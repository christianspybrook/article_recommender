towards certified analysis of software product line safety cases ramy shahin1 sahar kokaly2 and marsha chechik1 arxiv210500041v1 csse 30 apr 2021 university of toronto toronto canada rshahinchechikcstorontoedu general motors canada saharkokalygmcom abstract safetycritical software systems are in many cases designed and implemented as families of products usually referred to as software product lines spls products within an spl vary from each other in terms of which features they include applying existing analysis techniques to spls and their safety cases is usually challenging because of the potentially exponential number of products with respect to the number of supported features in this paper we present a methodology and infrastructure for certified lifting of existing singleproduct safety analyses to product lines to ensure certified safety of our infrastructure we implement it in an interactive theorem prover including formal definitions lemmas correctness criteria theorems and proofs we apply this infrastructure to formalize and lift a change impact assessment cia algorithm we present a formal definition of the lifted algorithm outline its correctness proof with the full machinechecked proof available online and discuss its implementation within a model management framework keywords safety cases product lines lean certified analysis introduction the development of safetycritical systems usually involves a rigorous safety engineering process a primary artifact resulting from that is a safety case identifying potential safety hazards their mitigation goals and pieces of evidence required to show that goals have been achieved safety cases together with other system artifacts are usually inspected and analyzed by tools as a part of the safety engineering process in safetycritical domains correctness of those tools is essential to the integrity of the whole process correctness certification of tools wrt their specifications becomes of extremely high value in this context in many cases families of safetycritical software products are developed together in the form of software product lines spls different product variants of an spl have different features ie externally visible attributes such as a piece of functionality support for a particular peripheral device or a performance optimization each feature can be either present or absent in each of the product variants of an spl given this combinatorial nature of feature composition analyzing the safety of each product instance individually in a bruteforce fashion is usually intractable ramy shahin sahar kokaly and marsha chechik fig 1 lifted change impact assessment when the visual class is modified a dashed ellipse around the visual class denotes a modification and dashed ellipses around safety case elements indicate that they need to be rechecked as a result several sourcecode and modelbased analysis tools have been lifted to product lines 2412920252322 in the sense that they can be applied efficiently to the whole product line at once leveraging the commonalities between individual products and thus generating aggregated results for the complete set of products those results have to be correct with respect to applying the analysis to each product individually however to the best of our knowledge lifting of safety analyses has not been attempted before in this paper we present a systematic methodology to correctbyconstruction lifting of safety case analysis algorithms to software product lines this includes infrastructure building blocks for implementing lifted algorithms and proving their correctness with respect to their singleproduct counterparts we use the lean interactive theorem prover 18 to formalize the correctness criteria of lifting implement our lifting infrastructure and prove the correctness of lifted algorithms a lean proof is machinechecked so it can be used as a correctness certificate of the property being proven we demonstrate our approach on a change impact assessment cia algorithm 15 that takes a system model an assurance case traceability links in between and a modification to the system model as inputs and determines the set of safety case elements that need to be revised or rechecked motivating example consider the lane management system lms system outlined in 4 lms can be thought of as a product line with several features including lane departure warning system ldws audio warning audio and visual warning visual for simplicity of presentation we assume that all feature combinations are allowed fig 1 shows a snippet of the class diagram of the lms product line and the corresponding snippet of its gsn 13 assurance case with traceability links in between the two we use colored annotations to map class diagram and gsn elements to features for example elements colored in green belong to the audio feature and towards certified analysis of software product line safety cases those in orange belong to the ldws feature base system elements existing in all products are in yellow in general each element can be annotated by a propositional formula over features usually referred to as a presence condition consider a modification to the visual class the problem cia algorithms try to solve is figuring out how that modification of a system element would impact the safety case we distinguish between two ways in which a change to the system can impact safety case elements 15 1 revise the content of the element eg definition of a goal or description of a solution may have to be revised because it referred to a system element that has changed and the semantics of the content may have changed and 2 recheck the state of the element eg whether a goal is satisfied or a solution is available must be rechecked because it may have changed in a product line setting in addition to figuring out which elements are impacted we also need to identify the product variants in which they are in fig 1 goals g19 and g20 are directly impacted by modifications to class visual because of the direct traceability links both classes need to be rechecked as a result but only in products where the visual feature is included in the same set of products pieces of evidence linked to those goals sn4 sn11 sn18 need to be rechecked as well note that although g20 sn4 and sn18 belong to all product variants we do not need to recheck them in product variants not including the visual feature a cia tool lifted to product lines has to preserve the exact semantics of its singleproduct counterpart in other words using the lifted tool should output exactly the union of outputs of the singleproduct tool applied to each product variant a software bug in the lifted tool might result in false positives elements marked as impacted while they should not even worse a bug might result in overlooking an impacted element potentially resulting in safety incidents contributions in this paper we 1 outline a methodology for lifting safety analyses to safety cases of software product lines and present a generic infrastructure for certified lifting data structures and correctness criteria using the lean interactive theorem prover and 2 demonstrate our methodology on a cia algorithm lifted to software product lines ie supporting the input of featurespecific modifications and outputting featurespecific annotations of safety case elements in addition 3 we formalize the singleconfiguration cia algorithm from 15 using lean 4 we outline a sketch of the correctness proof of the lifted cia algorithm with respect to the singleconfiguration one full lean proof available online and 5 we discuss extending mminta 7 model management framework with lifted safety algorithms including lifted cia organization the rest of this paper is organized as follows in sec 2 we provide background on safety cases and spls we outline the correctness criteria methodology and infrastructure needed to formally lift safety case algorithms in sec 3 in sec 4 we formalize the original singleconfiguration cia algorithm its lifted counterpart and outline the lifting correctness proof sec 5 explains how lifted algorithms can be integrated into existing model management tools sec 6 compares our approach to related work and sec 7 concludes ramy shahin sahar kokaly and marsha chechik background 21 safety cases gsn and change impact assessment a safety case is a structured argument decomposing safety goals into subgoals and linking pieces of safety evidence to the goals safety goals are usually identified using hazard assessment techniques each of the hazards needs to be mitigated by fulfilling one or more safety goals goal structured notation gsn 13 is a graphical notation for defining safety cases the safety case portion of fig 1 is an example of a gsn safety case model a gsn model has elements of four different types a goal is either satisfied or not based on the states of its subgoals connected solution nodes and the semantics of decomposition strategy nodes involved a solution is a piece of evidence that needs to be validated for its connected goals to be satisfied a strategy is a decomposition of a goal into subgoals a context connected to a goal node adds contextual assumptions that are assumed to hold when evaluating whether a goal is satisfied or not gsnia 15 is an algorithm for reflecting changes made in system models onto the relevant gsn safety cases the inputs to gsnia are the initial system model s and a safety case a connected by a traceability mapping r the changed system s 0 and the delta d recording the changes between s and s 0 specifically d is the triple hc 0a c 0d c 0mi where c 0a c 0d and c 0m are the set of elements added deleted and modified respectively the output of gsnia is the annotated model k of the safety case a indicating which elements are marked for revise recheck or reuse gsnia is parameterized by three slicers 21 a system model slicer slicesys and two safety case slicers slicegsnv and slicegsnr slicesys is used to determine how the impact of modifications propagates within the system model similarly the safety case slicers trace through dependencies within the safety case with slicegsnv only tracing direct dependencies while slicegsnr recursively generates the transitive closure of dependencies 22 software product lines we introduce software product line spl concepts following definitions from 20 an spl l is a tuple f d where 1 f is the set of features st an individual product can be derived from l via a feature configuration f 2  propf is a propositional formula over f defining the valid set of feature configurations is called a feature model fm the set of valid configurations defined by is called confl 3 d is a set of program elements called the domain model the whole set of program elements is usually referred to as the 150 representation 4 d propf is a total function mapping each program element to a proposition feature expression defined over the set of features f e is called the presence condition pc of element e ie the set of product configurations in which e is present given a product line l and a feature configuration we define l to be the subset of elements of l that belong to at least one of the features in we loosely use the same indexing operator when referring to subsets of values in a data structure subject to a feature configuration for example given a feature towards certified analysis of software product line safety cases def pc prop structure var type v pc pc def set0 type type pc def index s set0 pc pc set and pc s def mem x var s set0 prop xpc s xv def subset s1 s2 set0 prop a mem a s1 mem a s2 def union s1 s2 set0 set0 x s1 x s2 x def image f s set0 set0 x y f y x s y listing 1 variabilityaware building blocks configuration ldws visual a product with all the elements except for the ones annotated in green is instantiated from the product line fig 1 methodology and infrastructure in this section we present a set of generic infrastructure building blocks that can be used in designing and certifying the correctness of variabilityaware algorithms applied to safety cases we then present the correctness criteria of variabilityaware algorithms with respect to their singleproduct counterparts finally we put the infrastructure together with the correctness criteria into a correctbyconstruction methodology for systematic lifting of safety case algorithms we formalize algorithms theorems and proofs using the lean 18 interactive theorem prover we had two requirements for the proof assistant to be used in this project 1 to be based on constructive rather than classical logic to allow for explicit tracing of which subgoals and their proof evidence contribute to the overall proof and 2 to allow for sound userdefined proof automation procedures which can reduce the human effort involved in the proof development process lean meets those two requirements it is based on the calculus of inductive constructions 1 so it supports constructive logic by default it also supports tacticbased metaprogramming of theorems and proof objects lifted data structures the types of all input output and intermediate data structures of an algorithm need to be lifted ie elements of each of those data structures need to be paired with presence conditions indicating the set of products this element belongs to listing 1 has definitions of some of the data types used for lifted data structures pc line 1 is the type for presence conditions which is defined as native lean propositions var line 2 is a higherorder lifted type taking a type as a parameter and pairing values of type with presence conditions the lifted set data type set0 line 3 is a higherorder type parameterized by type and implemented as a function pc this implementation happens to be the same as the implementation of lean sets however the semantics of lean sets assume that a value of type is either present or absent in a set over lifted sets on the other hand map an element of type to an arbitrary propositional formula which might evaluate to true ie the element exists in the set in all configurations false ie the element does not exist in any configuration of the set or a contingent formula indicating the set of configurations in which the element exists in the set ramy shahin sahar kokaly and marsha chechik a correctness of a lifted function 22 b correctness of lifted function composition fig 2 lifting correctness criteria variables f set set g set set variables f0 set0 set0 g0 set0 set0 theorem funcompcorrect  a f a f0 a b g b g0 b  a g f a g0 f0 a listing 2 lifted function composition theorem the primary operation on lifted data types in general is indexing given a lifted set s and a presence condition pc index s pc evaluates to a lean set not lifted of elements existing in the configurations satisfied by pc in s this is exactly how the index operator is defined on set0 conjoining pc with the presence condition of each element in s line 4 standard set operations also need to be overloaded for lifted sets lifted set membership semantically checks if a lifted value vpc exists in all configurations of a lifted set s it is defined line 5 as a propositional implication between pc the set of configurations where the lifted value exists and the set of configurations where v exists in s lifted subset is defined exactly the same as standard subset using the lifted definition of set membership line 6 similarly lifted set union is implemented as a disjunction of the propositional definitions of its two arguments line 7 the last lifted set operation is image line 8 taking a function f and a lifted set s of and applies f to each element s returning a lifted set of correctness criteria given a product line l an analysis algorithm f and a product configuration we construct a lifted version of f referred to as f 0 such that instantiating a product p from l using configuration and then applying f to p has the same result as applying f 0 to l and then instantiating a productspecific result using this is summarized by the commuting diagram in fig 2a 22 lifting methodology we follow a divideandconquer methodology to design lifted analyses from their singleproduct counterparts if an analysis algorithm is brokendown into smaller functions and each of those functions is individually lifted composing the lifted functions together has to preserve the correctness criteria this is summarized in fig 2b we formulate the correctness criteria of lifted function composition as a theorem listing 2 assume we have two functions fset set and gset set and two lifted functions f0 set0 set0 and g0 set0  set0 line 2 the theorem states that if f0 is a correct lifting of f and g0 is a correct lifting of g then g0 f0 is a correct lifting of g f lines 35 towards certified analysis of software product line safety cases inductive annotation type  reuse recheck revise constants sysel gsnel type def sys  type set sysel def gsn  type set gsnel def tracerel type set sysel gsnel variable slicesys s sys es set sysel sys variable slicegsnv ac gsn es set gsnel gsn variable slicegsnr ac gsn es set gsnel gsn structure delta add set sysel delete set sysel modify set sysel listing 3 type definitions of the formalized gsn ia algorithm the theorem is proven by term rewriting definitions of all theorems lemmas and their full lean proofs are available online3 correctness of the lifted function composition theorem is the foundation of compositional lifting correctness proofs small helper functions can be manually lifted and proven correct relatively easily and their correctness proofs can be composed together with composing the functions themselves using the theorem this way lifted analyses can be compositionally implemented following the same structure of their singleproduct counterparts composing correctness proofs together with function composition we demonstrate this methodology on lifting a change impact assessment cia algorithm in sec 4 changed impact assessment in this section we formalize the gsnia 15 impact assessment algorithm systematically design a lifted version of it and prove its correctness based on the methodology in sec 3 41 singleproduct algorithm the data types and external dependencies of the gsn ia algorithm are defined in listing 3 annotation is the data type of annotations assigned to gsn model elements with the values reuse recheck and revise lines 12 sysel and gsnel are opaque types of system model elements and gsn model elements respectively where a system model sys and a gsn model gsn are sets of each of those elements types lines 46 tracerel is a traceability relation between system model elements and gsn model elements so it is a defined as a set of ordered pairs of sysel and gsnel line 7 gsn ia is parameterized by three model slicers slicesys is a system model slicer while slicegsn v and slicegsn r are gsn model slicers each of the slicers takes a model and a set of elements used as the slicing criterion returning a subset slice of the input model lines 911 delta is composed of three sets of system elements representing the elements added modified and deleted lines 12 listing 4 has the definitions of the gsn ia algorithm together with three helper functions restrict is a function taking a traceability relation t and a httpsgithubcomramyshahinvariability ramy shahin sahar kokaly and marsha chechik def restrict t tracerel d delta tracerel  x x1 dadd ddelete dmodify def trace t tracerel es set sysel set gsnel image prodsnd p p t p1 es def createannotation g gsn recheck set gsnel revise set gsnel  set gsnel annotation let ch image e e annotationrecheck recheck rv image e e annotationrevise revise ru image e e annotationreuse g recheck revise in ch rv ru def gsnia s sys s0 sys a gsn r tracerel d delta  set gsnel annotation let r0  restrict r d c1dm  slicesys s delete d modify d c1am  slicesys s0 add d modify d c2recheck trace r c1dm trace r0 c1am c2revise  trace r delete d c3recheck1 slicegsnv a c2revise c3recheck2 slicegsnr a c2recheck c3recheck1 in createannotation a c3recheck2 c2revise listing 4 helper functions and the formalized gsn ia algorithm delta es as inputs and returns a restricted subset of t only covering elements in es lines 12 trace takes a traceability relation t and a set of system elements es as inputs and returns the set of gsn elements mapped from es by t lines 45 createannotation assigns an annotation value to each element in a gsn model given sets of elements to be rechecked and revised lines 712 the change impact assessment algorithm gsn ia takes two system models s and s0 and the delta d between them it also takes a gsn model a and a traceability relation r between system model elements and gsn model elements it returns a set of ordered pairs of gsn model elements and annotations the algorithm starts by restricting the traceability relation based on d slices the original system model s using the elements deleted and modified as a slicing criterion and slices the modified system model s0 using the added and modified elements as the slicing criterion lines 1618 using those two slices the corresponding gsn model elements are traced using the traceability relation line 19 the gsn elements traced from elements deleted from the original system model are to be revised line 20 the slice of the gsn model based on the traced elements are to be rechecked lines 2122 and both revise and recheck sets are used to annotate the gsn model elements line 23 lifted algorithm listing 5 is the variabilityaware version of the algorithm in listing 4 both algorithms are compositions of functionoperator calls so each of those functionsoperators is replaced with its lifted counterpart we assume that lifted towards certified analysis of software product line safety cases def sys0 type set0 sysel def gsn0 type set0 gsnel def tracerel0 type set0 sysel gsnel structure delta0 add set0 sysel delete set0 sysel modify set0 sysel def gsnia0 s s0 sys0 a gsn0 r tracerel0 d delta0  set0 gsnel annotation let r0  restrict0 r d c1dm  slicesys0 s ddelete dmodify c1am  slicesys0 s0 dadd dmodify c2recheck trace0 r c1dm trace0 r0 c1am c2revise  trace0 r ddelete c3recheck1 slicegsnv0 a c2revise c3recheck2 slicegsnr0 a c2recheck c3recheck1 in createannotation0 a c3recheck2 c2revise listing 5 lifted change impact assessment algorithm versions of the three slicers are provided and that they meet the correctness criteria of fig 2a all the set types used in gsn ia need to be lifted definitions in lines 14 are lifted sets of system model elements gsn model elements and traceability mappings a lifted delta line 4 is composed of three lifted sets additions deletions and modifications the proof of the correctness theorem used auxiliary correctness lemmas for each of the helper algorithms each of the proofs expands definitions and repeatedly applies the correctness of lifted function composition fig 2b lifted helper algorithms since the lifted cia algorithm operates on lifted data structures all helper algorithms need to be modified to correctly operate on lifted data structures as well in particular we outline lifted versions of restrict and trace listing 6 the original implementation of restrict takes a traceability map and a delta as inputs and returns the minimal subset of the traceability map that covers all the elements in the delta we now have presence conditions associated to system model elements assurance case elements and also the traceability links in between the lifted version of restrict referred to as restrict0 needs to correctly process all those presence conditions the lifted algorithm starts by calculating the set of relevant elements in the system model which is the union of added deleted and modified elements in the delta line 2 the algorithm returns a lifted traceability mapping as a function taking sgpc where sg is a system model elementgsn model element pair and pc is a presence condition this function evaluates to the conjunction of applying the input traceability map t to sgpc and applying relevant to sg recall that variabilityaware sets as well as lean sets are functions mapping values of a given type to propositions similarly trace0 is the lifted version of trace the returned lifted set is a function mapping a gsn model element g to the set of configurations from ramy shahin sahar kokaly and marsha chechik def restrict0 t tracerel0 d delta0 tracerel0 let relevant dadd ddelete dmodify in x t x relevant x1 theorem gsnia0 correct  s s0 sys0 a gsn0 r tracerel0 d delta0 pc pc gsnia0 s s0 a r d pc gsnia s pc s0 pc a pc r pc d pc def trace0 t tracerel0 es set0 sysel set0 gsnel  ggsnel s sysel es s t hs gi listing 6 lifted implementation of restrict and trace listing 7 correctness theorem of gsn ia0 which there exists a system model element s in the input lifted set of system elements where sg belongs to the input traceability map the lifted version of createannotation named createannotation0 is of exactly the same structure as the original because it strictly uses set operations union set difference and image which have been all lifted as a part of the underlying variabilityaware set implementation listing 1 the correctness theorem of gsn ia0 with respect to gsn ia is in listing 7 it is a direct instantiation of the general correctness criteria in fig 2a applied to inputs of the gsn ia algorithm 43 examples in this section we apply our lifted cia algorithm to two examples of modifications to the fragment of the lms product line presented in sec 1 fig 1 ex1 featurespecific modification suppose that the visual class is modified this class is local to the visual feature if we only analyze the fragment in fig 1 the inputs to gsnia0 are shown in fig 3a and fig 3b tracing through the algorithm the first step is using restrict0 to calculate r visual g19 visual visual g20 visual line 8 because c0a and c0d are both empty and assuming a backward slicer returning the transitive closure of the elements that might affect the slicing criteria c1dm and c1am both become alarm true visual visual lanedeparturewarningsystem ldws lines 910 now tracing from c1dm and c1am c2recheck becomes g19 visual g20 visual line 11 since c0d is empty c2revise and c3recheck1 are both empty as well lines 1213 using a backward gsn slicer c3recheck2 becomes g19 visual g20 visual sn11 visual sn4 visual sn18 visual line 14 the algorithm returns an empty set of gsn elements to be revised and the set c3recheck2 to be rechecked note that g20 sn4 and sn18 are all base model elements having true as a presence condition so the algorithm output states that we need to recheck those elements only in products where the feature visual is present ex2 base system modification suppose that the alarm class is modified this is a base system class ie it is present in all products the inputs to gsnia0 restricted to the fragment in fig 1 are shown in fig 3a and fig 3c towards certified analysis of software product line safety cases a g5 tt sn3 tt s 8 tt g18 audio g19 visual g20 true sn4 tt sn18 tt sn12 audio sn11 visual r visual g19 visual visual g20 visual audio g18 audio audio g20 audio a assurance case elements a and traceability links r used in ex1 and ex2 s alarm true userinterface true audio audio visual visual lanedeparturewarningsystem ldws s 0 alarm true userinterface true audio audio visual 0 visual lanedeparturewarningsystem ldws d h visual visuali b system model s modified system model s and delta d used in ex1 s alarm true userinterface true audio audio visual visual lanedeparturewarningsystem ldws s 0 alarm 0 true userinterface true audio audio visual visual lanedeparturewarningsystem ldws d h alarm truei c system model s modified system model s and delta d used in ex2 fig 3 inputs to the gsnia0 algorithm used in ex1 and ex2 since the alarm class does not have any direct traceability links r 0 is empty line 8 using a backward slicer like in ex1 c1dm and c1am both become alarm true visual visual audio audio lanedeparturewarningsystem ldws lines 910 from c1dm and c1am using the traceability links c2recheck becomes g18 audio g19 visual g20 visual line 11 again since c0d is empty c2revise and c3recheck1 are both empty as well lines 1213 with a backward gsn slicer c3recheck2 becomes g18 audio g19 visual g20 visual audio sn11 visual sn12 audio sn4 visual audio sn18 visual audio line 14 the algorithm returns an empty set of gsn elements to be revised and the set c3recheck2 to be rechecked note that in this example g20 sn4 and sn18 are annotated with recheck with presence condition visual audio which means that they need to be rechecked only if either audio or visual are present towards implementation the gsnia algorithm is implemented together with slicers and model operators as an extension of the mmint 6 model management framework fig 4 called mminta 7 in order to extend mminta to support annotative product line models and subsequently the lifted change impact assessment algorithm the following modifications are required 1 model elements need to be extended with presence conditions with true as a default value this way single product models where all elements have the default true presence condition are directly supported as well 2 operators on models need to be modified to take presence conditions into consideration and compute the presence conditions of their outputs those modifications are mostly systematic along the lines of those of restrict0 and trace0 listing 6 3 higherlevel algorithms eg gsnia ramy shahin sahar kokaly and marsha chechik modelrel editor mid editor mmint workflow editor type mid model operators metamodels type support runtime eclipse platform emf model editors gmf ocl mmint plugins sirius eclipse fig 4 architecture of the mmint model management framework 7 need to be modified accordingly to use the lifted versions of the operators 4 the user interface of mminta needs to support annotating different model elements with presence conditions 5 optionally mminta can check the wellformedness of presence condition annotations for example the presence condition of an association between two uml classes has to be subsumed by the presence conditions of its two end points related work modelbased approaches to safety case management many methods for modeling safety cases have been proposed including goal models and requirements models 103 and gsn 13 the latter is arguably the most widely used modelbased approach to improving the structure of safety arguments building on gsn habli et al 11 examine how modeldriven development can provide a basis for the systematic generation of functional safety requirements and demonstrates how an automotive safety case can be developed gallina 8 proposes a modeldriven safety certification method to derive arguments as goal structures given in gsn from process models the process is illustrated by generating arguments in the context of iso 26262 we consider this category of work complimentary to ours we do not focus on safety case construction but instead assume presence of a safety case and focus on assessing the impact of system changes lifting to software product lines different kinds of software analyses have been reimplemented to support product lines 24 for example the typechef project implements variability aware parsers and type checkers for java and c 12 the superc project 9 is another c language variabilityaware parser a graph transformation engine was lifted to product lines of graphs 20 datalogbased analyses eg pointer analysis have been lifted by modifying the datalog engine being used 23 spllift 2 lifts data flow analyses to annotative product lines model checkers based on featured transition systems 5 check temporal properties of transition systems where transitions can be labeled by presence conditions syntactic transformation techniques have been suggested for lifting abstract interpretation analyses 17 and functional analyses 22 to spls in this paper our methodology tailors the lifting approach from related work to safety cases of product lines and we demonstrate it on change impact assessment we tackle a new class of product line artifacts particularly safety cases towards certified analysis of software product line safety cases to the best of our knowledge this is the first attempt to lift a safety case analysis to product lines formalized systems and interactive theorem proving correctness and behavioral properties of several software systems have been formalized and verified using interactive theorem provers the compcert compiler 16 is an example of a clanguage compiler fully certified using the coq theorem prover the sel4 microkernel 14 was verified using the isabellehol theorem prover isabelle was also used to formalize the structured assurance case metamodel sacm notation for certified definition of assurance cases 19 conclusion and future work in this paper we presented a methodology for lifting safety case analysis algorithms to software product lines we also outlined a certification infrastructure data structures and correctness criteria for our lifting approach using the lean interactive theorem prover we demonstrated both the approach and correctness certification on formalizing and lifting a change impact assessment cia algorithm 15 we discussed the implementation of the lifted cia algorithm as part of the safety model management system mminta 7 a lifted cia algorithm allows for reusing impact assessment conclusions across a potentially exponential in number of features different product variants as opposed to using a productlevel cia algorithm in individual product instances which is intractable in most cases for future work we are working together with an industrial partner on applying our lifted algorithm to their assurance case models we also plan to lift other safety case algorithms including slicers and add their implementations to mminta visualization of the analysis results and improved user interaction is another area of future improvements references 1 bertot y castran p interactive theorem proving and program development coqart the calculus of inductive constructions springer publishing company incorporated 1st edn 2010 2 bodden e toldo t ribeiro m brabrand c borba p mezini m spllift statically analyzing software product lines in minutes instead of years in proc of pldi13 pp 355364 acm 2013 3 brunel j cazin j formal verification of a safety argumentation and application to a complex uav system in proc of safecomp12 wkshp 2012 4 chechik m kokaly s rahimi m salay r viger t uncertainty modeling and safety assurance towards a unified framework 5 classen a cordy m schobbens py heymans p legay a raskin jf featured transition systems foundations for verifying variabilityintensive systems and their application to ltl model checking ieee trans softw eng 398 10691089 aug 2013 6 di sandro a salay r famelis m kokaly s chechik m mmint a graphical tool for interactive model management in proc of models demo 2015 ramy shahin sahar kokaly and marsha chechik 7 fung nls kokaly s di sandro a salay r chechik m mminta a tool for automated change impact assessment on assurance cases in proc of safecomp18 wkshp pp 6070 2018 8 gallina b a modeldriven safety certification method for process compliance in proc of issre14 workshops pp 204209 ieee 2014 9 gazzillo p grimm r superc parsing all of c by taming the preprocessor in proc of pldi12 pp 323334 acm 2012 10 ghanavati s amyot d peyton l a systematic review of goaloriented requirements management frameworks for business process compliance in proc of relaw11 pp 2534 ieee 2011 11 habli i ibarra i rivett rs kelly t modelbased assurance for justifying automotive functional safety tech rep sae 2010 12 kstner c apel s thm t saake g type checking annotationbased product lines acm trans softw eng methodol 213 1411439 jul 2012 13 kelly t weaver r the goal structuring notation a safety argument notation in proc of dsn04 2004 14 klein g elphinstone k heiser g andronick j cock d derrin p elkaduwe d engelhardt k kolanski r norrish m et al sel4 formal verification of an os kernel in proceedings of the acm sigops 22nd symposium on operating systems principles pp 207220 2009 15 kokaly s salay r chechik m lawford m maibaum t safety case impact assessment in automotive software systems an improved modelbased approach in proc of safecomp17 pp 6985 springer 2017 16 leroy x a formally verified compiler backend journal of automated reasoning 434 363446 2009 httpxavierleroyorgpublicompcertbackend pdf 17 midtgaard j dimovski as brabrand c wsowski a systematic derivation of correct variabilityaware program analyses sci comput program 105c 145170 jul 2015 18 de moura l kong s avigad j van doorn f von raumer j the lean theorem prover system description in felty ap middeldorp a eds automated deduction cade25 springer international publishing 2015 19 nemouchi y foster s gleirscher m kelly t isabellesacm computerassisted assurance cases with integrated formal methods in ahrendt w tapia tarifa sl eds proc of ifm19 pp 379398 2019 20 salay r famelis m rubin j di sandro a chechik m lifting model transformations to product lines in proc of icse14 acm ny usa 2014 21 salay r kokaly s chechik m maibaum t heterogeneous megamodel slicing for model evolution in proc of memodels16 pp 5059 2016 22 shahin r chechik m automatic and efficient variabilityaware lifting of functional programs proc acm program lang 4oopsla nov 2020 23 shahin r chechik m salay r lifting datalogbased analyses to software product lines in proc of esecfse19 acm new york ny usa 2019 24 thm t apel s kstner c schaefer i saake g a classification and survey of analysis strategies for software product lines acm comput surv 471 61645 jun 2014 