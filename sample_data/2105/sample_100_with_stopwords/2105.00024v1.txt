arxiv210500024v1 cslo 30 apr 2021 types are internal groupoids extended version eric finster antoine allioux matthieu sozeau cambridge university department of computer science ericfinstergmailcom inria irif universit de paris france antoinealliouxiriffr inria ls2n universit de nantes france matthieusozeauinriafr abstractby extending type theory with a universe of definitionally associative and unital polynomial monads we show how to arrive at a definition of opetopic type which is able to encode a number of fully coherent algebraic structures in particular our approach leads to a definition of groupoid internal to type theory and we prove that the type of such groupoids is equivalent to the universe of types that is every type admits the structure of an groupoid internally and this structure is unique i i ntroduction homotopy type theory has brought a new perspective to intensional martinlf type theory the higher identity types of a type endow it with the structure of an groupoid and ideas from homotopy theory provide us with a means to predict and understand the resulting tower of identifications while this perspective has been enormously clarifying with respect to our understanding of the notion of proofrelevant equality leading as it has to a new class of models as well as new computational principles a number of difficulties remain in order to complete the vision of type theory as a foundation for a new structural mathematics based on homotopytheoretic and higher categorical principles foremost among these difficulties is the following how does one describe a well behaved theory of algebraic structures on arbitrary types the fundamental difficulty in setting up such a theory is that in a proof relevant setting nearly all of the familiar algebraic structures monoids groups rings and categories to take a few become infinitary in their presentation indeed the axioms of these theories which take the form of a finite list of mere properties when the underlying types are sets constitute additional structure when they are no longer assumed to be so consequently in order to arrive at a wellbehaved theory the axioms themselves must be subject to additional axioms frequently referred to generically as coherence conditions in short in a proof relevant setting it no longer suffices to describe the equations of an algebraic structure at the first level of equality rather we must specify how the structure behaves throughout the entire tower of identity types and this is an infinite amount of data how do we organize and manipulate this data similar problems have arisen in the mathematics of homotopy theory and higher category theory and many solutions and techniques are known bafflingly however all attempts to import these ideas into plain homotopy type theory have so far failed this appears to be a result of a kind of circularity all of the known classical techniques at some point rely on setlevel algebraic structures themselves presheaves operads or something similar as a means of presenting or encoding higher structures internally to type theory however we do not have recourse to such techniques indeed without further hypotheses we do not even expect that the most basic objects of the theory types themselves are presented by setlevel structures this leaves us in a strange position absent a theory of algebraic structures we have nothing to use to encode algebraic structures we suggest that a possible explanation for this phenomenon is the following contrary to our experience with setlevel mathematics where an algebraic structure ie a structured set can itself be defined just in terms of sets underlying sets functions sets of relations and so on when we pass to the world of homotopy theoretic mathematics the notion of type and structured type are simply no longer independent of each other in the same way consequently some primitive notion of structured type must be defined at the same time as the notion of type itself the present work is a first attempt at rendering this admittedly somewhat vague idea precise we begin by imagining a type theory which in addition to defining a universe u of types defines at the same time a universe s of structures of course we will need to be somewhat more precise about what exactly we mean by structure category theory suggests that one way of representing a structure is by the monad on u which it defines so we might think of s as a universe of monads in practice however it will be useful to restrict to a particularly well behaved class of monads having reasonable closure properties and for which we have a good understanding of their higher dimensional counterparts we submit that a reasonable candidate for such a wellbehaved collection is the class of polynomial monads 1 we feel that this is an appropriate class of structures for a number of reasons a first reason is that this class of monads arises quite naturally in type theory already indeed a large literature exists on the interpretation of inductive and coinductive types as initial algebras and terminal coalgebras for polynomial monads and we consider our work as deepening and extending this connection furthermore this class of algebraic structures enjoys some pleasant properties which make them particularly amenable to weakening for example the very general approach to weakening algebraic structures developed by baez and dolan in 2 can be smoothly adapted to the polynomial case while the cited work employs the language of symmetric operads connections with the theory of polynomial functors were already described in 3 and moreover recent work 4 has shown that in type theory we should expect symmetric operads to in fact be subsumed by the theory of polynomial monads the central intuition of baez and dolans approach is that each polynomial monad m determines its own higher dimensional collection of shapes the m opetopes generated directly from the syntactic structure of its terms they go on to introduce the notion of an m opetopic type which is roughly a collection of well formed decorations of these shapes and the notion of weak m algebra is then defined as an m opetopic type satisfying certain closure properties in this sense their approach differs from say approaches based on simplices cubes or spheres in that the geometry is not fixed ahead of time but adapted to the particular structure under consideration with these considerations in mind our plan in the present work is to put the idea of a type theory with primitive structures to the test what might it look like and what might it be able to prove in order to answer these questions we will build a prototype of the theory 1 in the proof assistant agda and exploit the recent addition of rewrite rules 5 which permits us to extend definitional equality by new welltyped reductions the use of such rewrites is necessary to ensure that our primitive structures are not subject to the same infinite regress of coherence conditions which has so far obstructed more naive attempts and defining such objects concretely we will introduce a universe m2 whose elements we think of as codes for polynomial monads and describe the structures they decode to because we think of the objects of the universe m as primitives of our theory on the same level as types we allow ourselves the freedom to prescribe their computational behavior in particular we will equip them with definitional associativity and unit laws using the rewrite mechanism alluded to above we emphasize that if structures are taken as defined in parallel with types then this kind of definitional behavior should be no more surprising than say the definitional associativity of function composition we then show how the existence of our universe m has some strong consequences in particular it allows us to implement the baez and dolan definition of opetopic type alluded to above and subsequently to define a number of weak higher dimensional structures among the structures which we are able to define using this technique are a monoids and groups  1categories and presheaves over them in particular our 1 the agda source is available here httpsgithubcomericfinster opetopictypes 2 we mean by this notation to distinguish the universe m of this particular implementation from the generic idea of a universe of structures s the properties of which we expect to be refined by further investigation setup leads to a definition of simplicial type and as a special case groupoids themselves there arises then the problem of justifying the correctness of our definitions in order to do so we will take up the example of groupoids in some detail indeed since the homotopical interpretation of type theory asserts that types should be groupoids it seems natural to compare these two objects our main result is the following theorem there is an equivalence u grp in other words every type admits the structure of an groupoid in our sense and that structure is unique this theorem therefore can be regarded as a constructive internalization of the intuition provided by the various metatheoretic results to this effect 6 7 a related work the socalled coherence problem which is the main motivation for the present work has been considered by a number of authors we briefly compare our approach with two prominent other strains of thought 1 synthetic structures one way to avoid some of the problems posed by the definition of higher dimensional structures is to simply enlarge the collection of basic objects to include them such approaches may be described as synthetic in that they do not reduce higher structures to more primitive objects in exactly the same way that homotopy type theory itself does not define groupoids in terms of sets this point of view is often adopted for example in the research into directed type theories whether they be aimed at specific structures like higher categories as in 8 or allow for more general directed spaces as in 9 while our theory does indeed add some new primitive structures to type theory we collect these structures in a universe and decode them into collections of ordinary types and maps between them moreover we go on to use these additional strict structures to give analytic internal definitions of higher structures 2 twolevel type theory perhaps the closest related work to the current approach is that of twolevel type theory 10 there it is advocated to add a second level to type theory with a settruncated equality type which one can then use to make metatheoretic statements about the inner level whose objects are typically taken to be the homotopically meaningful ones the twolevel approach provides thus a great deal of generality and flexibility at the cost of restricting the applicability of homotopical interpretation of types to the inner theory it is likely for example that our theory could be developed inside a twolevel system and many of the rewrites we employ proven as theorems in the outer level by constrast our approach is we feel somewhat more economical extending the theory with a specific set of rewrite rules and pointing towards the possibility of a useful theory of higher structures without the need to restrict homotopical principles like univalence b preliminaries the basis of our metatheory is the type theory implemented in agda 11 which is an extension of the predicative part of martinlf type theory 12 among the particular types that agda implements we shall use inductive types records and coinductive records as such we adopt a style similar to agda code writing x a b x for the dependent product although we ocq casionally also employ the xa b x notation if it improves readability we also make use of the implicit counterpart of the dependent products written x a b x this allows us to hide arguments which can be inferred from the context and hence clarify our notation nondependent functions are denoted a b as usual functions enjoy the usual conversion rule we shall make extensive use of coinductive record types as well as copatterns for producing elements of these types we write p  for the empty record with a constructor tt we write xa b x for the dependent sum as a record with constructor and projections fst and snd pairs which are not dependent are denoted a b we write for the empty type using absurd patterns where appropriate and writing elim for the unique function for to any type the identity type a u x y a u is an inductive type with one constructor refl x a x x we shall make use of the notion of contractible type denoted iscontr whose center of contraction will be referred to as ctr other notions defined in the hott book 13 will be employed including equivalence of types denoted x y function extensionality denoted funext as well as the univalence axiom we write u for the universe of small types and u1 for the next universe when necessary in order to unclutter and clarify the presentation we occasionally take liberties with the formal definitions for example silently inserting applications to functional extensionality when necessary or reassociating types in order to avoid a proliferation of commas our formal development in agda allows no such informalities to remain ii a u niverse of p olynomial m onads as we have explained in the introduction type theory appears to lack the ability to speak about infinitely coherent algebraic structures and our strategy for addressing this problem will be to distinguish a collection of such structures which we consider as defined by the theory itself we do so using a common technique in the type theory literature that of introducing a universe we write m u for our universe and we think of its elements as codes for polynomial monads just as a typical type theoretic universe has some collection of base types and some collection of type constructors so we will populate our universe with a collection of base monads and monad constructors in other words we will have a syntax of structures which parallels the syntax for types typically a universe of types u comes equipped with a decoding function el u u in the case of our universe of monads m each element m m will decode not to a single type but to a collection of types and type families equipped with some structure we will use rewrite rules to specify the computational behavior of this structure a polynomial structure to begin we first equip each m m with an underlying polynomial or indexed container 14 this is accomplished by postulating the following collection of decoding functions idx m u cns m m idx m u pos m m i idx m cns m i u typ m m i idx m c cns m i  pos m c idx m polynomials of this sort appear in the computer science literature as the data of a datatype declaration they can equivalently be seen as a way to describe the signature of an algebraic theory concretely the elements of idx m which we refer to as indices serve as the sorts of the theory and for i idx m the type cns m i is the collection of operation symbols whose output sort is i the type pos m c then assigns to each operation a collection of input positions which are themselves assigned an index via the function typ it follows that every monad m induces a functor idx m u idx m u called its extension given m x i p pos m c x typ m c p ccns m i we may think of the value of this functor at a type family x idx m u as the type of constructors of m with inputs decorated by elements of x indeed we will frequently refer to a dependent function of the form p pos m c x typ m c p where x is as above as a decoration of c by elements of x b monadic structure next for each monad m m we are going to equip the underlying polynomial of m with an algebraic structure specifically that structure required on the underlying polynomial so that the associated extension m becomes a monad in the case at hand this takes the form of a pair of functions  m m i idx m cns m i  m m i idx m c cns m i  p pos m c cns m typ m c p  cns m i which equip m with a multiplication and unit operation we remark that the second argument of the multiplication is a decoration of c in the family cns m of constructors so that we can think of the input to this function as a twolevel tree crucial for what follows will be that the monads we consider are cartesian in the sense of 1 type theoretically the means we require each monad m to come equipped with equivalences pos m m i pos m m c ppos m c pos m p  pos m m c pos m c in the case of for example we postulate introduction and elimination rules of the form pos m m i idx m pos m m i poselim m m i idx m  x p pos m m i u  u x pos m i  p pos m c cns m typ m c p  p pos m m c  pos m posfst m p with typing rule typ m m c p typ typ m posfst m p possnd m p and computation rules posfst m pos m p q p posfst possnd m pos m p q q possnd pos m posfst m p possnd m p pos with the handling of positions in place we can now state the unitality and associativity axioms for the monads in our universe these take the form of reductions  m m i  pos m i  m m c with typing rule typ and computation rule notice these are exactly the rules for an inductively defined indexed unit type3 in particular decorations of the constructor  m i in a type family x pos m m i u are completely determined by a single element x x i a fact which we record in the following definition to reduce clutter below dec m x i x poselim m i xi x next for the multiplication our rules simply mimic the pairing and projections of the dependent sum that is we postulate an introduction rule pos m m i idx m c cns m i  p pos m c cns m typ m c p  p pos m c q pos m p  pos m m c 3 in possnd m m i idx m c cns m i  m c p m typ m c p  p pos m m i x p poselim m i x u pos m i posfst m m i idx m c cns m i  p pos m c cns m typ m c p since we are already modifying the definitional equality of our type theory it may be tempting to require these equivalences definitionally by asserting that the type of positions reduces when applied to constructors of the appropriate form however this will not work as we will see below when we come to populate our universe with concrete monads and monad constructors the equivalences we find are often in fact not definitional even if they remain provable as an alternative we will equip each monad with introduction elimination and computation rules for its positions which will in effect guarantee that we always have the required equivalence each monad definition will then be required to implement these rules in a manner consistent with the various required typing laws typ m m i p and elimination rules principle we would also like to have an rule for the unit that is we would prefer the negative version as we have below for but unfortunately this is not possible with the current implementation of rewriting in agda  m c p m p q pos m p q additionally we must posit laws which assert that the constructors and eliminators for positions are compatible with these equations we omit these for brevity but the interested reader may consult the development for details while we will not undertake an extensive investigation of the metatheoretic properties of our system in this article we wish to pause briefly to make at least of few observations to justify its wellformedness for example there are critical pairs in the rewrite equations for the monad laws between the first equation and the others so we need to ensure confluence and termination lemma 1 strong confluence for and the rewrite rules are strongly confluent 15 hence globally confluent proof the rewrite system is strongly confluent using the rules typ and typ and the associated reduction rules for pos we show the case for r and l we omit m which is fixed here  i p typ i p  i p typ i p  p typ i p pos i  typ i pos i typ the resolution of the r pair can be found in the appendix of the extended version of this article 16 lemma since its extension induces the identity monad on u up to equivalence the polynomial part of id decodes as follows proposition 1 termination of rewriting all of the above rules form a terminating rewrite system proof the pos pos and typ rewrite rules are obviously terminating for typ r l and we need to use a dependencypairs path ordering as introduced by 17 to verify termination in particular for associativity a lexicographic lifting of the subterm relation is not enough to verify s termination as we are going under binders and applying the and functions to subterms this is a variant of the ordinal type eliminator proven to terminate in 17 example 14 p11 which requires to ensure that the constructor types of our monads are inductively generated all the monads considered in this article satisfy this the instances of the and operations for specific monads will themselves be defined by structural recursion on inductive datatypes and can be shown to respect the associativity and unitality laws prositionally results such as can be found in 5 lemma 68 therefore guarantee the consistency of the system furthermore we conjecture that the rewrite system is strongly normalizing in conjunction with the definitional equality of agda c populating the universe in the previous section we described the generic structure associated to every monad m m we now proceed to implement this structure in concrete cases describing in each case the most salient features and omitting unnecessary details where we feel it will improve the presentation complete definitions can be found in the agda formalization in the material which follows we allow ourselves the freedom to use standard techniques such as inductive definitions and pattern matching during the definition of each monad in practice this agrees with the implementation there we first define all the necessary structure using ordinary agda definitions and subsequently install rewrites which connect the decoding functions to their desired implementations so for example in order to define the indices of the identity monad see below we first make an ordinary agda definition ididx u ididx and then postulate the rewrite idx id idx id cns id tt pos id tt typ id tt tt  tt given the triviality of the associated polynomial it is perhaps not surprising that its unit and multiplication are equally trivial indeed they are given by  id i tt  id tt we omit the remaining structure which has a similar flavor 2 the pullback monad our first monad constructor starts from a monad m m and a family x idx m u and refines the indices of m by additionally decorating the inputs and output of each constructor by elements of x we refer to the resulting monad as the pullback of m along x cf 2 section 24 we implement this construction by first postulating a function pb m m x idx m u m which adds the necessary code to our universe we next define the polynomial part of pb m x as follows idx pb m x  iidx m x i cns pb m x i x ccns m i ppos m c x typ m c p pos pb m x c  pos m c typ pb m x c p  typ m c p p the unit for the pullback monad simply calls the unit of the underlying monad and decorates its input with the same value as its output  pb m x i x m i dec m x x as for the multiplication of the pullback monad it again simply calls the multiplication of the underlying monad this time decorating the result using the decorations of the secondlevel constructors and forgetting the intermediate decoration that is we have  pb m x c m c 0 0 where  0 p fst p  0 p snd posfst p possnd p ididx in the presentation which follows we omit this auxiliary step and just write when defining the structure associated to each monad 1 the identity monad we begin by adding a constant id m to the universe to represent the identity monad so named the remaining structure is easily worked out from these definitions and we omit the details 3 the slice monad the baezdolan slice construction is at the heart of the opetopic approach it is this construction which allows us to raise the dimension of the coherences in our algebraic structures in our setting it will take the form of a monad constructor slice m m the basic intuition is that for a monad m m the monad slice m may be described as the monad of relations in m in order to realize this intuition we have to find a way to encode the relations of m as some kind of data just as the identity type encodes the relations in an ordinary type as data this data will then serve as the constructors for the slice monad to begin for a monad m m let us define idx slice m iidx m cns m i that is the indices of the monad slice m are exactly the constructors of the monad m next we are going to capture the notion of relation in m with the help of a certain inductive family defined as follows data tree idx slice m u where by position p typ slice m lf i typ slice m nd i c inl tt  i c typ slice m nd i c inl p q typ slice m p q it remains to describe the unit and multiplication of the slice monad in accordance with the general laws for monads the unit constructor needs to have a unique position and since the positions of a given tree are given by occurrences of constructors this implies that the unit at a given constructor c should be the corolla that is a tree with one node consisting of c itself therefore we set  slice m i c nd c p m typ m c p lf i idx m tree i m i  p lf typ m c p nd i idx m c cns m i  p pos m c cns m typ m c p  p pos m c tree typ m c p p  tree i m c and we define cns slice m tree the reader familiar with the theory of inductive types may recognize this as a modified form of the indexed w type associated to a polynomial or indexed container here as in that case the elements of this type are trees generated by the constructors of the polynomial in question the underlying polynomial of m in the case at hand the difference in the present setup is that our polynomial is equipped with a multiplication and unit and we reflect this fact by indexing our trees not just over the indices as is typically the case but also over the constructors applying the multiplication and unit as appropriate the result is that we may view an element cns slice m i c as a tree generated by the constructors of m whose image under iterated multiplication is c it is in this sense that this definition captures the relations in the original monad m we now turn to the rest of the structure required to complete the definition of slice m intuitively speaking the positions of a tree will be its internal nodes this can be accomplished by defining the positions by recursion on the constructors as follows pos slice m lf i pos slice m nd c note that this definition would not be type correct without the assumption that m is definitionally right unital a similar remark applies to the rest of the definitions of the slice monad in this section indeed it is exactly the problem of completing the definition of the slice monad without any assumptions of truncation which motives the introduction of our monadic universe in the first place let us now sketch the definition of the multiplication in the slice monad as hypotheses we are given a tree cns slice m i c for some i idx m and c cns m i as well as a decoration  p pos slice m cns slice m typ slice m p in view of the preceding discussion this means that assigns to every position of a tree which multiplies to the constructor which inhabits that position the multiplication of slice m may intuitively be described as substituting each of these trees into the node it decorates the definition of slice m will require an auxillary function with the following type  m m i idx m c cns m i  cns slice m i c  p pos m c cns m typ m c p  p pos m c cns slice m typ m c p p  cns slice m i m c pos slice m p ppos m c in other words if our tree is a leaf it has no positions and if it is a node its positions consist of either the unit type to record the current node or else the choice of a position of the base constructor and recursively a node of the tree attached to that position finally the typing function typ slice m p just projects out the constructor of m occurring at the node of specified the intuition of this function is that grafts the tree specified by onto the appropriate leaf of the tree indeed may be seen as an incarnation of multiplication in the free monad generated by the underlying polynomial of m this function simply operates by induction and may be defined as follows  m lf i  pos m i  m nd c  nd c 0 0 where we define 0 p q pos m c p q  0 p q pos m c p q  p m p p 0 p m p 0 p with this function in hand we may complete the definition of the multiplication in the slice monad as  slice m lf i  lf i  slice m nd c  m w where we put of the definitions fiberwise and since the dependent case resembles so closely the nondependent one we have attempted to systematically name dependent versions of the the monadic structure introduced above by appending a to the previously given name for example idx for the dependent version of the family idx of indices as a first step a dependent monad will be equipped with a polynomial lying over the base polynomial this corresponds to the following three dependent families idx m m m m idx m u w inl tt 0 p q inr p q  p slice m p 0 p this definition then says that substitution is trivial on leaves and when we are looking at a node we first retrieve the tree living at this position called w above and then graft to it the result of recursively substituting in the remaining branches we refer the reader to the formalization for details on the remaining constructions handling positions in the slice monad d dependent monads since the notion of dependent type is one of the primitive aspects of martinlf type theory it is perhaps not surprising that we quickly find ourselves in need of a dependent version of our polynomial monads we note there is a potential point of confusion here while a dependent type can be thought of as a family of types dependent on a base type a dependent monad in our sense is not a family of monads rather it is a monad structure on dependent families of indices and constructors indexed over the indices and constructors of the base monad m put another way under the equivalence between dependent types with domain a and functions with codomain a our dependent monads over a base monad m correspond to monads m 0 equipped with a cartesian homomorphism to m 4 the advantage of working in a dependent style however is that we do not need to axiomatize the notion of homomorphism using propositional equalities as it is encoded directly in the typing of the multiplication operator to begin let us postulate for each monad m m a universe m m u of monads over m m m u that is for m m the inhabitants of mm are codes for monads equipped with a cartesian morphism to m for this reason when we are given a monad m and a dependent monad m m m we often speak of the pair m m as a monad extension the decoding functions for dependent monads follow the same setup as the nondependent case simply repeating each 4 in fact it is entirely possible to add a monadic form of dependent sum to the list of monad constructors of the universe m so that this statement becomes literally true as we will not have need of this construction in the present article however we omit the details cns m m m m m i idx m  idx m i cns m i u typ m m m m m  i idx m i idx m i  c cns m i c cns m i c  pos m c idx m typ m c p the reader will notice however that there is no analog of dependent positions this is because we are modelling cartesian morphisms of monads and therefore positions of a dependent constructor c cns m i c should be the same as those of the underlying constructor c by working fiberwise we can reflect this requirement directly in the type signature the monadic structure of a dependent monad simply operates fiberwise following the multiplication in the base monad  m m m m m  i idx m idx m i  cns m i m i  m m m m m  i idx m c cns m i  p pos m c cns m typ m c p  i idx m i c cns m i c  p pos m c cns m typ m c p p  cns m i m c the fact that we require the multiplication of a family of dependent constructors to live over the multiplication of the base constructors and similarly for the unit is what guarantees the homomorphism property alluded to above our dependent monads must also be equipped with equational laws making them compatible with the corresponding laws of the monads they live over for example the typing functions for and respect the indices of parameters just as in the base case typ m m i p typ m m c p typ m posfst m p possnd m p there are similar laws asserting the definitional associativity and unitality of the multiplication but as these all follow exactly the same pattern we omit the details here and refer the curious reader to the implementation we remark that because their positions are the same decorations of the dependent constructor are essentially constant just as in the case of and there is therefore an analogous function dec generating such decorations from a single piece of data with a similar definition this function occurs occasionally in the code below e populating the dependent universe we now quickly describe dependent counterparts of the base monads and monad constructors of the previous section as most of the definitions are routine and easily deduced from the absolute case the presentation here is brief 1 the identity monad the dependent identity monad is parametrized by a type a u and indexed over the identity monad id that is we have a dependent monad constructor of the form id u m id idx id a tt cns id a x tt pos id a tt tt typ id a i x tt tt as in the base case the multiplication and unit all take values in the unit type making the structure essentially trivial 2 the dependent pullback monad just as we can refine the indices of a base monad so the dependent pullback monad allows us to refine the indices of a dependent monad its constructor takes the form pb m m m m m x idx m u  x i idx m idx m i x i u  m pb m x note that the family x may also depend on elements of the refining family x for the base monad the underlying polynomial of the dependent pullback is then defined as follows idx pb m x i x x i x iidx m i cns pb m x i x c slice m m m m m m slice m as for the absolute case the indices are given by the dependent constructors that is we set idx slice m i c cns m i c iidx m i similarly the type of constructors cns slice m are trees lying over a tree in the base this corresponds to the following rather verbose inductive type data tree i idx slice m i idx slice m  tree i u where lf i idx m i idx m i  cns slice m i m i lf i nd i idx m c cns m i  p pos m c cns m typ m c p  p pos m c  cns slice m typ m c p p its polynomial part is defined by 3 the dependent slice monad finally the dependent slice monad extends the baezdolan slice construction to the dependent case its monad constructor is typed as follows x typ m c p p ccns m i c ppos m c typ pb m x c p typ m c p p with multiplicative structure following fiberwise the rules for the base pullback pb m x  i idx m i c cns m i c  p pos m c cns m typ m c p  p pos m c  cns slice m typ m c p p  cns slice m i m c nd c the rest of the description of the dependent slice follows exactly the same pattern duplicating the definitions and laws of the base case routinely in each fiber iii o petopic t ypes in this section we show how to use the universes introduced above in order to implement baez and dolans definition of opetopic type 2 we go on to explain how to use this definition to capture the notion of weak m algebra and finish with some examples definition 1 an opetopic type over a monad m is defined coninductively as follow record opetopictype m m u1 where c idx m u r opetopictype slice pb m c we see from the definition that an opetopic type consists of an infinite sequence of dependent families c x c r x c r r x whose domain is the set of indices of a monad whose definition incorporates all the previous families in the sequence given an opetopic type x opetopictype m we will often denote this sequence of dependent types more succinctly as just x0 x1 x2 since the destructor notation quickly becomes quite heavy we will use a similar convention for the series of monads m m0 m1 m2 generated by the definition that is we have m0 m x0 c x idx m u we recall that for m a polynomial monad an m algebra consists of a carrier family c idx m u together with a map  i idx m m c i c i m1 slice pb m0 x0 x1 c r x idx m1 u m2 slice pb m1 x1 x2 c r r x idx m2 u before describing the connection between opetopic types and weak m algebras let us give some examples of how to think of the resulting dependent families as fillers for a collection of shapes generated by the monad m for concreteness we will fix m id in our examples given x opetopictype id we can define the type of objects of x as simply obj u obj c x tt next after a single slice x provides us with a type of arrows between any two objects which can be defined as follows arrow x y obj u arrow x y c r x tt y tt dec id c x x furthermore for a loop f in x that is an arrow with the same domain and codomain x includes a family whose elements can be thought of as nullhomotopies of f and which is defined by null x obj f arrow x x u null x f c r r x tt x tt dec id c x x f lf tt x elim more examples of shapes and filling families may be found in the development a weak algebras and fibrant opetopic types we now wish to describe how an opetopic type x opetopictype m encodes the structure of a weak m algebra before we begin it will be convenient to adopt the following convention recall that x consists of an infinite sequence of dependent types following the form of equation 1 in the discussion which follows instead of working with a fixed opetopic type x we will rather just work with abstract type families x0 x1 over monads m m0 m1 following the same pattern of dependencies we will then freely add new families of the form xi to our hypotheses as they become necessary the advantage of working this way is that our definitions are parameterized over just that portion of the opetopic type which is necessary as opposed to depending on the entire opetopic type x itself and consequently we will be able to reuse our definitions and constructions starting at any point in the infinite sequence generated by x which satisfies some equations expressing the compatibility of with the multiplication of m indeed it is the need for a complete description of these equations in all dimensions which motivates the present work now clearly the first dependent type x0 idx m u may serve as a carrier for an m algebra structure let us now see what else this sequence of families provides us with after one iteration we obtain a type family x1 idx m1 u and unfolding the definition of the indices of the slice and pullback monads we find that the domain of x1 takes the form p pos m c x0 typ m c p iidx m xx0 i ccns m i the elements of this type are 4tuples i x c and we now observe that the three elements i c and are typed such that they are exactly the arguments of the hypothetical algebra map  introduced above we may regard the family x1 therefore as a relation between triples i c and elements x x0 i and in order to define a map we only need to impose that this relation is functional in the sense that there is a unique x determined by any such triple when this is the case we will say that the family x1 is multiplicative that is we define ismult x0 idx m0 u x1 idx m1 u u ismult x0 x1 i idx m c cns m i  p pos m c x0 typ m c p  iscontr x1 i x c xx0 i supposing we are given a proof m1 ismult x1 we can define an algebra map as above by  c fst ctr m1 c furthermore we will write wit c snd ctr m1 c for the associated element of the relation x1 i c c which witnesses this multiplication let us now suppose that our sequence extends one step further that is that we are given a type family x2 idx m1 u and a proof m2 ismult x2 we now show how to use this further structure to derive some of the expected laws for the algebra map we have just defined as a first example we expect to satisfy a unit law decorating a unit constructor with some element x and then applying should return the element x itself in other words we expect to be able to prove  coh i idx m x x0 i  m i dec m x0 x x to prove this equality let us define the following function algm2 i idx m x x0 i  x1 i x m i dec m x0 x algm2 fst ctr m2 lf i x elim now we simply notice that the pairs must be equal as indicated since they inhabit a contractible space projecting on the first factor gives exactly the desired equation we also expect our algebra map to satisfy an equation expressing its compatibility with multiplication of the following form  coh i0 idx m c0 cns m i  0 p pos m c cns m typ m c p  0 p pos m c0 q pos m 0 p  x0 typ m 0 p q  m c0 0 p 0 posfst p possnd p  c0 p 0 p 0 p we note that this equation is simply the type theoretic translation of the familiar commutative diagram m x0 m m x0 c c0 x1 wit c  p 0 p 0 p  p 0 p 0 p x0 c x p wit 0 p 0 p we find that the pairs ctr m1 m i dec m x0 x x alg x m m x0 now instantiating our function algm2 with arguments to prove this axiom we use m2 to define the following multiplication operation on elements of the family x1 algm2 i idx m c cns m i  p pos m c x0 typ m c p  p pos m c  cns pb m x0 typ pb m x0 c p  x0 x0 i x1 x1 i x0 c  x p pos m c x1 typ pb m x0 c p  x1 i x0 pb m x0 c algm2 fst ctr m2 ctr m1 m c0 0 p 0 posfst p possnd p  c algm2 c x0 x1 x again inhabit a contractible space whereby their first components are equal giving the desired equation we may think of the functions algm2 and algm2 defined above as the nullary and binary cases of a multiplicative operation on the relations of our algebra structure the key insight as we have seen is that this multiplicative structure encodes exactly the laws for the algebra map defined one level lower similarly if we are able to extend our sequence on further step to a family x3 which is itself multiplicative then we will be able to show that the operations algm2 and algm2 themselves satisfy unit and associativity laws and this in turn encodes the 2associativity and 2unitality of the algebra map this motivates the following definition definition 2 an opetopic type x over a monad m is said to be fibrant if we are given an element of the following coinductively defined property record isfibrant m m x opetopictype m u where carismult ismult m c r x relisfibrant isfibrant r x fibrant opetopic types therefore are our definition of infinitely coherent m algebras with the multiplicativity of the relations further in the sequence witnessing the higher dimensional laws satisfied by the structure earlier in the sequence b higher structures we now use the preceding notions to define a number of coherent algebraic structures a first example is that we obtain an internal definition of the notion of groupoid as follows  nd c p m1 typ m c p p p definition 3 an groupoid is a fibrant opetopic type over the identity monad that is grp xopetopictype id isfibrant x is the twolevel tree consisting of a base node c as well as a second level of constructors specified by the decoration  and is the decoration of the nodes of by elements of x1 defined by we will attempt to justify the correctness of this definition in the sections which follow next it happens that the monad slice id is in fact the monad whose algebras are monoids and consequently our setup leads naturally to the definition of an a type that is a type with a coherently associative binary operation where  inl tt x1  inr p inl tt x p definition 4 an a type is a fibrant opetopic type over the first slice of the identity monad a type xopetopictype slice id isfibrant x furthermore the notion of a group can now be defined by imposing an invertibility axiom a classical theorem of homotopy theory asserts that the type of a groups is equivalent to the type of pointed connected spaces via the loopspace construction it would be interesting to see if the techniques of this article lead to a proof of this fact in type theory the notion of category can also be defined using this setup recall that an opetopic type over the identity monad id has both a type of objects and a type of arrows equations 2 and 3 in the definition of groupoid above the invertibility of the arrows in the underlying opetopic type is a consequence of the fact that the family of arrows is assumed to be multiplicative consequently we obtain a reasonable notion of a precategory by simply dropping this assumption and only requiring fibrancy after one application of the destructor precat xopetopictype id isfibrant r x the prefix pre here refers to the fact that this definition is missing a completeness axiom asserting that the invertible arrows coincide with paths in the space of objects that is an axiom of univalence in the sense of 18 such an axiom is easily worked out in the present setting but as it would distract us slightly from the main objective of the present work we will not pursue the matter here iv t he groupoid associated to a type in this section we use the machinery we have set up to produce an groupoid associated to any type and eventually prove it is unique as a first step we will need a source of opetopic types here is where the notion of dependent monad becomes important we now show that every dependent monad gives rise to an opetopic type the reason for this phenomenon is simple since our dependent monad constructors mirror the monad constructors of the absolute case any monad extension m m in fact gives rise to a new monad extension as follows slice pb m idx m slice pb m j k j k notice how by pulling back along idx m the identity type gives us a canonical family along which to apply the pb constructor iterating this construction then we find that associated to every monad extension m m is an infinite sequence m m m0 m 0 m1 m 1 m2 m 2 where mi1 m i1 is obtained from mi m i by the above transformation the above construction provides us with our desired source of opetopic types formally we define using copattern notation optype m m opetopictype m c optype m m idx m r optype m m optype slice pb idx m slice pb m j k j k specializing to the case of the identity monad we obtain the following definition 5 for a type a u the underlying opetopic type of a is defined to be the opetopic type associated to the dependent identity monad determined by a that is the opetopic type optype id id a in the notation of the previous paragraph in order to show that every type a determines an groupoid in our sense our next task is to show that this opetopic type is in fact fibrant a algebraic extensions let m m and m m we will say that the extension m m is algebraic if we have a proof isalgebraic m m m m u isalgebraic i idx m c cns m i  p pos m c idx m typ m c p typ m c  iscontr iidx m ccns m i an algebraic extension should be thought of as roughly analogous to a generalized kind of opfibration if we think of the constructors as generalized arrows between their input indices and output then the hypothesis says we know a family of lifts over the source of our constructor and the conclusion is that there exists a unique pushforward consisting of a lift over the output as well as a constructor connecting the two whose typing function agrees with the provided input lifts such a hypothesis is one way of encoding an m algebra which motivates the name for this property see 19 section the main use of the notion of algebraic extension is the following lemma whose proof is entirely straightforward lemma 2 suppose the pair m m is an algebraic extension then the relation idx m 1 is multiplicative consequently just as dependent monads are a source of opetopic types algebraic extensions can be thought of as a source of multiplicative relations hence if we want to prove fibrancy of the opetopic type associated to a monad extension we will need to know which of the extensions in the generated sequence are algebraic our main theorem is that after a single iteration of the slice construction every monad extension becomes algebraic that is theorem 1 let m m be a monad extension then slice extension m1 m 1 is algebraic a proof can be found in the extended version of this article 16 the importance of the theorem is that it has the following immediate corollaries corollary 1 let m m be an algebraic extension then the opetopic type optype m m is fibrant proof the base case of the coinduction is lemma 2 and the coinductive case is covered by theorem 1 corollary 2 there is a map u grp proof let a u be a type a short calculation shows that the monad extension id id a is algebraic the result therefore follows from corollary 1 b uniqueness of the groupoid structure we now turn to the task of showing the map u grp is an equivalence observe that there is a forgetful map grp u which is given by extracting the type of objects equation 2 from the opetopic type underlying a groupoid g grp it is readily checked that the composite  is definitionally the identity and so what remains to be shown is that any g grp is equivalent to applied to its type of objects unwinding the definitions we find that we are faced with the following problem suppose we are given a monad extension m m as well as a opetopic type x opetopictype m under what hypotheses can we prove that x o optype m m where o denotes an appropriate notion of equivalence of opetopic types a first remark is that the opetopic type optype m m is completely determined by the algebraic structure of the dependent monad m therefore at a minimum we must assume that the data of the opetopic type x is equivalent to the data provided by m wherever they overlap to see what this means concretely let us begin at the base of the sequence writing z optype m m to reduce clutter now the family z0 idx m u is by definition given by the family of dependent indices idx m of the dependent monad m on the other hand without additional hypotheses the opetopic type x only provides us with some abstract type family x0 idx m u clearly then we will need to assume an equivalence e0 i idx m idx m i x0 i in order to have any chance to end up with the desired equivalence of opetopic types moving on to the next stage here we find that z1 is given by the dependent indices idx m 1 idx m1 u of the first iteration of the dependent slicepullback construction unfolding the definition these are of the form idx m 1 i j c v jidx m i rjj 0 typ m d r and the equality relating to the typing function of d we find that the dependent indices are essentially just dependent constructors of m slightly reindexed in other words a dependent equivalence e1 i idx m1 idx m 1 e0 x1 over the previous equivalence e0 amounts to saying that the relations of the family x1 are just the dependent constructors of m again reindexed according to the typing of their input and output positions as this is again part of the data already provided by the dependent monad m we will additionally need to add such an equivalence to our list of hypotheses to recap assuming the equivalences e0 and e1 amounts to requiring that the first two stages of the opetopic type x are equivalent to the indices and constructors of the dependent monad m respectively what structure remains well the dependent constructors of m are equipped with the unit and multiplication operators and but now recall from section iiia that if the family of relations x1 extends further in the sequence to a family x2 and we have a proof m2 ismult x2 then the family x1 can be equipped with a multiplicative structure given by the functions algm2 and algm2 defined there this is the case in the current situation if we assume that the opetopic type x is fibrant in fact we only need assume that r x is fibrant to make this statement hold therefore the last piece of information in order that x completely agrees with the dependent monad m is that the equivalence e1 is additionally a homomorphism sending  to algm2 and to algm2 our theorem now is that this data suffices to prove an equivalence of opetopic types theorem 2 suppose m m is a monad extension and x opetopictype m an opetopic type such that r x is fibrant moreover suppose we are given the data of  an equivalence e0 i idx m idx m i x0 i  an equivalence e1 i idx m1 idx m 1 e0 x1 over e0  proofs that s m e0 e1 algm2 and t m e0 e1 algm2 then there is an equivalence of opetopic types x o optype m m we have taken some liberties in the presentation of this theorem strictly speaking we have not stated precisely in what sense the second equivalence e1 is over the equivalence e0 nor precisely what equality is implied by symbol the e0 e1 but these omissions can be made perfectly rigorous by standard techniques and we feel the statement above conveys the essential ideas perhaps more clearly than a fully elaborated statement which would require a great deal more preparation not to mention space see the appendix of the extended version of this article for a proof 16 theorem 2 we at last obtain our desired equivalence dcns m c with the 4tuple i j c v as in equation 4 we notice that much of the data here is redundant by eliminating the equality theorem 3 the map  u grp is an equivalence proof given g grp we let a u be its type of objects we now apply theorem 2 with m id and m id a we may take e0 to be the identity the equivalence e1 is a consequence of 13 theorem 582 and the required equalities are a straightforward calculation v c onclusion we have presented an approach to defining higher coherent structures in homotopy type theory by equipping type theory with a primitive set of structures collected into a universe m of polynomial monads and demonstrated that this approach can be used to prove nontrivial theorems about these structures in this brief final section we compare some related approaches and survey some of the possible directions and applications a future directions 1 symmetric structures a natural class of structures which escapes the capabilities of our current approach is that of symmetric structures that is those which incorporate higher analogs of commutativity examples would include e groups and monoids symmetric monoidal categories and general operads and their algebras 2 higher category theory as we have seen one higher structure which is amenable to treatment by our methods is that of an category an obvious point to follow up on then is how much of the well developed theory of categories can be formalized in this manner 3 a general theory of structures as we have mentioned in the introduction we see the present work as a first step towards a general theory of types and structures and though we feel certain that at least some of the ideas of the present work will carry over to such a theory a complete picture of the basic principles remains to be understood moreover a careful investigation of the interaction of our techniques with univalent implementations of type theory such as cubical type theory also remains for future work accompanying such a general theory we anticipate a deeper investigation of the metatheoretic properties of our proposed approach for example the agda implementation is limited by the expressivity of rewrite rules and complicated by the explicit universe construction while a proper extension of mltt would allow for the investigation of metatheoretic properties like decidability of type checking and strong normalization using techniques like normalizationbyevaluation and potentially settling the conjecture of iib furthermore we have not touched at all on the potential models of our system topic which deserves we feel deserves careful attention r eferences 1 n gambino and j kock polynomial functors and polynomial monads mathematical proceedings of the cambridge philosophical society vol 154 no 1 p 153192 2013 2 j c baez and j dolan higherdimensional algebra iii ncategories and the algebra of opetopes advances in mathematics vol 135 no 2 pp 145206 1998 3 j kock a joyal m batanin and jf mascari polynomial functors and opetopes advances in mathematics vol 224 no 6 pp 2690 2737 2010 4 d gepner r haugseng and j kock operads as analytic monads arxiv preprint arxiv171206469 2017 5 j cockx n tabareau and t winterhalter the taming of the rew a type theory with computational assumptions proceedings of the acm on programming languages 2020 online available httpshalarchivesouvertesfrhal02901011 6 b van den berg and r garner types are weak groupoids proceedings of the london mathematical society vol 102 no 2 pp 370394 2011 7 p l lumsdaine weak categories from intensional type theory in international conference on typed lambda calculi and applications springer 2009 pp 172187 8 p r north towards a directed homotopy type theory electronic notes in theoretical computer science vol 347 pp 223239 2019 9 e riehl and m shulman a type theory for synthetic categories arxiv preprint arxiv170507442 2017 10 d annenkov p capriotti and n kraus twolevel type theory and applications corr vol abs170503307 2017 online available httparxivorgabs170503307 11 agda development team agda 2611 documentation 2020 online available httpsagdareadthedocsioenv2611 12 p martinlf an intuitionistic theory of types predicative part in studies in logic and the foundations of mathematics elsevier 1975 vol 80 pp 73118 13 t univalent foundations program homotopy type theory univalent foundations of mathematics institute for advanced study https homotopytypetheoryorgbook 2013 14 t altenkirch n ghani p g hancock c mcbride and p morris indexed containers j funct program vol 25 2015 online available httpsdoiorg101017s095679681500009x 15 g huet confluent reductions abstract properties and applications to term rewriting systems j acm vol 27 no 4 p 797821 oct 1980 online available httpsdoiorg101145322217322230 16 a allioux e finster and m sozeau types are internal groupoids extended version arxiv preprint 2021 17 f blanqui g genestier and o hermant dependency pairs termination in dependent type theory modulo rewriting corr vol abs190611649 2019 online available httparxivorgabs1906 11649 18 b ahrens k kapulkin and m shulman univalent categories and the rezk completion mathematical structures in computer science vol 25 no 5 pp 10101039 2015 19 t leinster higher operads higher categories cambridge university press 2004 no 298 a ppendix lemma 3 strong confluence for the r pair we fix a monad m and show that the two rules can always be joined if t r t0 and t t00 then t00 t0 proof in case of overlap the first application reduces in one step  c p typ c p we show that applying the rule instead results in the same term where only one rule applies on a given subterm at each step  c p typ c p  c p p q typ c pos p q typ  c p p q  typ posfst c pos p q possnd c pos p q posfstpossnd  c p p q typ p q  c p p for the inductive case that is when nd c evaluating the decoration on the position corresponding to the base of our tree that is inl tt we obtain a 4tuple j 0 r d where j 0 idx m i r j 0 j d cns m c j 0 and typ m d then we define theorem 1 let m m be a monad extension then slice extension m1 m 1 is algebraic proof unfolding the definitions we have that idx m1 is the iterated sum iidx m jidx m i ccns m i p pos m c idx m typ m c p and for a given i j c the type idx m 1 i j c of dependent indices is itself an iterated sum of the form typ m d jidx m i rjj 0 dcns m c in other words if the tuple i j c is seen as a constructor in c with inputs and output decorated by elements of idx m then a element j 0 r d lying over it is simply a constructor of the dependent monad m over c whose intrinsic typing information that is indices assigned by the underlying dependent polynomial of m matches the decoration of c the constructors follow a similar pattern but now assembled into trees a constructor of the base monad m1 is a tree  whose internal nodes carry the additional information of a decoration of their incoming and outgoing edges by elements of idx m a constructor of m 1 lying over is itself a tree  built from dependent constructors of m and carrying the additional information of equalities witnessing that the typing information of each node agrees with the decoration of the node it lies over in in the sense of the previous paragraph now the situation of the theorem is the following we are given a 4tuple i j c idx m1 and a tree cns m1 i j c together with a decoration of this tree which assigns to each of the positions of that is to each of its nodes an index living in idx m 1 which as we have seen means a single dependent constructor together with proofs that its typing information matches the local decoration of the node in to prove the theorem we must produce in this situation three pieces of data  j 0 r m d 0 0  ndd p 0 p 0 p q 0  0 in which the decorations 0 and 0 as well as the typing compatibilities 0 and 0 are obtained from the induction hypothesis and is a coherence asserting that the typing information of a constructor is unchanged when it is transported along an equality of indices in summary the decoration assigns to each node of the tree a dependent constructor lying over the constructor occupying that node together with compatibility information about the typing by induction on we accumulate these dependent constructors into dependent tree lying over and at the same time accumulate witnesses that the typing of the nodes in the resulting tree agrees with which it clearly does by construction to show uniqueness we need to see that any other triple  0 0 0 is equal to the one defined above the proof again proceeds by induction on the given tree and the crucial point is that all the data of this 3tuple can be eliminated away to see this let us expand 0 j 0 r d now r j 0 j so we may eliminate and assume j 0 j similarly  0 typ m 1 0 is just an equality between the typing function for 0 and the original decoration since was a free parameter to begin with we can freely eliminate 0 at this point and assume that actually is typing function 0 we are left with just the dependent tree 0 and the remaining two elements of 0 namely d but now as we proceed by induction on we can also proceed by induction on the dependent tree 0 and in fact this completely forces the values of d via the indexing of dependent trees for example when lf i j the only valid possibility for 0 is lfj refl and in this case we necessarily have d m j refl dec refl as required the nd case is similar even if the path algebra is considerably more involved and moreover we must show that the space of all such data is contractible we will construct this data by induction on the tree in the case that lf i j we have necessarily that c m i and dec j and we may take theorem 2 suppose m m is a monad extension and x opetopictype m an opetopic type such that r x is fibrant moreover suppose we are given the data of  an equivalence e0 i idx m idx m i x0 i  an equivalence e1 i idx m1 idx m 1 e0 x1 over e0  proofs that s m e0 e1 algm2 and t m e0 e1 algm2 then there is an equivalence of opetopic types  j refl m j dec refl x o optype m m an index idx m 1 i j c a dependent tree cns m 1 a proof that typ m 1  lf j refl  funext elim proof the proof is by coinduction and so it suffices to produce elements e00 e01 s0 t0 whose types are the same as those of the corresponding elements in the hypotheses but modified by the transformations m m m1 m 1 next we observe that it follows from univalence that the equivalences e0 and e1 can be eliminated from the hypotheses since the opetopic type x is abstract in other words we are free to assume that x0 idx m and x1 idx m 1 so that the first remaining abstract family of x is x2 idx m2 u moreover after making these simplifications the equalities s and t take the following types s i idx p m j idx p m i  j p m j algm2 fst i snd i t i idx p m c cns p m i when lf i j and lf j refl we must produce an element of x2 of type x2 is js lf i j where is i j m i dec j js j refl m j dec refl on the other hand we have an element x2 x2 is algm2 is lf i j lf i j x2 snd ctr m2 lf i x since algm2 is defined using the multiplicativity of the relation x2 but the term s i j j refl obtained from the hypothesis s now gives js algm2 is lf i j and we so we obtain the desired result by transporting x2 along this equality  pos p m c cns p m typ p m c p before moving on to the inductive case of a node let us pause to anticipate how we intend to prove the equations s0  j idx p m id cns p m j c and t as this will have serious consequences for how we  p pos p m c cns p m typ p m d p p proceed these equations will now be over the equivalence e01  j p m d which we are in the process of constructing specifically they take the form algm2 fst i fst c snd c snd i j d p typ m fst dp snd d p p where we have set p m pb m idx m s0 i idx p m1 j idx p m 1 i  e01 i p m1 i j p m 1 j algm3 fst i snd i p m pb m j k j k to simplify the notation now we may take e00 to be the identity since e1 is the identity it therefore remains to construct the equivalence e01 of type i idx m2 idx m 2 i x2 i and check the two required equations we claim that it in fact suffices to construct a map e i idx m2 idx m 2 i x2 i and that any such map is necessarily an equivalence this follows from the fact that both idx m 2 and x2 are multiplicative relations the former by theorem 1 and the latter by assumption now unfolding all the definitions and eliminating the redundancies we find that the map e depends on the data of a tree  cns m1 i j c where i j c idx m1 a decoration  of the nodes of this tree in the family idx m 1 a dependent tree living over and a proof that the typing function of agrees with the data determined by the situation is analogous to that encountered in the proof of theorem 1 we may therefore proceed by simultaneous induction on and t0 i idx p m1 c cns p m1 i  pos p m1 c cns p m1 typ p m1 c p  j idx p m 1 id cns p m 1 j c  p pos p m1 c  cns p m 1 typ p m 1 d p p  e01 i p m1 c j p m 1 d algm3 fst i fst c snd c snd i j d p typ m1 fst dp snd d p p where now each of monads have advanced by a single slice p m1 pb m1 idx m1 p m 1 pb m 1 j k j k furthermore the left side of each equality now includes an application of the equivalence e01 and the right side uses the unit and multiplicative operators algm3 and algm3 corresponding to the fact that the next family x3 is also multiplicative what this means is that if we want to ensure that the equivalence e01 sends the required elements to applications of the unit algm3 and multiplication algm3 functions we will need to use these functions in the definition of e01 and furthermore we need to use them both but since the unit case algm3 in the next dimension corresponds to a corolla that is a tree with a single node in the present dimension we will need to now make a case split depending on whether or not the node in the tree we are recursing on has descendants or not this is possible as soon as the monad m we are considering is finitary in the sense that the type of positions is merely equivalent to finite type in this case the the property of a tree being a corolla becomes decidable and so we can make the required case split this is not a problem for our intended application since it is easily checked that the identity monad has this property and moreover that it is inherited both by pulling back and slicing consequently we will freely proceed now under this hypothesis now returning to the definition of our equivalence e01 we are in the inductive case so that we have nd c and  nd c our goal is to produce an element of type x2 is js nd c where now is i j p m c js j refl p m c we now make a case distinction based on whether the tree  is a corolla or not in case that it is one can prove equalities u i j p m c i j c v j refl p m c inl tt but then the result follows from transporting the term algm3 i j c inl tt in the fibration x2 along the equalities u and v if is not a corolla but rather has proper descendants then we proceed as follows by appealing to the induction hypothesis we obtain a family of elements of x2 parameterized by the positions p pos m c these assemble together with the witness for the binary multiplication of c and under algx2 into the arguments for algx3 which has the correct type up to a transport along the equality given by our hypothesis t this completes the definition of e01 and as the reader can see we have thus achieved our goal of using the multiplicative operators algm3 and algm3 in the construction of the required equivalence it remains to check the equations s0 and t0 above a long calculation which we will not reproduce here it is not hard to see that up to some path algebra s0 is by definition verifying t0 is slightly more involved in this case one must proceed by induction on the trees occurring in the arguments c and c again splitting into three cases that of a leaf a corolla and a tree with at least 2 nodes additionally during the course of the induction one uses that the operators algm3 and algm3 are themselves associative and unital under the assumption that the opetopic type x was fibrant 