isolation taxationnear zero cost transitions sfimatthew kolosick shravan narayan conrad wattmichael lemay deepak garg ranjit jhala deian stefanarxiv210500033v1 cscr 30 apr 2021uc san diegouniversity cambridgeintel labsmax planck institute software systemsrequire frequent domain crossings similarly sfiallows fastly service thousands tenants secondcore calls runtime multiple timeshandling request fractions millisecond 19significant strides sfi enforcementx86 2 9 14 20 x8664 21 sparc 22arm 21 23 24 context switching sfi systems remains largely unexplored wahbe et als original work 1sfi systems heavyweight transitionscontext switching transitions switch domains tyingunderlying sfi enforcement mechanism exampletransitioning sandbox set segmentregisters 9 memory protection keys 25 26 ensuresandbox code memory isolated save scrubrestore machine state stack pointer programcounter calleesave registers ensure confidentialityintegrity code hard rightaccount different architectures platformsquirks 27 significant overheads vintroductionpaper revisit context switching sfi systemssoftwarebased fault isolation sfi lightweight alterna realize 90s vision reducing cost context switchtive processbased isolation isolates untrusted code roughly function contributionsruntime checks restrict sandbox code specific design sfi systems near zerocost transitionsregion address space 1 2 sfi runtimechecks typically slow code running sandbox 1 formal model secure transitions iii simply rein application domains sandboxed components moving heavyweight transitions sfi systemstightly coupled require frequent domain crossings unsafe transitions attacker easily escapelow overhead sfi transitions makes sfi sandbox contribution formaladded cost 3 example sfi isolate code declarative highlevel model elucidates roleos kernels 47 browsers 810 runtime systems 11 transitions making sfi secure ii intuitively securetransitions protect integrity confidentiality machine13 storage systems 1 14 15recently mozilla started webassembly wasm state domain transition provide wellbracketedbased sfi sandbox thirdparty c libraries firefox 16 control flow returns actually return sitesabstractalmost sfi systems use heavyweight transitionsincur significant performance overhead savingrestoring registers context switching applicationsandbox code identify set zerocost conditionscharacterize sandboxed code wellstructuredsecurity guaranteed lightweight zerocosttransitions webassembly wasmintermediate representation lowlevel code naturally resultssfi zerocost transitions modify lucetwasm compiler runtime use zerocost transitionsmodifications speed image font rendering firefox297 10 respectively newpurposebuilt fast sfi segmentzero32 uses x86segmentation llvm offtheshelf passesenforce zerocost conditions enforcement incursruntime cost sandboxed codefirefox image font rendering benchmarks time savedtransition allows segmentzero32 outperformidealized hardware isolation memory isolationincurs zero performance overhead use heavyweighttransitions required17 companies like fastly wasm isolate tenant 2 zerocost conditions sfi iv heavyweight transicode edge clouds 18 sfi allows mozilla isolate tions provide security wrapping calls returns ensurelibraries like libgraphite font shaping libexpat sandboxed code example read secret registersxml parsing hunspell spell checking tamper stack pointer transitions necessarytightly coupled process content streaming fashion code running sandbox arbitrary nativecode practice sfi systems enforcework supported gifts cisco nsf structure sandboxed code example nacl uses controlgrant number cns1514435 ccf1918573 career cns2048262conix research center centers jump semiconductor flow integrity cfi restrict sandboxs control flowresearch corporation src program sponsored darpa conrad watt code region requires dynamic checks readssupported epsrc grant rems rigorous engineering mainstream writes 3 9 10 structure simplifies sfi enforcementsystems epk0085281 google phd fellowship programming technology software engineering research fellowship peterhouse verification enforcement correct insightuniversity cambridgeimposing structure sandboxed code allowsreplace heavyweight transitions zerocost transitionsclose bare function callsinsight inspired work languagebased isolation 2833 languagebased systems like singularity 32use highlevel type memorysafe languages singisolate code language level compositionalstructure languages allow systems usesimple function calls secure crossdomain transitionslanguage enforces wellbracketed control flow local stateencapsulation confidentiality integrity machinestate realistically rewrite huge systems like firefoxthirdparty libraries firefox highlevellanguage 3 instead capture essence makespossible languagebased systems safely use zero costtransitions adapt sfi settingsecond contribution precisely defines zerocostconditions sandbox code satisfy safely use zerocost transitions sandboxed code follow typedirectedcfi discipline wellbracketed control flow enforce localstate stack register encapsulation ensure registersstack slots initialized use conditionsslightly onerous structure sfi systemsrequire sandboxed code compared naclrely typebased cfi instead coarsegrained cfi usesafe stack instead separate stack state zerocostconditions terms dynamic overlay semanticsinstantiate model different sfi systems3 instantiating zerocost model v contribution instantiation zerocost model sfisystems wasm segmentzero32wasm lowlevel bytecode sound static typedesigned targeted compilers languagesc 10 study wasm intermediate representationir sfi 16 3436 compiling untrusted cclibraries native binaries wasm irlinked application like firefoxcompiled wasm wasm satisfieszerocost conditions replace heavyweight transitionsexisting wasm sfi compilers zerocost transitionsdesign segmentzero32 sfi 1 use32bit x86 segmentation hardware enforce heap memoryisolation 2 restrict structure code accordingzerocost conditions unlike previous sfi systems usesegmentation 2 9 14 use set offtheshelfllvm compilation passes custom compilation passsection vb enforce zerocost conditions includingtypebased cfi ensure segmentzero32 safelyuse zerocost transitions prevalence 32bit x86systems declining constitutes 20firefox web browsers user base 45 millionusers1 segmentzero32 allow high performancelibrary sandboxing machines4 proofs security fourth contribution set proofssecurity prove nacls heavyweight transitions1secure b zerocost conditionsmet zerocost transitions secure c provewasm meets zerocost conditions safelyelide heavyweight transitions maintaining integrityconfidentiality d5 implementation evaluation vi contribution implementation evaluation wasmsegmentzero32 zerocost transitions integratesfi systems rlbox sandboxing framework 16evaluate performance zerocost transitionsmicrobenchmarks macrobenchmarks imagedecoding font rendering firefox currentlysandboxed wasmbased sfi zerocosttransitions speed wasmsandboxed image decoding297 font rendering 10 segmentzero32imposes overhead 24 image decoding225 font rendering relative unsandboxed native codeoverheads significantly lower idealizedhardware isolation memory isolation adds zerooverhead use heavyweight transitions requiredopen source data code dataavailable open source licenseii overviewsection role transitionsmaking sfi secure overview existing heavyweighttransitions introduce zerocost model makespossible sfi systems replace heavyweight transitionssimple function callsneed secure transitionsconsider sandboxing untrusted font rendering librarylibgraphite browser like firefoxvoid onpageloadint textint screen stored r12int tempbufgrgetpixelbuffertext tempbufmemcpyscreen tempbuf 100code calls libgraphite grgetpixelbufferfunction render text temporary buffer copiestemporary buffer variable screen renderedsfi sandbox library ensures browsersmemory isolated libgraphite memory isolationensures grgetpixelbuffer access memory onpageload parts browser stackheap unfortunately memory isolationtransitions simply function calls 25 attackersviolate calling convention applicationlibraryboundary grgetpixelbuffer returnbreak isolation different wayscompromised libgraphiteclobbering calleesave registers suppose screen variable onpageload snippet compiledhttpsdatafirefoxcomdashboardhardware visited march 2021cost wrappers heavyweight springboards trampolines guarantee secure transitions significantdrawbacks impose overhead sfi callssandboxed library significantly expensivesimple application function calls vi heavyweighttransitions conservatively save clear statenecessary essentially reimplementing aspectsos process switch duplicating work wellbehaved libraries second springboards trampolinescustomized different platforms different processorscalling conventions implementation mistakes4045 resulted sandbox escape attacksregister r12 v calling convention r12calleesaved register 37 grgetpixelbufferclobbers r12 supposed restore original value returning onpageload compromisedlibgraphite doesnt instead attackerpoison registermov r12 hretr12 screen firefox line 6memcpy tempbuf sandbox memory givesattacker write gadget use hijack firefoxscontrol flow prevent attacks need calleesaveregister integrity ensure sandboxed coderestores calleesave registers returning applicationc zerocost transitionsheavyweight transitions conservativeassumptions structure possible behaviorleaking scratch registers dually scratch registerscoderunning sandbox sfi systems like naclpotentially leak sensitive information sandbox supposewasmimpose structure sandboxed codefirefox keeps secret encryption key scratchenforcememoryisolation sectionregister memory isolation prevent attackerimposingstructuresandboxed code transitionscontrolled libgraphite uninitialized registersconservativespecifically set zeroand reading secret prevent leaks needcostconditionsimpose internal structurescratch register confidentialitysandboxed code ensure behave like highreading corrupting stack frames finally applilevel compositional language maintaining sfis highcation sandboxed library share stack 25performance sfi systems meet conditionsattacker read corrupt data pointers storedsafely elide extra work heavyweightstack prevent attacks need stack framespringboards trampolines moving idealencapsulation need ensure sandboxed codesfi transitions simple fast portable function callsaccess application stack frameszerocost conditions assume sandboxed librarycode split functions functionb heavyweight transitionsexpected number arguments known types formalizesfi toolchains nacl 9 wasm native compilersinternal structure required library code safetylike lucet 38 wamr 39 use heavyweight transitionsmonitor checks zerocost conditions localwrap calls returns prevent aforementioned attacksrequirements necessary ensure callsinto returnsheavyweight transitions secure transitions provideuntrusted library functions wellbehaved1 calleesave register integrity springboard satisfy secure transition requirementstransition code wraps calls saves calleesave registers 1 typedirected forwardedge cfi monitor reto separate stack stored protected application memory quires library code enforces typedirected forwardwhen returning library application edge cfi instruction encounteredtrampoline code wraps returns restores execution jump target address startregisterslibrary functions number types arguments2 scratch register confidentiality scratch registercontain secrets springboard clears scratch registerstransitioning sandboxexpected function match actually passedprovides main properties critical securityensures function starts statically3 stack frame encapsulation sfi systems known stack shape preventing class attack benignprovision separate stacks trusted sandboxed code function tricked overwriting stack framesensure trusted stack accessible sandbox hijacking control flow passedspringboard trampoline account ways arguments second provides structure neededtrack separate stack pointers transition define property capturing proper restoring calleesaveorder switch stacks second springboard copies registers discussed pointarguments passed stack sandbox stack 2 wellbracketed controlflow second monitor requiressandboxed code access arguments stored library code adheres wellbracketed return edgesapplication stack finally trampoline tracks actual return abstractly calls returns wellbracketedaddress return transition keeping protected f calls g g calls h h ought return gmemory sandboxed library tamper g ought return f untrusted functionssubvert control stack implement arbitrary control flowfunctions unrestricted control flow oddscompositional reasoning makes difficult definecorrect restoration calleesave registers unclearreturning function means accordinglyrequire properties library ensure callsreturns wellbracketed jump stayfunction limits interfunction control flowfunction calls returns second specification monitormaintains logical stack ensurereturns preceding caller3 calleesave registers restoration building wellbracketed control flow particular resulting definitionbeginning end function define functionlevel adherence calleesave register conventions monitortracks calleesave state checks correctlyrestored return importantly satisfying monitormeans application calls wellbehaved library functionrequire transition separately saves restorescalleesave registers function known obeystandard calling convention4 local state encapsulation monitor establishes localstate encapsulation checking stack reads writescurrent stack frame check allowslocally checking function isolation ensurelibrary function correctly saves restores calleesave registersentry exit local state encapsulationneeded consider following idealized assembly functionlibraryfuncprivvalregregionimmediatecommandcoderegvalsmemorystateapp libhn pirn sp pcr v iir popp pushp jmpkr loadk storekgatecalln gateretr mov callk retkgatecalln storelabelpn priv commandreg valn valerrorpc n sp n r regvalsm memory c codefigure 1 syntaxstrict ensure wasm compilergenerates native code meets conditions finallysection vb demonstrate zerocost conditionsdesign new sfi scheme combining hardwarebacked memory isolation existing llvm compiler passesiii g ated ssembly l anguageformalize zerocost transitions assembly languagesfiasm captures key notions application interactingsandboxed library focusing capturing propertiestransitions application sandboxed librarylibraryfunclibraryhelperpush r12store sp 1 hmov r12 1retload r1 sp 1add r1 r12libraryhelperpop r12retcode figure 1 summarizes syntax sfiasm r iscstyle language natural numbers n sole data typecode c memory m separated captureseparation application code sandboxed library code cimmutable partial map n pairs privilegep app lib command c app libsecurity domainslibraryhelper called overwrite stack slotlibraryfunc saved r12 libraryfuncrestore r12 attackers desired value monitor states memory total map n values vprohibits crossfunction tampering ensuring assume memory subdivided disjoint regionssubsequent reasoning calleesave integrity carried mp application library separate memoryregions divided disjoint heaplocally function5 confidentiality finally monitor uses dynamic informa hp stack sp write denote states machinetion flow control ifc tracking define confidentiality configurations comprise code memory fixedscratch registers monitor tracks secret application finite set registers mapping register names rn valuesvalues stored scratch registers flow sandboxed distinguished stack pointer sp program countercode checks library code leak pc register write lcmp cpc p cinformation concretely implementations enforce current instruction c security domain p writeensuring functions localized control flow 0 program mean 0 valid initial programstate definition validity varies different sfiregister local stack variables initialized useprove zerocost conditions characterize techniques heavyweight transitions assumptionslibraries securely isolated zerocost transitions initial state separate stackcombination memory isolation function calls gated calls returns capture transitionsoverhead springboards trampolines application library defining pair instructionstheorem 1 section va wasm type gatecalln gateret serve way switchsecurity domains gatecallnrepresents application sandboxcallback sandbox application nannotation representing number arguments passedsecond gateret represents corresponding returnsandbox application viceversa leave reductionrule implementation specific order capturedetails given sfi systems trampolines springboards1 22 lc2 mp21 lc1 mp1p1 p2 p012 0lgatecalln im2 lgateretm0memory isolation sfiasm provides abstract mechanismsenforcing sfi memory isolation equipping standardfigure 2 wellbracketed transitionsload store push pop optional statically annotated checks capture different styles enforcementmodel checks partial functions map pointernew value undefined particular address systems enable zerocost transitions exploringinvalid lets instance capture nacls coarse correctness particular implementations springboardsgrained dynamically enforced isolation sandboxed code trampolines baseline prove naclstyleread write sandbox memory requiring heavyweight transitions satisfy highlevel propertiesloads stores annotated f nnmlib n wellbracketed gated calls sfi systems allow arbitrarycontrolflow integrity sfiasm provides abstract control nesting calls callbacks sandboxflow integrity enforcement annotations jmp insufficient define calleesave registersret enforced dynamically require properly restored simply equating register statestandard control flow operations remain entering exiting sandbox instead notionsecurity domain gatecall gateret remain entry corresponding exit precisesfiasms gatecall gateret define notion wellthe way switch security domainsbracketed gated calls serve backbone transitionoperational semantics capture dynamic behaviorintegrity properties wellbracketed gateddeterministic small step operational semanticswrite0 figure 2 captures idea gatedrules standard rule loadsecurity domain followed runninghaddri vaddr0 kaddrnew security domain 0 result gatedv m addrr rr 7 vreturn balances gated includepotentially recursive balanced gated calls wellbracketedlr loadk im r r0gated calls let relate state gatedv evaluates immediate value based register file state corresponding gated return capturingincrements pc checking remains library fully returned applicationsecurity domain function kaddr undefinedaddr bounds program step integrity relations states callingdistinguished terminal state error lcm simply shorthand sandbox corresponding return capture sfilcmp care security domain transition integrity properties identify keylastly include specific halt command instead integrity properties sfi transitions maintain1 calleesave register integrity requires calleesavehalting pc domain cregisters restored returning gatedsecure transitionslibrary ensures attacker unexpectedlygoal specify sandboxed code modify internal state application function2 return address integrity requires sandbox 1 restructure elide springboards trampolines mainturnsinstruction gatecall 2 tampertaining security guarantees waystack pointer 3 modify stackstipulating zerocost sandboxed code equivalentensure attacker tamperspringboards trampolines unfortunatelyapplicationcontrol flowspecification unpleasantly operationalintegrity properties crucial ensurehard right springboards trampolines trickyinvolve significant lowlevel implementation sandboxed library break application invariantssecond specification platformspecific capture formally define abstract notionarchitecture callingconventions requires different integrity property wellbracketed gatedallows cleanly define propertiesspringboards trampolinesinstead use sfiasm declaratively specify highlevel provides general framework capture integrityproperties capture intended security goals transition properties different architecturessystems lets use sfiasm setting studyingspecifically define integrity property predicatetrace state state p captures integritypreserved p type propositionsargument trace sequence steps programtaken making gated argumentsstates wellbracketed gateddefines states properly related leadsfollowing definition iintegritypair n label p extend instructionset r movlabelp storelabelp allowapplication dynamically assign label p value storedregister r pointed respectivelydefinition 2 calleesave register integrity let csrcalleesave registers define csr 1 22 rcsr 1 rcsr sfi transitioncsrintegrity calleesave register integrityconsideration account definingnoninterference property callbackapplication application choose declassify additionalinformation instance sandboxed image decoding libraryparsing file header callback requestingappropriate data decode rest imageapplication callback transfer datapreviously confidential application data sandboxedmemory declassifying transferask comprises public outputconsidered leaking secret applabeled datalowlevel systems leaks occur secret datadefinition 1 iintegrity let trace state state p written file exfiltrated network0 program 0 1 1 lmapp sandboxed libraries arent given direct access calls1 2 imply 1 2 sfi enable exfiltration given indirectaccess callbacks provided host applicationtransition iintegrityoverapproximate public outputs set valuesinstantiate define integrity propertiesreturned application includes valuescalleesave register integrity define calleesave register leaked returned values include argumentsintegrity iintegrity property ignores trace gatecall callback return value gateretargument requires calleesave registers values application values stored sandboxed heapequal stateshlib referenced returned valuesreturn address integrity specify library returnsexpected instruction relation 1 22 pc 1 pc1 restoration stack pointersimilarly specified 2 sp 1 sp specifyingstack integrity involved 1 lacks informationreturn addresses saved look likedata stack instead return addresses definedhistory calls returns leading 1capture trace argument define functionreturnaddress details appendix figure 16computes set locations return addresses basedtrace clause return address integritylocations values preserved 1 2 yieldingpossibility intentional declassificationchoose follow 46 define confidentiality disjointnoninterference follows use lib 0 mean0 agree values label lib representing varyingsecret inputs use m 00 agree sandboxed heap values program counterm arguments passed callback ret 00 agree sandboxed heap valuesprogram counter value return register writtenrret 3 lets define noninterference followsdefinition 3 return address integrityra 1 2 2 pc 1 pc 1 2 sp 1 spdefinition 4 disjoint noninterference2 m returnaddress 1 m returnaddress0 program 1 lmlib 3 lmapp 0lib1 n 2 3 01 1 lib 01lib01 n 02 03 03 lmapp 3 pcconfidentiality sfi systems sure secrets 0 pc 1 lgatecall im 0 lgatecall imleaked untrusted librarym 3 2 2 lgateretm 2 lgateretmprovide confidentiality specify confidentiality non 0 sfi transitionretinterference changing secret inputs affect public disjoint noninterference propertyoutputs context library sandboxing associatesecret application data nonsecret library datadefinition states consecutive sequencepurpose library sandboxing isolating untrustedexecuting exactly n steps sandbox returningcomponents augment values labels appcontrol application varying confidential inputslib lib v app nonsecret flow secretinfluence public outputs library returns controlapp 6v lib secret flow nonsecret valuesapplication number steps sfi transitionsatisfying disjoint noninterference guaranteed2 extended setting mutually distrustingcomponentsdeclassify new data running sandboxsfi transition raintegrityreturn address integrityframe 3 sf baseretaddr loc nreg ncsr valsfunction 3 f instrs n commandentry ntype nostate 3 oerrorstatefuncs n functionstack frameo chn libi vn0 knsp0 sp 1m m sp 7 pc 1stack sf stacksf newframe n0 sp0typechecks n0 sp0stack stack pc n sp sp0 m m 0lcallk imlibo r etisretaddr sphni m spn0 kncsrrestoredpopframelretk mlib0 pc n0 sp sp 1figure 3 osfiasm extended syntaxo j mphn libi vn0 kninsamefunc pc n0ljmpk imlibpc n0iv z ero c ost t ransition c onditionsdefine zerocost conditions safety monitorlanguage osfiasm overlaid sfiasm languageextends sfiasm additional structure dynamic typechecks ensure invariants needed zerocost transitionsmaintained returning library functions providinginductive structure proofs security zerocostimplementations providing level guaranteeintegrity confidentiality properties maintainedo s torehn libi vv h pi0 v i0m m n 7 vwriteable n0n knpi0 app n0hliblstorek mlibm m 0syntax osfiasm figure 3 shows extended syntaxfigure 4 osfiasm operational semantics excerptosfiasm overlay state written wraps state sfiasmextending extra pieces data osfiasmf funcstargetf entry targetsp sprequires sandboxed code organized functionssf stacksp sf retaddr f typefuncs funcs maps command sandboxedlibrary parent function functions f storetypechecks target spcode indices commands field f instrs storeentry point f entry track number argumentssf stackf codfuncsfunction expects f type partitioning sandboxed coderetaddr sf retaddrn n0 f instrsfunctions static second overlay state dynamicallyisretaddr retaddrinsamefunc n n0tracks list overlay stack frames stack stackframes sf solely logical inaccessible instructionssf stackinstead serve bookkeeping implement dynamicr n sf csr vals rr ntype checks osfiasm tracking base addresscsrrestoredstack frame sf base stack location return addresssf retaddr values callee save registerssf stackentry function sf csr vals concernedn sp n sf base n 6 sf retaddrbehavior untrusted library logical stackwriteable nfinely track application stack frames keeps singlelarge stack frame nested application stack framesfigure 5 osfiasm semantics auxiliary predicatescode fails overlays dynamic checks resultstate oerror definition monitor safetyensure zerocost transitions secure simplyauxiliary definitions shown figure 5 shows excerptprogram step oerrorchecks definitionsappendix coverlay monitorosfiasm enforces zerocost conditions extending overlay reduction rule library instrucoperational semantics sfiasm additional checks tions o c checks type safe execution typechecksoverlays small step operational semantics written0 predicate state target target stacksteps refinement underlying sfiasm pointer sp checks 1 address jumpingstep 0 0 oerror figure 4 entry instruction functions 2 stackpointer remains stack sp sp 3 number3 definitions appendix definition 8 definition 9arguments expected callee pushedstack check creates new logicalstack frame recording base new frame locationreturn address current calleesave register valuespushing new frame overlay stack ensure ifcrequire label lib ensure control flowinfluenced confidential values similar checkjumping library code obviating needprogram counter label overlay captureszerocost transitions gatecall behaves exact wayadditional ifc check argumentsinfluenced confidential valuesb overlay semantics enforce securitygoal overlay semantics zerocost conditions capture essential behavior necessary ensureindividual wellbehaved library functions composedsandboxed library enforces sfi integrityconfidentiality properties library code wellbehaved dynamic overlay type behaveequivalently library code springboard trampolinewrappers wellbehaved library code safelyelide wrappers overhead prove theoremsshowing overlay semantics sound respectsecurity properties statementcalleesave register integrityjmp zerocost conditions rely preventing invariantsinternal function interferedfunctions key protection enabling illustrated theorem 1 overlay calleesave register soundness 01 1 p app 12reduction jmp o j mp enforces inter program 0function control flow ret insamefunc 2 6 oerror 1 2 2 rcsrpredicate checks current n target n0 instructions 1 rcsroverlay function check addedv nstantiating z ero c ostprogram counter increment operation checksisolation systems securely supportensure logical stack corresponds actualzerocosttransitions meet overlay monitor zerocostcontrol flow program enabling overlay stacks useconditionssfi webassemblymaintaining invariants level function callsir compiling native code lucetstore reduction rule store o s tore demonstrates toolchain 38 rely languagelevel invariantskey protection enabling function local reasoning wasm satisfy zerocost requirements secondcheck address n writeable given current segmentzero32 novel sfi combining x86state overlay stack writeable guarantees segmented memory model memory isolationoperation writing stack write securityhardening llvm compiler passes enforce zerothe current frame location stored return cost conditionsaddress allows reasoning localized functionwebassemblyneed worry callees tamperingwebassembly wasm lowlevel bytecode soundlocal variables protecting stored return addressstatictype wasms abstract state includes globalcrucial ensuring wellbracketing guaranteesvariablesheap memory zeroinitialized startfunction returns callerheap accesses explicitly bounds checked meaningguarantee ifc o s tore requires pointer compiled wasm programs inherently implement heaplabel lib ensuring location write isolation wasm programs enjoy languagebased confidential data second check pi0 app level properties combination trusted compilern0hlib enforces confidential values written produce binaries satisfying conditions required supportlibrary heap similar checks based standard ifc secure zerocost transitionstechniques implemented instructionscontrol flow arbitrary jump instructions wasmret control flow checks memory write checks structured intrafunction control flow functionsplace guarantee reach ret instruction entered instruction exitedlogical frame correspond actual frame executing return instruction functions associatedret responsible guaranteeing wellbracketing type direct calls type checked compile time indirectensuring calleesave registers restored handled calls subject runtime type check ensuresextra conditions ret instructions isretaddr compiled wasm meets typedirected forwardedge cficsrrestored csrrestored checks callee save registers conditionproperly restored comparing values protecting stack wasm functions type preciselysaved logical stack frame isretaddr describes space required allocate functions stackchecks value pointed stack pointer retaddr frame including spilled registers accesses localcorresponds location return address saved variables arguments performed statically knownlogical stack frame memory writes checked enforce offsets current stack base impossiblereturn address overwritten guarantees wasm operation access stack frames alter savedfunction return expected program locationreturn address ensures compiled wasm meetslocal state encapsulation condition combination theorem logical relation wasm librarytype checking function calls guarantees wasms controltheorem 2 fundamental theorem wasm librariesflow wellbracketed know compiled wasmnumber steps n n compiled wasm library lfunctions execute registersaving preamblen l ltermination execute registerrestoring epiloguefunction body alter values theorem states function compiled wasmregisters saved stack ensuring proper library making calls wasm functionsrestoration calleesave registersapplication callbacks wellbehaved respect zeroconfidentiality wasm code store values function cost conditions number steps technical relatedlocal variables functionlocal value stack similar stepindexing zerocost security follows adequacyjava virtual machine 47 wasm spec requires logical relation theorem 1compilers initialize functionlocal variables theorem 3 adequacy wasm logical relationfunction argument default value accesses number steps n n library l n l lwasm value stack governed coarsegrained data program 0 program l n0 n 0 n0 0flow type explicit annotations control flow joins 0 6 oerrorcheck compiletime instructionpop value stack corresponding value details logical relation proofs appendix dpushed earlier function guarantees b segmentzero32local variable value stack accesses compiledsegmentzero32 novel design 32bit sfiregister accesses accesses staticallyknown offsetschemedeveloped zerocost conditions designstack frameguidesegmentzero32leverages clangllvm compilerexecuting compiled wasm function heavypassesdirectlyenforcestructure required zerocostweight transitions confidential values prior computationstransitionscoderelying wasmlinger spilled registers parts stacksimilarnaclvx3214 segmentzero32checks ensure locationstakesadvantagex86segmentedmemory model 48read previously overwrittenmemoryisolationsegmentationallowsprograms demarcateexecution function lowconfidentiality wasmmemoryregionsstack data heaplibrary valuecode regions hardware support range checksproving wasm secure prove compiled wasm libraries nacl vx32 employ single memory rangesafely elide springboards trampolines maintaining shared sandbox stack heap segmentzero32integrity confidentiality showing compiled code instead separates leverages existing exploitviolate safety monitor allows apply mitigation passes pass design providetheorem 1 analogues relatively straightforward isolation supporting zerocost transitionsexception verify properties wasm passes usedescribed satisfy necessary safety conditionsprotecting stack simply separate stack nonshowing linear instructions basic blockstack segments protect return addresses contextfunction safe basic block properly initializessaved stack standard buffer overflow attacklocal state block jumps typesafe executionsolve issue applying safestack 49 50 compilercalls guaranteed wasms required type checkingpass llvm pass designed protect stack corruptionconfidentiality preserved language invariantpass splits sandboxed stack safe unsaferegisters stack slots written use zerostack safe stack contains data compilerinitializedstatically verify accessed safely return addressescrucial exception proof function callsspilled registers allocations accessed locallywasm functions inductively assume calledverifiably safe offsets function allocatesfunction safe doesnt change variables stackthem4 stack values moved heapframe restores calleesave registers unfortunately naivemodifications sufficient stack safetyattempt lead inductively wellfounded argumentpractice ran compatibility challengeinstead use overlay monitors notion wellbehavedstack segment access safe stack code emitted llvmfunction define stepindexed logical relation detaileduse data segment accessing safe stackappendix da captures semantic notion wellbehavedcompiler assumes flat nonsegmented memory modelfunctions relation f lift relationcorrect develop additional llvm pass annotatesentire wasm library relation l gives basisinstructions stack data segment override prefixesinductively wellfounded argument locallyprove wasm function semantically wellbehaved4 employ llvms existing stackheap clash detection flag fstackis f use prove standard fundamental clashprotection prevent stack growing heapneeded pass assumes esp points safestack start function track flowaddresses derived esp registersfunction determine given memory operandrefers safe stack memory operand referencesincorrect segment pass emits segment override prefixissue patched heap global loads storesstatically assigned nonstack segment registermodel appears guard f n codomain hlibstack operations use verifiably safe offsetsremain unguarded guarantees local state isolationprotects saved register values stack pointer returnaddress notably achieve properties deterministicallysegmentation based memory isolation ensuresattacker guesses stack location dereferencepointer stackcontrol flow protects calleesave registersreturn address saved sandbox frameguaranteeing restoration calleesave registers wellbracketing iff forward control flow enforced fortunatelyenforcing forward edge cfi widely studied 51use cfi pass implemented clangllvm 5253 including flags dynamically protect indirect function calls ensuring forward control flow integritysegmentzero32 conservatively bans nonstructured controlflow including setjmplongjmp c source codepermissive approach possible principle akinfixirreduciblecontrolflow llvm passwebassembly compilation leave future workconfidentiality guarantee confidentiality employexisting experimental clang pass ensures localvariables stack slots registers auto initialized 54ensures scratch registers leak secretssandbox values written use demonstrateszerocost transition scheme enables platformagnostic defense need account detailsscratch registers processor application valuesflow sandbox variablesinclude explicit proof securitysegmentzero32 closely follows proof wasmsecurity main differences administrative changeslogical relation definitions different controlflow graphblocks compiled functionvi e valuationevaluate zerocost transitions asking questionsperformance overhead zerocostheavyweight transitions different sfi systemszerocost transitions improve endtoend performance applications use webassembly sfi vibsegmentzero32 isolation scheme outperformisolation schemes require heavyweight transitionsnative client real workloads vicimplementation answer questions studyperformance native unsandboxed code seven isolationscheme implementationsisolation builds vary transition modelswebassembly sfi based lucet 38compiler lets understand benefits zerocosttransitions webassemblybased sfi systems investigatefollowing builds wasmlucet build uses originalheavyweight springboards trampolines shippedlucet runtime written rust wasmheavy adopts techniquesnacls implementations uses optimized assemblyinstructions save restore application contexttransitions wasmzero implements zerocost transitionmeaning transitions simple function callsperform additional register savingrestoring stackswitching library application code executestack order distinguish overhead registersavingrestoring stack switching test wasmregbuild savesrestores registers similar wasmheavyshares library application stack like wasmzerobuilds use different hardware based isolation schemes measure purposebuilt zerocostisolation scheme segmentzero32 outperform stateoftheart isolation schemes support zerocosttransitions segmentzero32 uses segmentationahardware feature supported 32bit x86 programsbuilds run 32bit mode faircomparison segmentzero32 zerocost segmentationscheme described vb nacl32 native client 32bit isolation scheme 9 modified narayan et al 16support library isolation scheme leverages segmentation employs transitions similar wasmheavycompare idealheavy32 optimal hardwareisolation scheme zerocost compatible schemeincurs slowdowns enforce enable disable isolationsimulate performance idealheavy32 simplymeasure performance native code heavyweighttrampolinesintegrate sfi scheme firefox rlboxframework 16 rlbox provides pluginswasmlucet nacl32 builds implement pluginsremaining builds above5machine software setup run benchmarksmachine intel coretm i76700k 4ghz cores64gb ram running ubuntu 20041 lts kernel version 54058 benchmarks run shielded isolated cpuset 55consisting core hyperthreading disabledclock frequency pinned 22ghz wasm sandboxed codegenerated twopart toolchaincc compiledwasm format clang11 native codefork lucet rlbox snapshot dec9th 2020 nacl sandboxed code generated modified5 segmentzero32 plugin accurately model transition costsemphasize production ready particular relaxrestrictions accessible address ranges need allow access staticdata sections elf binarieswasm builddirectindirectcallbacksyscallfunc cwasmlucetwasmheavywasmregwasmzero1ns120ns120ns7ns56ns1137ns209ns210ns66ns56ns172ns172ns67ns24ns192ns192ns60nsidealheavy32 nacl32 transitions23ns slower func direct calls segmentzero32incurs overhead wasmzero hardware isolationschemes like segmentzero32 nacl32 invokeextra instructions enable disable hardware basedmemory isolation transitions32bit hardwareisolation builddirectindirectcallbacksyscallb zerocost transitions webassembly sfifunc c 32bitidealheavy32nacl32segmentzero321ns324ns24ns74ns179ns714ns108ns74ns154ns373ns80ns37ns181ns356 ns88nsfigure 6 costs transitions different isolation modelszerocost transitions shown boldface funcperformance vanilla unsandboxed c serve baselineversion clang4 cc source code includingsegmentzero32 sandboxed code benchmarksapplications compiled clang11 implementfirefox benchmarks firefox nightly august22 2020evaluate endtoend performance impact different transition models libraries currently sandboxedfirefox font rendering libgraphite imagerendering libjpeg performance sandboxedlibraries previously observed narayan et al 16particularly affected highnumber transitionsfont rendering evaluate performancelibgraphite isolated wasmbased schemeskews benchmark6 narayan et albenchmark reflows text page times adjustingsize fonts time negate effects font cachesrun benchmark 100 times report medianexecution time values standard deviations1transition microbenchmarksmeasure cost different uses transitions directindirect calls sandbox callbacks sandboxsyscall invocations sandbox differentisolation builds described expose overheads fully chooseextremely fast payloadseither function addsnumbers gettimeofday syscall relieslinuxs vdso avoid cpu ring changes resultsshown figure 6 numbers averages millionrepetitions repeated runs negligible standard deviationnote lucets nacls existing implementationssupport direct sandbox calls lucet supportcustom callbacks invocation syscalls reportnumberswasmbased sfi schemes zerocost transitionswasmzero significantly faster optimizedassembly instructions implementing heavyweight transitionswasmheavy lucets existing indirect calls written rustwasmlucet significantly slower stack switching difference wasmheavy wasmreg addssmall overhead transitions performancefunc wasmzero identicaltransitions hidden costcomparing code produced differentcompilers func native code produced clangwasmzero code produced lucet lucets codegeneration highly optimized 56 examplebenchmark adds numbers clang eliminatesfunction prologue epilogue save restores framepointer lucet hardwarebased isolationcompare zerocost transitions segmentzero32heavyweight transitions nacl32 idealheavy32segmentzero32 transitions fasterfont renderwasmlucet wasmheavywasmreg wasmzero8173ms2230ms2246ms2032msexpected zerocost transitions wasmzero resultbest performance compared wasmzero lucets existingtransitions slow rendering 4optimized transitions wasmheavy performance10 slower wasmzero stack switching accounts08 wasmheavys extra costimage rendering firefox renders images streaming modecalling libjpeg decode row imagework wasmsandboxed libjpegproportional width imagecomplexity rendering row image expecteffect pertransition overhead decrease increasingimage width increasing image complexity benchmarkvaries width image complexityfigure 7 shows costs rendering kindsjpeg imagesa simple image consisting single colorsimpleimage stock image image compressionbenchmark suite7 stockimage image randompixels randomimage image rendered 500 timesreport median decoding time standard deviations1 costs normalized wasmzero highlightrelative overheads different transitions comparedzerocost transitions results wasmlucet includedappendix figure 26 rendering times92 longer builds skews graphsinstead focus evaluating overheads optimizedheavy transitions wasmlucet performance numbershighlight fact care needed implementing optimized6 available7 onlinehttpsjfkthamegithubiotestudhrurdhtmlhttpsimagecompressioninfotestimages visited dec 9 2020normalized overhead110wasmzerowasmheavywasmreg110wasmzerowasmheavywasmreg105wasmzerowasmheavywasmreg1051001000955001000image width pixels09550015001000image width pixels1500500b stockimagesimpleimage1000image width pixels1500c randomimagecumulativeimage percentfigure 7 performance different wasm transitions rendering simple image color b stock imagec complex image random pixels normalized wasmzero wasmzero transitions outperform transitionsdifference diminishes width narrower images common webimage width pixelslog scalefigure 8 cumulative distribution image widthslanding pages alexa 500 websites 80images widths 480 pixels narrower imageshigher transition rate higher relative overheadsexpensive transitionsheavyweight transitions transitions availablecurrent tools fully optimizedexpected wasmzero significantly outperformstransitions images narrower simplersimpleimage wasmheavy wasmlucet297 92 longer render imagewasmzero transitions performance differencediminishes image width increases stockimagerandomimage wasmheavy trends similarrendering time differences start 45 lucetsexisting transitions wasmlucet significantly slowerzerocost transitions wasmzero wide imagesdifferences transitions smallerimage width increases imagesweb narrow figure 8 shows distribution imageslanding pages alexa 500 websites106k images 86k 80 widths 1480 pixels range zerocost transitions noticeablyoutperform kinds transitionsc zerocost transitions native isolationsection compare performance native codecode isolated segmentzero32 zerocosttransitions code isolated nacl nacl32support zerocost transitions segmentzero32nacl32 isolate nativecompiled libraries goingwasm use hardware support enforce isolationadditionally compare hypothetical isolationisolation enforcement overhead idealheavy32heavyweight transitions simulates performanceisolation schemes hardware mpk 25negligible overhead require heavyweight transitionsidealheavy32 performance simulated runningnative unsandboxed code heavyweight transitionsmeasure performance rerun libgraphitelibjpeg benchmarks previous sectionisolate libraries segmentzero32 nacl32idealheavy32 segmentzero32nacl32 use segmentation supported 32bit mode implement isolation builds32bit mode compare native 32bit unsandboxedcode benchmarks segmentzero32zerocost transitions outperforms nacl32hypothetical idealheavy32 isolationindividual benchmarksfont rendering impact isolation schemesfont rendering shown standard deviations 1unsandboxed idealheavy32 nacl32 segment32bit codezero32font render1441ms2399ms2769ms1765msobserve nacl32 idealheavy32 incur overhead 92 66 respectively compared unsandboxedcode contrast segmentzero32 overhead225 save restore registers switchstacks overhead segmentzero32 native codedifferent factors segmentzero32change segments enabledisable isolationfunction calls second uses indirect function callsinvocation choice simplifies engineeringfundamental finally small slowdown imposedcode structure enforced allow zerocost transitionsimage rendering impact sandboxingschemes image rendering compared figure 9 standard deviations 1 narrow images width 10pixels segmentzero32 overheads relative nativeunsandboxed code 24 1 65 simpleimagestockimage randomimage respectively lowercorresponding overheads nacl32 31229 66 respectively idealheavy32208 28 45 respectively observed wasmnormalized overheadunsandboxed 32bit codesegmentzero32idealheavy32nacl32unsandboxed 32bit codesegmentzero32idealheavy32regnacl325001000image width pixelssimpleimage1500unsandboxed 32bit codesegmentzero32idealheavy32nacl325001000image width pixelsb stockimage15005001000image width pixels1500c randomimagefigure 9 performance image rendering libjpeg sandboxed segmentzero32 nacl32 idealheavy32times relative unsandboxed code nacl32 idealheavy32 relative overheads high 312 208respectively segmentzero32 relative overheads exceed 24workloads overheads reduce image width increasescomplexity image increases additionallyobserve overheads negligible images wider480 pixels seen earlier images constitute20 images alexa 500 websitesreading uninitialized scratch registersensure confidentiality heavyweight springboardsclear scratch registers specify cfggranularity clear strong satisfyzerocost type safe cfi requirementconclusion evaluation conclude perfor webassembly based isolation wasmboxc 35 sandboxes cmance isolation scheme supports zerocost transitions code compilation wasm followed decompilationsignificantly lower certain workloads especially c ensuring sandboxed c code inheritlarge number transitions additionally isolation properties wasm sandboxed library codeworkloads transition frequently rendering safely linked c applications enabling formwide images additional runtime overheads imposed zerocost transition zerocost wasm sfizerocost condition enforcement result significant described paper designed released priorperformance overheadsindependently wasmboxc creators wasmboxcacknowledge believe theory developedvii r elated workpaper provides foundation analyzing provingconsiderable research gone efficient security wasmboxc analysis needimplementations memory isolation cfi techniques account possible undefined behavior introducedprovide sfi platforms 2 3 58 11 compiling wasm c12 14 2022 38 5760 systemssledge 13 describes wasm runtime edge computingimplement require user implement heavyweight relies wasm properties enable efficient isolationspringboards trampolines guarantee securityserverless components sledge focuses functionsfi systems wahbe et al 1 suggest ways optimize scheduling including preempting running wasm programstransitions 1 partitioning registers application needs context saving differ library sandboxingsandboxed component 2 performing link time contexts saved middle function callsoptimizations lto conservatively eliminates registersfi verification work includes compiler tcbsaves entire sandboxed componentprevious work sfi 2 4 9 62 instead usescallee register partitioning cause slowa verifier small verified trusted program theoremdowns increased spilling native client 9 optimizedprover 23 63 validate relevant sfi propertiestransitions clearing saving contexts machinecompiled sandbox code verifiersspecific mechanisms like intel fxrstor instructioncurrently establish sufficient properties zerocost transitionsclears floating point state simd registerssafety monitor definition provides appropriate contextvi transitions impose significant overheadextending existing sfi verification work validatecpu makers continue add optimized context switchingcompiled code meets sfi zerocost conditionsinstructions instructions eliminate overheadzeng et al 61 combine sfi scheme rich cfi hardware based isolation hardware features memoryscheme enforcing structure executing code similar protection keys 25 26 extended page tables 64 virtuapproach goal safely perform optimizations elide alization instructions 64 65 dedicated hardwaresfi cfi bounds checks impose sufficient designs 66 speed memory isolationstructure enforce wellbracketing necessary property works focus efficiency memory isolationzerocost transitions xfi 4 combines sfi scheme switching protected memory domains requirerich cfi scheme adopts safe stack model heavyweight transitions idealheavy32 section vi studmeeting zerocost conditions prevent ies idealized version schemecapabilities 67 68 look protecting interacting components systems provide hardware enforcedcapabilities 67 specifically looks register savingrestoration optimized based different levels trustcomponents analysis offerformal security guarantees 68 investigate callingconventionbased capabilities cheri 69allows safe sharing stack distrusting componentsdefinition wellbracketed control flow local stateencapsulation overlay inspired worklogical relation based worktechnique ensure equivalent notionconfidentiality property tied machine supporthardware capabilitieslto zerocost transitions applied wasmreduce transitions simple function allowslto optimize code calls applicationwasmboundary dont use lto application sandboxboundary benchmarks lto speedups wasmsandboxed code examined zakai 35type safety isolation workstronglytyped languages provide similar security benefitssingularityos 32 70 71 explored sing buildos cheap transitions mutually untrustingprocesses unlike work sfi techniques zerocosttransitions extend tools like singularityos require engineeringeffort rewrite unsafe components new safe languageslower level typed assembly language tal 3372 73 type safe compilation target highlevel typesafe languages type enables proofs assemblyprograms follow calling conventions enables elegantdefinition stack safety polymorphism unfortunatelysfi designed unsafe code mind generallycompiled meet tals static checks handlezerocost security conditions instead capture behaviortals type designed ensure1 r wahbe s lucco t e anderson s l graham efficientsoftwarebased fault isolation proceedings fourteenthacm symposium operating systems principles ser sosp 93association computing machinery 1993 pp 203216 onlineavailable httpsdoiorg1011451686191686352 s mccamant g morrisett evaluating sfi cisc architecture 2006 online available httpswwwusenixorgconference15thusenixsecuritysymposiumevaluatingsficiscarchitecture3 g tan et al principles implementation techniques softwarebasedfault isolation publishers 20174 erlingsson m abadi m vrable m budiu g c necula xfisoftware guards address spaces osdi 20065 m castro m costa jp martin m peinado p akritidis donnellyp barham r black fast bytegranularity software fault isolationosdi 20096 j n herder h bos b gras p homburg s tanenbaum faultisolation device drivers dsn ieee 20097 m seltzer y endo c small k smith dealing disastersurviving misbehaved kernel extensions osdi vol 96 56 19968 s lucco o sharp r wahbe omniware universal substrateweb programming www 19959 b yee d sehr g dardyk j b chen r muth t ormandy s okasakan narula n fullagar native client sandbox portableuntrusted x86 native code 2009 30th ieee symposium securityprivacy 2009 pp 7993 issn 2375120710 haas rossberg d l schuff b l titzer m holmand gohman l wagner zakai j bastien bringing webspeed webassembly proceedings 38th acm sigplanconference programming language design implementationassociation computing machinery 2017 pp 185200 onlineavailable httpdlacmorgcitationcfmdoid3062341306236311 j siefers g tan g morrisett robusta taming native beastjvm ccs 201012 b niu g tan rockjit securing justintime compilationmodular controlflow integrity ccs 201413 p k gadepalli s mcbride g peach l cherkasova g parmersledge serverlessfirst lightweight wasm runtime edgemiddleware 202014 b ford r cox vx32 lightweight userlevel sandboxingx86 usenix atc 200815 b ford vxa virtual architecture durable compressed archivesfast vol 5 200516 s narayan c disselkoen t garfinkel n froyd e rahm s lernerh shacham d stefan retrofitting fine grain isolationfirefox renderer usenix sec 202017 1566288 rlbox port libgraphite usage code use rlboxapi online available httpsbugzillamozillaorgshowbugcgiid156628818 pat hickey announcing lucet fastlys native webassemblycompilerruntimehttpswwwfastlycomblogannouncinglucetfastlynativewebassemblycompilerruntime 201919 t mcmullen lucet compiler runtime highconcurrencylowlatency sandboxing prisc 202020 m payer t r gross finegrained userspace securityvirtualization 2011viii d iscussionzerocost transitions significantly simplify transitionsapplication sandbox shown section viimprove performance real workloads additionallyoffer benefits performance clarity designingisolation schemes discuss brieflymultithreading separate stacks believe stackswitching incur larger overheads shown section virunning workloads multiple application threadsinvoke sandboxed code parallel applicationmaintain nton stack mapping corresponding sandboxstack application thread invokes sandboxedfunction large applications like browsers clearthreads invoke sandboxed code ahead timeexisting tools 16 maintain check mapping lazilyheavyweight trampoline adding additionallatency heavyweight transitionsalternate abis measure transition overheadv 32bit 64bit calling conventionswindows 74 requires savingrestoring 10 additional floating point registers incurlarge overhead heavyweight trampolinescomplicated expensive isa extensionsintroduce registerszerocost transition compatible hardwaredemonstrated hardware support memory isolationzerocost transitions separate heap stackoperations simple observation provides blueprintfuture isolation hardware including hardware extensions64bit cpus support zerocost schemesr eferences21 d sehr r muth k schimpf c biffle v khimenko b yee b chene pasko adapting software fault isolation contemporary cpuarchitectures usenix sec 201022 ar adltabatabai g langdale s lucco r wahbe efficientlanguageindependent mobile programs pldi 199623 l zhao g li b sutter j regehr armor fully verifiedsoftware fault isolation emsoft 201124 y zhou x wang y chen z wang armlock hardwarebasedfault isolation arm proceedings 2014 acm sigsacconference communications security 2014 pp 55856925 vahldiekoberwagner e elnikety n o duarte m sammlerp druschel d garg erim secure efficient inprocess isolationprotection keys mpk 28th usenix security symposiumusenix security 19 usenix association 2019 pp 1221123826 m hedayati s gravani e johnson j criswell m l scott k shenm marty hodor intraprocess isolation highthroughput dataplane libraries usenix atc 201927 f alder j van bulck d oswald f piessens faulty point unitabi poisoning attacks intel sgx acsac 202028 s maffeis j c mitchell taly object capabilities isolationuntrusted web applications ieee sp 201029 mettler d wagner t close joee securityorientedsubset java network distributed security symposiumndss 201030 m grimmer r schatz c seaton t wrthinger h mssenbck memorysafe execution c java vm workshopprogramming languages analysis security plas 201531 m miller m samuel b laurie awad m stay caja safeactive content sanitized javascript httpgooglecajagooglecodecomfilescajaspec20080607pdf june 200832 g c hunt j r larus singularity rethinking software stacksigops operating systems review vol 41 2 200733 g morrisett k crary n glew d grossman r samuels f smithd walker s weirich s zdancewic talx86 realistic typedassembly language acm sigplan workshop compiler supportsoftware pp 2535 199934 j bosamiya b lim b parno webassembly intermediatelanguage provablysafe software sandboxing prisc 202035 zakai wasmboxc simple easy fast vmless sandboxing httpskripkengithubioblogwasm20200727wasmboxchtml 202036 s narayan t garfinkel s lerner h shacham d stefan gobiwebassembly practical path library sandboxing 201937 h lu m matz m girkar j hubika jaeger m mitchellv application binary interfaceamd64 architecture processorsupplementwith lp64 ilp32 programming models tech rep2018 online available httpssoftwareintelcomcontentdamdevelopexternalusendocumentsintrotointelavx183287pdf38 lucet online available httpsgithubcombytecodealliancelucet39 webassembly micro runtime online available httpsgithubcombytecodealliancewasmmicroruntime40 native client team native client security contest archive httpsdeveloperchromecomdocsnativeclientcommunitysecuritycontest200941 issue 2919 security naclswitch leaks naclthreadcontext pointerx8632 untrusted code httpsbugschromiumorgpnativeclientissuesdetailid2919 201242 issue 775 uninitialized sendmsg syscall arguments selldr httpsbugschromiumorgpnativeclientissuesdetailid775 201043 issue 1607 signal handling change allows inner sandbox escapex8632 linux chrome httpsbugschromiumorgpnativeclientissuesdetailid1607 201144 issue 1633 inner sandbox escape 64bit windows kiuserexceptiondispatcher httpsbugschromiumorgpnativeclientissuesdetailid1633 201145 bartel j doe years escaping java sandboxphrack 201846 matos g boudol declassification nondisclosure policy 18th ieee security foundations workshop csfw052005 pp 22624047 java platform standard edition java virtual machine guide techrep 2019 online available httpsdocsoraclecomenjavajavase13vmjavavirtualmachineguidepdf48 intel 64 ia32 architectures software developers manual 202049 v kuznetsov l szekeres m payer g candea r sekard song codepointer integrity 11th usenix symposiumoperating systems design implementation osdi 14 2014 pp147163 online available httpswwwusenixorgconferenceosdi14technicalsessionspresentationkuznetsov50 safestack clang 12 documentation online available httpsclangllvmorgdocssafestackhtml51 n burow s carr j nash p larsen m franz s brunthalerm payer controlflow integrity precision security performanceacm computing surveys vol 50 pp 1611633 apr 2017 onlineavailable httpsdoiorg101145305492452 control flow integrity clang 12 documentation online availablehttpsclangllvmorgdocscontrolflowintegrityhtml53 c tice t roeder p collingbourne s checkoway erlingssonl lozano g pike enforcing forwardedge controlflow integritygcc llvm proceedings 23rd usenix security symposiumk fu j jung eds 2014 pp 94195554 automatic variable initialization online available httpsreviewsllvmorgrl34944255 shieldinglinuxresourcesintroductiononlineavailable httpsdocumentationsusecomslert15sp1htmlslertallchashieldingintrohtml56 l t hansen cranelift performance parity baldr x8664httpsbugzillamozillaorgshowbugcgiid1539399 201957 n goonasekera w caelli c fidge libvm architectureshared library sandboxing vol 45 12 pp 15971617 2015online available httpsonlinelibrarywileycomdoiabs101002spe229458 bittau p marchenko m handley b karp wedge splittingapplications reducedprivilege compartments 5th usenixsymposium networked systems design implementation nsdi2008 april 1618 2008 san francisco ca usa proceedingsj crowcroft m dahlin eds usenix association 2008 pp309322 online available httpwwwusenixorgeventsnsdi08techfullpapersbittaubittaupdf59 j litton vahldiekoberwagner e elnikety d garg b bhattacharjeep druschel lightweight contexts os abstraction safetyperformance proceedings 12th usenix conferenceoperating systems design implementation ser osdi16 usenixassociation 2016 p 496460 y chen s reymondjohnson z sun l lu shreds finegrainedexecution units private memory 2016 ieee symposiumsecurity privacy sp 2016 pp 567161 b zeng g tan g morrisett combining controlflow integritystatic analysis efficient validated data sandboxingproceedings 18th acm conferencecommunications security ser ccs 11 new york ny usaassociation computing machinery 2011 p 2940 onlineavailable httpsdoiorg1011452046707204671362 e johnson d thien y alhessi s narayan f brown s lernert mcmullen s savage d stefan trust verify sfi safetynativecompiled wasm network distributed securitysymposium ndss internet society february 202163 j kroll g stewart w appel portable software faultisolation 2014 ieee 27th security foundations symposiumieee 2014 pp 183264 w qiang y cao w dai d zou h jin b liu libsechardware virtualizationbased isolation shared library 2017ieee 19th international conference high performance computingcommunications ieee 15th international conference smartcity ieee 3rd international conference data science systemshpccsmartcitydss 2017 pp 344165 belay bittau mashtizadeh d terei d maziresc kozyrakis dune safe userlevel access privileged cpu featuresproceedings 10th usenix conference operating systemsdesign implementation ser osdi12 usa usenix association2012 p 33534866 d schrammel s weiser s steinegger m schwarzl m schwarzs mangard d gruss donky domain keys efficientinprocess isolation riscv x86 29th usenix securitysymposium usenix security 20 usenix association aug 2020pp 16771694 online available httpswwwusenixorgconferenceusenixsecurity20presentationschrammel67 p karger registers optimize crossdomainperformance proceedings international conferencearchitectural support programming languages operatingsystems ser asplos iii new york ny usa associationcomputing machinery 1989 p 194204 online availablehttpsdoiorg101145700826820168 l skorstengaard d devriese l birkedal stktokens enforcingwellbracketed control flow stack encapsulation linearcapabilities proceedings acm programming languagesvol 3 popl pp 128 jan 2019 online availablehttpdlacmorgcitationcfmdoid3302515329033269 r n m watson j woodruff p g neumann s w moore j andersond chisnall n dave b davis k gudka b laurie s j murdochr norton m roe s son m vadera cheri hybrid capabilitysystem architecture scalable software compartmentalization 2015ieee symposium security privacy 2015 pp 203770 m aiken m fhndrich c hawblitzel g hunt j larusdeconstructing process isolation workshop memoryperformance correctness 200671 m fhndrich m aiken c hawblitzel o hodson g hunt j rlarus s levi language support fast reliable messagebased communication singularity os eurosys acm 200672 g morrisett d walker k crary n glew ftyped assembly language acm transactions programminglanguages systems vol 21 pp 527568 1999 onlineavailable httpsdoiorg10114531930131934573 g morrisett k crary n glew d walker stackbased typed assembly language journal functionalprogramming vol 12 pp 4388 jan 2002 publishercambridgeuniversitypressonlineavailablehttpswwwcambridgeorgcorejournalsjournaloffunctionalprogrammingarticleabsstackbasedtypedassemblylanguagefaa86c307845c6e28b88f57ee64c6f3b74 x64 calling convention tech rep 2020 online available httpsdocsmicrosoftcomenuscppbuildx64callingconventionviewmsvc160ppendixl anguage d efinitionsfigure 10 presents syntax sandbox language model programs define regions m mp hp sp cpm n represents memory space mp hp sp memory heap stack applicationlibrary heap stack sit disjointly inside memory cp set instruction indices cn pset import indices beginnings application functions library allowed jumpnote calling convention arguments passed stack return address placed argumentsapplication passes arguments library marks integrity libprivvalregcheckimmediatecommandpc sp ncoderegvalsmemorystateapp libhn pirn sp pcr v iir popppushpr loadkstorekr movcallkretkjmpkr movlabelpstorelabelpgatecallngateretn priv commandreg valn valerrorpc nsp nr regvalsm memoryc codefigure 10 syntaxfigure 11 figure 13 define base small step operational semantics separate transitions lcm 0error transitions lcm errorlcm 0v vsp0 sp 1m m sp 7 vsp0 spsps v plpushp im sp sp0 m m 0sp spsps v pv m spr0 rr 7 vlr popp m sp sp 1 r r0hni vn0 knv m nr rr 7 vlr loadk im r r0hni vv v i0n knm m n0 7 vlstorek i0 m m m 0m 0 m n hm pihni vhmi m nlstorelabelp im m m 0hni vn0 knljmpk im pc n0v vr0 rr 7 vlr mov im r r0hni vn0 knsp0 sp 1m m sp 7 hpc 1 libisp0 spslcallk im pc n0 sp sp0 m m 0hni m spn0 knsp spslretk m pc n0 sp sp 1hni rrr0 rr hn pilr movlabelp m r r0hvi vlsp mov im sp vfigure 11 operational semanticslcm errorsp spsps 6v plr popp m errorhni vkn undefinedlstorek i0 m errorsp 1 spsps 6v plpushp im errorsp 1spslcallk im errorhni vkn undefinedlr loadk im errorhni vkn undefinedlcallk im errorspspslretk m errorhni vkn undefinedljmpk im errorhni m spkn undefinedlretk m errorfigure 12 operational semanticscpc clcm0000 6 error0cpc p clcmpv vv rv spv pcv i0hsp libihpc libihv v 0 p u p0hv pi vhv 0 p0 v i0hni hnpc pc 1figure 13 operational semantics auxiliary definitionslib v appfigure 14 defines unguarded derived forms memory operationsr poppushr loadstore i0jmpretr poppushr loadidstoreid i0jmpidcallidretidfigure 14 derived formssandbox properties1 22 lc2 mp21 lc1 mp1p1 p2 p12 0lgatecalln im2 lgateretm0figure 15 wellbracketed transitions1 integrity integrity maintaining application invariants calls sandbox invariants varysignificantly program program capture generality define iintegrity instantiatespecific instancesdefinition 5 iintegritylet trace state state p 0 program 0 1 1 p app 1 2 imply1 2 sfi transition iintegrityinformally calleesave register integrity says values calleesave registers restored gated callssandboxdefinition 6 calleesave register integritylet csr list calleesave registers definecsr 1 2 1 rcsr 2 rcsrsfi transition csrintegrity calleesave register integrityreturnaddressp trace nreturnaddressp 0 lcallk imp 0 returnaddressp 0 sp 1returnaddressp 0 lretk mp 0 returnaddressp 0 spreturnaddressp 0 lgatecalln imp 0 returnaddressp 0 sp 1returnaddressp 0 lgateretmp 0 returnaddressp 0 spreturnaddressp 0 lcm 0 returnaddressp 0returnaddressp 0 0 0figure 16 stack return address calculationdefinition 7 return address integrity definera 1 2 1 m returnaddressapp 2 m returnaddressapp 2 sp 1 sp 2 pc 1 pc 1sfi transition raintegrity return address integrity2 confidentiality let v map type val define v lib following restriction vv hn libiv libundefinedlib 0 rlib 0 rlib m lib m lib equality partial functions requiresdomain define notions observational equivalencedefinition 8 n 01 m hlib 0 m hlib2 pc 0 pc3 sp 0 sp4 1 n exists n0 hn0 libi m sp 0 m spsecond let rret calling convention return registerdefinition 9 ret 01 m hlib 0 m hlib2 pc 0 pc3 exists n hn libi rrret 0 rrretdefinition 10 disjoint noninterferencelib0 program 1 lmlib 3 lmapp 0 1 n 2 3 01 1 lib 01lib01 n 02 03 03 lmapp 3 pc 03 pc1 2 lgatecalln0 im 02 lgatecalln0 im 3 n0 032 2 lgateretm 02 lgateretm 3 ret 03sfi transition disjoint noninterference propertyppendix bn ac lnacl context applicationctx 0library stack pointerctxctxnacl context libraryctx 0application stack pointerctx 1csr0csr1ctx 2ctx lencsrcsrlencsr1ctxctxfigure 17 transition context layoutnaclspringboardnr0 load ctxr1 load r0j lencsr 0 store r0 csrj r0 r0 1r1 r1 nsp sp 1j 0 n r2 pop storemlib r1 r2 r1 r1 1r2 sp n 1 store r0 r2sp r1 nstore ctx r0r r r mov h0 libijmpr1 holds library stack pointersave callee save registersset r1 new library stackstack pointer argumentcopy arguments library stacksave stack pointerset new stack pointerupdate ctxclear registersnacltrampolinej 0 lencsrr0 load ctxr0 r0 1 csrj load r0r0 load ctxr1 load r0r0 r0 lencsr store r0 spstore ctx r0sp mov r1retnaclcbspringboardnr0 load ctxr1 load r0r0 r0 1 store r0 spstore ctx r0sp sp 1r1 r1 nj 0 n r2 popmlib store r1 r2 r1 r1 1sp r1 njmpinaclcbtrampoliner0 load ctxr1 load r0r0 r0 1 store ctx r0sp mov r1r r r mov h0 libiretclibrestore callee save registersr1 holds application stack pointersave library stack pointerupdate ctxswitch application stackr1 holds application stack pointersave stack pointerupdate ctxstack pointer argumentset r1 new library stackcopy arguments application stackset new stack pointerr1 holds library stack pointerupdate ctxswitch library stackclear registersprogramsnacl program defined following conditions1 memory operations sandboxed library guardedncn lib r popp p libcn lib pushp p libcn lib r loadchk chk mlibcn lib storechk chk mlib2 application write app data sandbox memory3 gated calls way application library codencn p callchk chk cpcn p retchk chk cpcn p jmpchk chk cp4 sandboxed library change integrity labelsncn 6 lib r movlabelpcn 6 lib storelabelp5 program starts application pc 0 c0 app6 ctx ctx start initialized library stackctx happhctxi m ctx happm ctx slib 0 1b propertiesfollowing use shorthand ctx m ctxproposition 1 nacl disjoint noninterference propertyproof follows immediately fact reads writes guarded mlib values mliblabel lib jumps remain library codelemma 1 trampoline context happlemma 2 ctx ctx0lemma 3 1 lcmlib 12 00 mapp 0 mappproof cases p p app p lib p app 2 1 trivially 2 mapp 1 mappp lib 1 2 cpc lib structure nacl programensures 2 mapp 1 mapplemma 40 p 0 plemma 5 0 00 0 00 p 6 p 0 p pproof proceed simultaneous induction wellbracketed transition 0 length 0 0case callbackslgatecalln im exist 1 2 p 12 0 2 lgateretm2 inspection reduction gatecalln know 1 p 6 p lemma 400 p 6 p inspection reduction gateret 0 p pcase callbackslgatecalln im exist 1 2 12 0 2 lgateretm2 inspection reduction gatecalln know 1 p 6 p induction2 2 p 1 p 6 pproof steps clearly 2 p 1 p 6 p possible cases 1344 lemma 4 gives 4 p 3 p 1 p 6 p 3 4 outer inductive hypothesis gives4 p 3 p 1 p 6 plastly inspection reduction gateret p plemma 60 0 p pproof induction lemma 4 lemma 5lemma 7 context integrity let 0 program 0 01 p app m ctx0 ctx 0 m ctx0 ctx0 ctx ctx02 p lib m ctx0 ctx 0 m ctx0 ctx0 ctx ctx0proof proceed mutual simultaneous induction wellbracketed transition 1 2 length 00consider case lcmappcase callbackslgatecalln im exist 1 2 p 12 0 2 lgateretmlemma 3 1 mapp 2 mapp assumption lgatecalln imapplemma 5 2 lgateretmlib lemma 1 lemma 2 inspection reduction rules gatecallngateret m ctx0 ctx 0 m ctx0 ctx0 ctx ctx0case callbackslgatecalln im exist 1 2 12 0 2 lgateretminspection reduction rule gatecalln ctx1 ctx lencsr induction2 ctx2 ctx1 1 m ctx0 ctx1 2 m ctx0 ctx2proof steps clearly ctx2 ctx1 1 mapp 2 mapp possible cases134 notice 3 p 1 p lib lemma 6 34 lemma 3 gives3 mapp 4 mapp lemma 1 gives ctx4 ctx3 ctx1 3 4 case 2inductive hypothesis gives 1 m ctx0 ctx1 3 m ctx0 ctx3 4 m ctx0 ctx4ctx4 ctx3 ctx1finally lemma 6 2 lib inspection reduction rule gateret givesm ctx0 ctx 0 m ctx0 ctx0 ctx ctx0second consider case lcmlibcase callbackslgatecalln im exist 1 2 p 12 0 2 lgateretmstructure nacl program ctx1 ctx2 1 m ctx0 ctx1 2 m ctx0 ctx2assumption lgatecalln imlib lemma 5 2 lgateretmapp lemma 2inspection reduction rules gatecalln gateret m ctx0 ctx 0 m ctx0 ctx0ctx ctx0case callbackslgatecalln im exist 1 2 12 0 2 lgateretminspection reduction rule gatecalln ctx1 ctx 1 induction2 ctx2 ctx1 1 m ctx0 ctx1 2 m ctx0 ctx2proof steps clearly ctx2 ctx1 1 mapp 2 mapp possible cases134 notice 3 p 1 p app lemma 6 34 structurenacl program gives ctx1 ctx2 1 m ctx0 ctx1 2 m ctx0 ctx2 3 4 case1 inductive hypothesis gives 1 m ctx0 ctx1 3 m ctx0 ctx3 4 m ctx0 ctx4ctx4 ctx3 ctx1finally lemma 6 2 app inspection reduction rule gateret givesm ctx0 ctx 0 m ctx0 ctx0 ctx ctx0proposition 2 nacl calleesave register integrityproof follows lemma 7 lemma 5 inspection reduction rules gatecalln gateretlemma 8 let 0 programm returnaddressapp0 0 m returnaddressappproof consider case lcmappcase callbackslgatecalln im exist 1 2 p 12 0 2 lgateretminspection reduction rule gatecalln 1 m sp 1 pc 1 addingstack structure nacl program 1 m returnaddressapp m returnaddressapplemma 3 1 mapp 2 mapp lemma 1 gives ctx2 ctx12 m returnaddressapp 1 m returnaddressapp inspect trampoline code rightexecute ret set sp 2 m ctx2 1 m ctx1 sp 1 returningapplication stack modify sp 1 fact 2 m returnaddressappm returnaddressapp gives m returnaddressapp 0 m returnaddressappcase callbackslgatecalln im exist 1 2 12 0 2 lgateretminspection reduction rule gatecalln 1 m sp 1 pc 1 addingstack structure nacl program 1 m returnaddressapp m returnaddressappinduction 12 2 m ctx2 sp 1 2 m returnaddressapp1 m returnaddressappproof steps 2 1 goals hold immediately possible cases 14 notice 3 p 1 p lib lemma 6 34 lemma 3 gives4 mapp 3 mapp goal holds returnaddressapp sapp 3 4 lemma 7gives ctx3 ctx4 3 m ctx0 ctx3 4 m ctx0 ctx4 4 m ctx4sp 1 returnaddressapp 0 3 returnaddressapp sp 1 inductive hypothesis gives4 m returnaddressapp 3 m returnaddressappsecond consider case lcmlibcase callbackslgatecalln im exist 1 2 p 12 0 2 lgateretminspection reduction rule gatecalln 1 m returnaddressapp m returnaddressappstructure nacl program stack elements added callbackpopped gateret 2 m returnaddressapp 1 m returnaddressapp inspectionreduction rule gateret gives 0 m returnaddressapp 2 m returnaddressappm returnaddressappcase callbackslgatecalln im exist 1 2 12 0 2 lgateretm inspectionreduction rule gatecalln 1 m returnaddressapp m returnaddressappinduction 12 2 m returnaddressapp 1 m returnaddressapp3proof steps 2 1 goal holds immediately possible cases 14 structure nacl program gives4 notice 3 p 1 p app lemma 6 3stack elements added callback popped gateretinductive invariant maintained 3 4 notice returnaddressapp 0 3 returnaddressappinductive hypothesis gives 4 m returnaddressapp 3 m returnaddressappinspection reduction rule gateret2 m returnaddressapp m returnaddressappgives0 m returnaddressappproposition 3 nacl return address integrityproof 0 program 0 p app 0 wishm returnaddressapp 0 m returnaddressapp 0 sp sp 0 pc pc 1lemma 8 gives m returnaddressapp 0 m returnaddressapp proceed simultaneous inductionwellbracketed transition 0 length 0 0 0 sp sp 0 pc pc 1case callbackslgatecalln im exist 1 2 p 12 0 2 lgateretminspection reduction rule gatecalln 1 m sp 1 pc 1 1 m ctx1 sp 1lemma 3 1 mapp 2 mapp lemma 1 gives ctx2 ctx1 inspecttrampoline code right execute ret set sp 2 m ctx2 1 m ctx1 sp1returning 0 pc pc 1 0 sp spcase callbackslgatecalln im exist 1 2 12 0 2 lgateretminspection reduction rule gatecalln 1 m sp 1 pc 1 1 m ctx1 sp 1induction 12 2 m sp 1 pc 1 2 m ctx2 sp 1proof steps 2 1 hold immediately possible cases 13notice 3 p 1 p lib lemma 6 34 lemma 3 gives 4 mapp3 mapp hold invariants mapp 3 4 lemma 7 gives ctx3 ctx43 m ctx0 ctx3 4 m ctx0 ctx4 4 m ctx4 sp 1 returnaddressapp 03 returnaddressapp sp 1 lemma 8 gives 4 m sp 1 3 m sp 1 pc 1finally inspect trampoline code right execute ret set sp 2 m ctx2sp 1 returning 0 pc pc 1 0 sp spppendix coverlay s emanticsfigure 19 figure 20 figure 21 define overlay monitor operational semanticsframefunctionostatebaseretaddr loc nreg ncsr valsinstrs n commandentry ntypeoerrorstatefuncs n functionstack framefigure 18 overlay extended syntaxlcmhn pi vn0 knsp0 sp 1m 0 m sp0 7 pc 1typechecks n spsf newframe n0 sp0pi v liblcallk imlibstack sf stack pc n sp sp0 m m 0isretaddrloc sphni m spn0 kncsrrestoredpopframelretk mlibpc n0 sp sp 1hn0 vsp0 sp 1m 0 m sp0 7 pc 1ntypechecks n spargssecure sp0 nsf newframe n0 sp0lgatecalln imlibstack sf stack pc n0 sp sp0 m m 0hn0 vsp0 sp 1m m sp 7 pc 1sf newframe n0 sp0lgatecalln imappstack sf stack pc n0 sp sp0 m m 0lretmp0 v phn p rrretlgateretmphn pi vv h pi0 v i0m m n 7 vwriteable n0n knpi v ppi0 6v p n0hliblstorek mpm m 0v vsp sp 1sp spm 0 m sp0 7 vwriteable sp0lpushp imsp sp0 m m 0hn pi vn0 knpi v pv h pn0 m nr0 rr 7 vlr loadk impr r0hv pi vlsp mov impsp vpr 6v p0 pr v phn pr rrr0 rr hn p0lr movlabelp0 mpr r0hn pi vn0 knpi v pinsamefunc pc n0ljmpk imppc n0hn pi vhm pm m npi v pm 0 m n hm p0pm 6v p0 pm v plstorelabelp0 impm m 0lcm 0insamefunc pc 0 pclcm0figure 19 overlay operational semanticsf funcstargetfentry targetsp spsf stacksp sf retaddr loc f typetypechecks target spsf stackn sp n sf base n 6 sf retaddr locwriteable nsf stackretaddr loc sf retaddr locisretaddrloc retaddr locsf stackr n sf csr vals rr ncsrrestoredf codfuncs ndomf instrsinsamefunc n n0f codfuncsn n0 domf instrsinsamefunc n n01 n m sp h libiargssecure sp nfigure 20 overlay operational semantics auxiliary judgmentsnewframe target retaddr locpopframeretaddr loc funcstargettyperetaddr locr rrrcsrbaseretaddr loccsr valsstack s sf s stackerrorinsamefunc pc pc 1figure 21 overlay operational semantics auxiliary definitionslemma 9 overlay refinement0 0 6 oerror 0applemma 10 overlay equivalent application reduction 0funcs stack stacktheorem 4 overlay integrity soundness 0 program 00 n 11 csr 1 22 ra 1 21 1 lmapp 10 funcs2 1 2proof induction definition wellbracketed step nested induction logical stack stepfollows fact 2 6 oerror restoration checks overlay monitor passedlibtheorem 5 overlay confidentiality soundness 0 program 1 lmlib 3 lmapp 0 1 n 2 3lib1 n1 3 1 lib 01 01 n 02 03 01 n1 03 03 lmapp 3 pc 03 pc1 2 lgatecalln0 im 02 lgatecalln0 im 3 n0 032 2 lgateretm 02 lgateretm 3 ret 03proof proof standard ifc enforcementppendix dw eba ssemblylcall imlgatecalln imapp 0 p liblcalli imlgatecalln imlib 0 p appfigure 22 webassembly trampoline springboardlretm 0p lib p applgateretmp 0 p appspcurrent block spill slotsfunction localssaved csrreturn addressargumentsfigure 23 webassembly stack framewebassemblyfunctionblockindirect blockargslocalsentryexitsblocksstartendslotsinputsindirectsstartendparentblockblockblockn regibblockfigure 24 webassembly structurecompiled webassembly library divided disjoint functions f fixed number arguments localsfunction composed set disjoint blocks b blocks code cbstart bend distinguished entryblock set exit blocks fixed number stack slots associated block subset slotsregisters assigned inputs block nonexit block terminated cbend branch jump exitblocks function uniformly terminated retclib gateret simplify things assume webassemblyfunctions function exit blocks terminate gateret application code calls functionbranches jumps appear end blockinstructions appear block sequences instructions correspond direct callswebassemblysp sp flocals bslotspush arg1 push argf 0 argsf 0 entrystartsp sp flocals bslots f 0 argssecond correspond indirect calls associated expected type calleetypecheckr expectedargssp sp flocals bslotspush arg1 push argexpectedargscallt rsp sp flocals bslots expectedargst set entry points functions corresponding webassembly table indirect typecheckimplementation specific code checks function address register r expects expectedargscases instruction replaced gated instructionsp sp flocals bslotstypecheckr npush arg1 push argnsp sp flocals bslotsgatecalln vpush arg1 push argnsp sp flocals bslots ngatecalln rsp sp flocals bslots nv address expects n argumentskinds memory accesses allowed block firstly heap accesses guardedsandboxed heap r loadhlib storehlib i0 secondly argument local variable accesses addressedconstant offsets stack pointer r load sp x store sp x x csrf fargs csrf1 flocals bslots lastly initializing blocks inputs jumping immediately precede constant branchjump instruction b 0 start store sp x x flocals b 0 inputs reads stack slotsregisters preceded writes stack slot register block stack slot register blocks inputset binputswebassemblys indirect branches compiled indirect jump indirect block ib blocks terminatedconstant jump instruction block b consist entirely initializing inputs b indirect block ib readvariables according rules parent block ibparent indirect jump end block b guardedjmpbindirectsstart rlastly webassembly function f s entry block begins pushing subset calleesave registers fblocks writtencsrf exit block pops corresponding registerlogical relationinterfacelibrarycodeworldnnn wasmfunctioncoden n n n nworld world0 fi fl 0 fi fln fi fl n 1 fi flc f2 f3 w1 2fi entry domi wfi fi fi type w fi entryfi fi w fi cfi instrs fframe retaddr n sp r m c fi fllet 0 base sp retaddr loc sp csr vals rcsrf typesp topretaddr locsp 7 retaddr sp 7 ai i0a mc fi fl wdomc f instrsw f cdomm mlib hn libi mlet pc f entry sp sp r r m m c cletstack 0 funcs f 0 entry 7 f 0 f 0 fi fl0 0n0 wn n 0 0 6 oerror0 0n0 wn n 1 0lretm lgateretm 0 stack 0 00 6 oerrorn ldomllibrarylet wf llibraryilet w n linterfacellibraryiargslet instrs bwfblocks bstart bendlet f instrs instrs entry wfentrystart type wfargsw f lcodeinstrs ffigure 25 function library relationslemma 11 ftlr functions let w world c code compiled webassembly function wf wfexpects application functionsinterface locations types 2 w library locations types 3 wlet instrs bwfblocks bstart bend f instrs instrs entry wfentrystart type wfargsw f c fproof unroll assumptions w f c f reusing variable names defined maintainsteps step oerror wologcontinually assume n0 wn n0 greater number steps0 n0taken case0 0 6 oerror holdsstructure compiled webassembly function assumption stack stack pointer representwfargs arguments structure entry block means begin pushing csr rc rc registersmentioned c generalize block wfblocks adding antecedent touchreturn address calleesave registers continue proof structure compiled webassembly blocklets proceed reach 1 function library function wf0 wf0 entrystart fl entry2 application function f 0 f 0 entry fi entry 3 end block1 assumption pushed wf0 args 3 w wf0 entrystart arguments failed dynamictype check terminated stepping terminal state oerror set 2 0constructed 02 2 base sp wf0 args retaddr loc sp csr vals rcsr setretaddr pc 1 wf0 args sp sp r r m m c c fi fi fl fl structurecompiled webassembly remaining checks f pass instantiated equalcurrent state instantiate fl cfl instrs f uses remaining stepsreturn pc 1 values restored new app values written library memorywalk block continue2 identical case 13 end block followed direct jump block b 0 indirect block ib exit blockcase block b 0 structure compiled webassembly code instantiated b 0 inputsjump block follow proof structure detailed true intermediate blockib extra steps setting inputs jumping block b 00 lastly reached endexit block touched pushed return address calleesave registers stack pointerexpected location execute ret gateret pass overlay monitor checkslemma 12 ftlr libraries number steps n n compiled webassembly library l n l lproof unrolling definition l lemma 11theorem 6 adequacy l number steps n n library l n l l program 0 programl n0 n 0 n 0 0 6 oerrorproof straightforward assumption steps application assumption application code properly callinglibrary code unrolling l fnormalized overheadppendix el ucet mage b enchmarkswasmlucet simplewasmlucet stockwasmlucet random5001000image width pixels1500figure 26 performance wasmlucet heavyweight transitions included lucet runtime image benchmarkssection vi performance rendering simple image color b stock image c complex imagerandom pixels performance overhead compared wasmzero