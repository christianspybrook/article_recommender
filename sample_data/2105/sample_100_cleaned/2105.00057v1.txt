speeding pythonbased lagrangian fluidflowparticle simulations dynamic collection datastructuresarxiv210500057v1 physicscompph 30 apr 2021christian kehl erik van sebille angus gibsonabstract arraylike collection data structures widely established pythons scientificcomputingecosystem highperformance computations structure maps regular gridded lattice structures common computational problems physics geosciences highperformance guaranteed static computations fixed computational domain dynamic computations actively changing computational domainarraylike collections provided numpy derivatives bottleneck large computations response integration naturallydynamic collection data structuresdoublelinked lists numpy simulations ctypesbased cbindings benchmarks verifyquantify performance increase attributed change collection data structureapplication scenario lagrangian oceanic fluidflow particle simulation parcels framework demonstrates speedup yield realistic setting demonstrates novel capabilitiesfacilitated optimised collection data structureskey words collection data structures python justintime compilation performance analysisperformance optimisation numerical methods numpy scientific computingams subject classifications 68p05 68q25 18b05 70b051 introduction past decade rise python versatile programming platform scientific research particularly physics geoscienceled development domainspecific numerical simulation modelling platforms subsurface modelling gempy 8 plate tectonicsgplate 17 eulerian oceanic flow simulations veros 10 16lagrangian particle tracing ocean currents parcels 9 simulationmodelling python advantageous coding simplicity novice developersdomain experts versatility typeless interpreterbased processingcomputational efficiency links establish highperformance linear algebralibraries blas 4 lapack 2 packages numpy 25 11scipy 27 scikits 26 21 additionally pythons embedding modern devopstools git wide application opensource openscience projectsadditional reasons high acceptance scientific communitydevelopment parcels 14 9 application platformpaper relies highperformance computation python regardemploys ctypes 20 justintime jit cinterface execute highlyadaptive kernels advection tracing particles ocean general circulationmodel ogcm fields kernels provided elementary python functionsdevelopers user community compiled runtime ccoderapid field interpolation advection evaluation available highperformancepackages numpy handle densematrix data organisation high efficiencyhand problems translated densematrix algebrasubmittedsiam journal scientific computing editors 20210125funding work funded european research council erc topios project grant 715386 simulations carried surfs dutch national einfrastructureproject 16371 2019034institute marine atmospheric research utrecht university netherlandsckehluunl evansebilleuunlaustralian national university angusgibsonanueduauc kehl e van sebille gibsonproblem data dynamically altered simulation pose challengeefficient calculations reorganisation data container arraylike collection cases consume runtime memory overheadrequired particle advection issue arises physicssimulations concern large sets dynamicallychanging physics entitiescommon nbody simulation bodies onthefly added deletedcareful benchmarking section 3 identified data collection reorganisation major barrier increased performance particle simulationsfluid flows paper propose introduction alternative data structures organisation dynamic data entities python furthermore datastructures expressed jitcompliant format increased performancemajor contribution article detailed performance evaluation comparisondata structures data organisation patternsstarting point investigation common arrayofstructure arrangement particles dense array performance benefit structureofarray arrangement allows higher cache coherence better data localityvectorized computations evident static data arrays handlistofarray arrangement sublists defined maximum size limiting memoryreordering overhead fixed upper bound provides marginal improvements despite theoretical upper bound computational complexity subsection 41scenarios dynamic data arrays particle entities insertedintoremovedfrom particle collection arbitrarily simulation runtimeexpense data reordering memory copies poor data locality evidentcontext doublelinked list containers distinct performance advantageespecially large particle collections 215 entities2 related work section review current state efficientcollection data structures pythons scientific computing environmentcomprehensive topic abundant literature concentrate mainly nonarraylike collections access potential python c wrapperspresent background knowledge physics applicationlagrangian oceanic flow simulations particles section mainly serves introduction workflow provides background information performanceand runtime bottleneck concerns21 efficient data structures scientific computing native pythonknown hampered processing performance order circumvent computebottleneck numpy 25 introduced fast cwrapper blas lapackarranges data efficiently blockwise matrices dense arrays array collections arraylike collections dense arrays matricescommon highperformance data structures especially python modern scientific computing data structures main objective random accessitems rarely required modern computing frameworks scipy 27 scikitimage 26 scikitlearn 21 machinelearning frameworks 3 1 6 buildnumpys densearray matrix data structures common fundamentalissue arraylike collections random insertions deletions itemscollection requires array copies merges 24 slows operation requires additional data buffer size collectionprohibitively expensive modern big datacomputingpythoninternal bisect module facilitates listlike collection behaviourbinary searches objects arraylike collections said binary searchspeeding pythonbased lagrangian particle simulationssimplifies object search object access provides functionalityspeedup native internal item insertion deletion functionality providedcollectionsdeque module linked nodelist terms item insertionsdeletions performance exhibits expected constant runtime complexitylogarithmic complexity including item localisation said workingcollectionsdeque module difficult cinterface data structureaccess ctypes poorly documented connectionreliably established cinterface doublelinked listpython interface unilinked listsortedcollections python module promises ccomparableperformance behaviour dynamic collections sortedlist stdlistequivalence module internally wraps python lists arraylike collectionsinternallymanaged item indexing scheme indexing scheme provides constantcomplexity insertions deletions use bisect module internallyfacilitates fast object access module provides performancerelevant features advantages listlike collections drawback modulelack python c interfaces fast execution simulations analysesgap address paper development benchmark dynamiccollection data structures python integrated cinterface rapid computations dynamicallyorganised data22 lagrangian particle tracing oceanic flows parcelsphysicsmotivated prime application scenario tracking virtual particlesoceanic flows virtual particles example represent plastic 15 plankton 18 nutrients 5 fish 23 tracing lagrangian advectionparticles follow given background eulerian advective flow field 9 trajectories numerically integrated time given eq 21 implementedeulerforward rungekutta scheme 19xt t xtvx d dxbxt x representing individual particles position time t advectedt timesteps discretized vxt gridded fluid flownumerical simulation dxb optional position change particlebehaviour swimming sinking partial integral required matchtemporal resolutions underlying flow field particle simulationconsidering computational complexity particle advection schemedistinction theoretical practical computational workload theoretically operations majorly contribute compute loadr ttvelocity interpolation tvx d gridded eulerian flow field iiposition integration xt t fixed adaptive timestepping iiisum partial integration results fused multiplyadd fma operationsplain calculations particle trajectory lagrangian simulations mainpurpose tracking particle properties physical biochemical behavioural nature time functions executed parcels helpuserdefined kernels depending complexity particle model operations represent majority calculations practical setting handkernels casespecific hardly generalizable compute workloadconsidered papers experimentsc kehl e van sebille gibsonterms performance benchmarking runtime simulationsintegration iteration individually sum compute timeanalysed inputoutput io time splitmemoryio fileio plotting time special case device outputhappening exclusively files inmemoryrealistic practical lagrangian fluid flow simulations compute timefar exceeded fileio oceanic flow fields need dynamically loadedlarge file databases practical perspective lagrangian fluid flowsimulations typically strictly iobound tasks parcels 9 implements multiple ioenhancing techniques deferred loading dynamic selective loadingexclusively occupied cells concerned improvingparticle integration large particle sets particle swarmsexperiments paper utilize synthetic preloaded perlinnoise flow fields 22remain resident memory simulation neglecting fileio timeflow fieldsindepth performance analysis required case large particle sets effects hardware caching memory layout particle set data organisationpotentially measurable impact overall runtime perspectivelagrangian fluid flow simulations particle particle set statically allocated remains fixed data entities simulationalternatively order circumvent limitedprecision floatingpoint errorscomply casespecific simulation requirements particles dynamically reemitted removed particle set cases potentially behave differentlyterms performance runtime data access alteration patternsdifferent collection data structures store particle setpotential performance difference static dynamic particle setsquantification rationale impact different oceanic flow simulation casesexploitation speed improvement main experimental subjectsarticle3 statusquo benchmarks investigation performance enhancinglagrangian particle simulations starts following research questionscostly functions functionalities existing particle simulationorder answer question needed determine costly functionssimulation framework ii quantify controls impact parameterscomputational runtime iii test different computational settingssimulation python cbased kernel evaluation impact taskparallelisation message passing mpi cost dynamic array operationsquantification parcels code1 version 215 profiled cprofile package outcome linebyline code timings analysedsnakevis7 plotting percentage runtime figure 1figure 1 shows total runtime blue bars 365day particle simulationsynthetic flow field generated perlin noise figure 2 advectedfixed temporal resolution 1 hour 13000 seconds removalscenario 265000seconds insertionscenario presented cases simulation targetsaverage number particles arraycollection 218 codelevel significant difference active garbage collector darkergreen bar consumes significant runtime 56 dynamic removal1 oceanparcelswebsite httpoceanparcelsorgspeeding pythonbased lagrangian particle simulationsdynamic particle insertionb dynamic particle removalfigure 1 plot percodeline runtime distributions different dynamic array operationsaverage particle number target cases 218 plots runs mpiparallelisation cevaluated kernelscase dynamicinsertion scenario furthermorefifth level scenarios spend large amounts time localisingerroneous 3046 removalscenario 2973 insertionscenario deleted3115 removalscenario 3128 insertionscenario particles removalscenario particles actually deleted spends approximately twicetime removal function insertion scenario 448 compared 211extra runtime expenses item removal garbage collection resulttime spent actual particle advection 2546 removal scenariocompared 3589 insertionscenario remaining percentagessmaller helper functions listcomprehensions memory management notesynthetic flow field particles advected held entirelyinmemory particle positions written external storageextensive fileio limit casesfollowing top5 expensive execution functions emerge extensivebenchmark analysis different scenarios described staticvsdynamicdatasets varying particle set sizes furthermore mostexpensivefunctions detrimental impact performance scales sizeparticle set overpronounced running large particle setsparallel reduce common fileio performance malus realworld oceansimulations1 list comprehension kernel execution gathers unadvected particlescomputational complexity2 delete function removing individual particles particle set computational complexity 23 arraycopy operation flips densearray arrangement memorycolumnmajor order fortranpythonnative orientation rowmajororder cc native orientation cinternal kernel evaluation computational complexity4 actual particle advection computation function ideallylist 34 runtime5 array transposeandcopy operation performs nddensearray concatenation periodicallyreleased particles computational comc kehl e van sebille gibsonfigure 2 probabilistic synthetic fluid flow field generated perlin noise 22 background displays absolute flow speeds range 0 10 mmetrescale flow fieldgreen particle traces depict particles trajectory flowplexity o2nclear target research reduce impact abovelisted superlinearly runtime scaling collection reordering alteration functions point advection function major runtime expendituresimulation traditionally intended transform simulation process computebound application subsequently spedcommon highperformance computing approaches simd processingparallelisation load distributionreason runtime malus abovelisted operations densearrays randomaccess data structures exhibit high computationalmemory complexity random alterations words adding removingentities arraycollection requires splitting collection multiple distinctsubsets exclude removed include inserted elements concatenatenewlyallocated result collection inplace operationsneed exploit alternative data structures exhibit sublinear scalingoperations4 highperformance collection data structures pythonbased numerical simulations paper propose supplement python dynamic collections doublelinked nodelists bisectsearch augmented arraysexplicit cbindings perform highspeed kernel executions c structures attempt remedy performance malus rooted slow randomalterationspeeding pythonbased lagrangian particle simulationsmethods arraycollectionscomparison baseline common arrayofstructure aos arraycollectiondata structure simple array housing complex multidimensional objectsfigure 3 supplement material details simplicity advantageousconversion data structure c suffers severe speed malusdynamic alterationsfigure 3 arrayofstructure aos collection memory layout collection data structureitemlinearized memory alignment linear item order annotated black major arroworder address trivial common request engineering optimisations speedy list comprehensions reduced memory copies forthcreated comparison case engineeringoptimised aos showcasepotential limitations simplistic trivial improvements41 listofarrays ofstructures loaos collection attemptprovide upper bound scaling complexity random array alterationssplit global array list fixedlength arrays refer datastructure listofarray loa collection text remainder highlightingunderlying array structure aossplitting setup subsequently requires address translation randomly accessing retrieving items collection slowing excessivelynumerous item lookups advantage complexity item insertiondeletion reduced k n n 1n 1 k numberadded removed items n total number items particlesk d m m 1 m 1 d 2 m2 d m mmaximum size subarrays loose bound n madditional accounts effort merging subarrays occupancy50 layout illustrated figure 442 structureofarrays soa collection soa representationtransposition memory layout aos single instancecontainer datatype toplevel elements particle structuresinstance particle structure array values fieldvelocity position particle denoted index reconstructedextracting element index constituent fieldsc kehl e van sebille gibsonfigure 4 listofarray loa collection memory layout nodelist container fixedsizepreallocated aosorganised subarrayslayout soa lends vectorized instruction flow commonmodern linearalgebra software frameworks blas lapack numpy 12accessed python loop particles turned loopnumpyaccelerated vectorized operations particle fields particularlyapparent case multiple particle initialization allocationindependent objects replaced instantiation arrays soacachefriendly justintime advection calculation fieldvalue multiple particles loaded single cache line figure 5optimizing compiler choose use vectorized cpu instructions operatemultiple particles sm1 supplementary materiallinearized inmemory layout soa tradeoff speed dynamic flexibility cache coherence high data locality vectorized processing prioritizedefficient deletion arbitrary particles accessing manipulating individualparticles unwieldy fields accessed separatelyfigure 5 structureofarray soa collection memory layout collection data structureattributelinearized memory alignment43 nodal doublelinked list collection proposed loacollection enforces upper bound computational complexity dynamic collection alterations soacollection inherently improved cache access advectionexecution underpinning tackling dynamic collection alteration issueorder reduce computational complexity actual dynamic collection alteration process needs addressedspeeding pythonbased lagrangian particle simulationsintroduce doublelinked list implementation parcels particleframework novel aspect straightforward implementation ctypesallows direct access data collection highspeed ckernelsfigure 6 nodebased doublelinked list collection memory layoutimplementation node objects complementary python classobjects crepresentation structure node stores referencepredecessor successor data container data container caseparticleobject reference python numpyobject pointer referencec numpyobject reference particle pointer numpymappedcstruct reference particle pointer numpy arrayruntime particles dynamically added removed standard complexity o linked lists particles bound node insertionremoval performed plain relinking predecessor successor references collection contrast pythons internal deque implementationlist commonly traversed beginenditerators foreachelementiterationspython c equivalently traditional drawback remaininglack fast randomaccess usually requires list traversal comparedo randomaccess arrays expected nodesbaseddoublelinked list outperforms alternative implementations scenarios abundant dynamic particle operationsabbreviation purposes remainder paper refers doublelinkedlist nodal list benchmark logs plots refer collection nodescontext paper implied nodes nodal list doublelinked5 results order assess compare quantify effectivenessindividual data collection designs run benchmarks setup section 3 contrast initial benchmark timings need resolvedindividual atomic operations costs considerable runtime memoryevaluation purposes parameters listed followsmeasured highest distinct code levelcompute time bare time required execute flow advection kernelsfield interpolationsio time combined time require fileio memory io operationsplotting time operation time required console image outputimage renderingtotal time time start simulation endc kehl e van sebille gibsonsimulation excluding preprocessing setup flowfields initialcollections startup phase result collection writeback cleanup postprocessing shutdown approximately equal cumulative computeio plotting time minor roundup deviations possiblefileio time component iotime measures filerelated operation times data transfer external storage memorydemonstrated benchmarks include memoryio gridded flow fieldsmeasure use synthetic flow fields special caseinterface commonly accesses files instead preloaded memory sectionsmemoryio second component iotime measures memory management operation times array variable copies memory mappingc python storagekerneltimes average compute io total processing timeiterations simulationperparticle time average compute io total processing timeindividual particle simulation iterationmemory consumption memory acquired simulationprocess instruction data stack segment size sharedmemory page blocksfurthermore enable appropriate comparisons static dynamic scenariossetup cover simulation approximately average number particlesworkload simulation time avoidingirrelevant setups simulations 4 particles singleparticle additions removals iteration order achieve dynamic scenarios startitems insert 128 items periodicity tp tsim 12874n targetremoving itemsq defining randomized uniformlydistributed life expectancyb 2 23 tsim t 0px baorder cover wide range scenarios benchmark experimentn 2x particles x 101651 static datasets static setup fixed particle numbercollections shows runtime behaviour figure 7total timeb average runtime particlec memory consumptionfigure 7 runtime behaviour different collection data structures static simulation setupadapted collection types consistently improve runtime compared aos case observe diverging runtime behavioursloa engineering case linear time increase negativelyoffset aos curve unsurprising collection structuresspeeding pythonbased lagrangian particle simulationsconceptually structurally similar aos starting case soa structureshows strong logarithmic time behaviour doublelinked list showsweak logarithmic behaviour behaviours agree approximationscomputational complexity data access subsection 43overall consistently fastest collection implementation nodal liststatement supported overall runtime figure 7aaverage runtime individual particle figure 7c plot showslimited constant offset time setting managing data structureperparticle runtime small datasets significantly lowerstructures beneficial runtime behaviour comes significantlyincreased memory demand item record node particle datapackage needs store predecessor successor referencecompute vs io ratiob speedup relative aosfigure 8 derivative performance metrics different collection data structures staticsimulation setupfigure 8b speedups minor data structure modificationscompared aos loa engineered improvements limitedpoint exceeding 2x speedup different collection structures soanodal lists yield higher speedups figure 8b shows soas startsspeedup small collections consistently increasing speedup largercollections contrast speedup nodal lists highest smaller collectionsdepreciates intermediatesized collections increasinglarge datasets runtime speedup reliable stablenodal lists soa collectionsfurthermore figure 8a shows collections time spentmemory management tasks larger dataset meaning simulation process increasingly iobound specifically memoryio boundsingle exception behaviour soa data structure inherently requiresminimal memory management static dataset sizes concerned leadingincreasing computetoio ratio52 fullydynamic datasets dynamic case combining dynamic collection operations insertion removal performance figures significantly change seen figure 9separate analysis regimes small collections lowparticle count n 25 000 large collections n 25 000 smallcollections speed regimes arraylike structures aos engineering improvements loa soa doublelinked list arraylike structuresexperience hyperbolic rise runtime small collections computationalc kehl e van sebille gibsontotal timeb average runtime particlec memory consumptionfigure 9 runtime behaviour different collection data structures fully dynamic collectionoperations simulationeffort outweighs additional memoryio workload figure 10afurthermore fixed memory allocation requires setup time dynamics nodal lists clearly outperforms collectionssecond regime large collections divergence datastructures categories category row major orderaligned arraylike collections aos loa category b column major orderaligned arraylikecollections engineering improvements soa category c nodal listlarge collections cat collections scale linearly steep slope relativen disadvantageous memory layout complicates memory operations numpy cat b collections exhibit logarithmic runtime scalelarge collections despite fixed memory arrangements numpyinternally concatenates column major order arrays faster row major orderarrays arraylike data structures terms runtime insertions removals result large number array concatenation operations expecteddoublelinked list favourably deals dynamic collection operationscomparing results figure 12 subsection 52 doublelinked listscollections structures exhibit approximately equal runtimes casesregime split performance argumentation supportedcomputetoio ratio figure 10a observation speedupfigure 10bcompute vs io ratiob speedup relative aosfigure 10 derivative performance metrics different collection data structures fullydynamic collection operations simulationspeeding pythonbased lagrangian particle simulationscomparison previous experiments soa structure particularlyimpeded performance random operations consistently slowerengineering improvements furthermore specific advantages disadvantagesbalance performance aos loa soa intermediate dataset sizeslarge collections perparticle runtime approximately equal nodal listsengineering improvements soa collectionsfinal point note interesting observation extrapolating results massive dataset sizes n 100 000 observationsmemory consumption fully dynamic operations subsequent concatenation operations leave temporary data blocks traces memory leadingexponential memory demand row major orderaligned arraylike collections catcollections fixedsize buckets loa prevent excess memory consumption soa nodal lists memory requirements remain linearmeasurementscombining insights runtime perparticle runtime memory behaviour viable collection data structures massive dynamicallyalteringdatasets huge particle swarms fluid simulation doublelinked nodallists soa doublelinked list yields highest performance terms speedrequires times memory soa supplemental node information memory capacity major limiting factor soa data structuredelivers maximum speed memory demands6 discussion runtime memory consumption results demonstrate diverse performance impacts choice specific collection datastructure largescale simulations traditionally choice collectiondata structure depended exclusivelydataset sizeavailable computerelated technologies simd parallelization assembly compilersavailable memorybenchmark analysis demonstrates choice ideal collection datastructure depends scenario operations actually performed datasetorder judge potential future improvements analyse computetoioratio static dynamic case appear different trendslarge data similar new collection types increased computational loadn 25 000 items larger collections experience dropoff ratiolarge collections n 50 000 items soa collection experiencesincrease compute load conclusion collections bad data localityiobound processing behaviour cacheoptimised soa collectioncomputebound processing behaviour data locality issue explainslarge dropoff computetoio ratio nodal lists items collectionsparsely distributed memory contrast arraylike collectionimpacts ideal use collections nodal list perform dynamiccollection operations simple compute kernels simple advectionexperiments soa collection expected conversely outperformcollections static dynamic experiments complex computational kernelsincreasing field interpolations furthermore high degreedata locality beneficial sharedmemory parallelization future shallcombine doublelinked list collection improved data locality schemec kehl e van sebille gibsonfindings directly impact studies ocean physics splitfollowing casestudy categories1 mass momentumconserving particle studies lagrangian particlesreleased traced stretched time periods set particles staysfixed static2 endofstate particle studies particles released state tracedmultiple iterations removed reaching given endstate simulation ends removal particle releasesparticles anew particle converges end state simulationincludes dynamic data removal fully dynamic specialcase endofstate simulation particle aging particlesdeleted defined maximum lifetime3 density flux approximations particles continuously releasedposition attribute modalities traced regular intervalsregulargridded map attributes created averaging particleattributes particles covered gridcell stencil bufferlikeoperation order facilitate high particle density particles constantly created inserted collection order prevent accuracyerrors accumulation longtraced particles regularly removeddataset traditional case large dynamics collection datastructure contains particlesaccording findings simulation cases shall employ optimal collection structure qualitatively data structures enable developing newdynamic operations driven particle behaviour splitmerge particles particleinherent dynamics capabilitiesgeophysical lagrangian oceanicflow simulations require versatile definition particle behaviour ii efficient memoryconserving fastdata structure facilitates random insertions removals specific example applications individual modelling fractured particulate matter oceansaggregation smaller particulates larger clustersperformance results different data structures extend computational cases outside physics simulations general data analysis requires iterativeattribute derivation subsequent costfunction computation information condensation removing merging attributes large datasets dataoperations map different experiments static datasets dynamic data insertion dynamic data removal fully dynamic operations section 5geophysical data science applications frameworks benefit improveddata organisation particularly important computation speed crucialemergency response systems forecast systems connectedrealtime sensor networksconceptual development approach acknowledge performance optimisation especially performance measurement hardly possiblepython challenge measurement improvement pythons nativecore typeless codes class hierarchy interpreter introspection supportslow measure runtimes memory consumption certain resolutionempirically tm 20ms temporary resource allocations happennumpy scipy measured python measurementfunction calls slow observed numbers 13nearlyflat memory consumption graph soa furthermore acknowledgemanual provision justintime ccompiler interfaces ctypes consumesspeeding pythonbased lagrangian particle simulationsresources runtime memory hidden reduced removedcbinding implementations numbaorder check results apply outlined structures modellingand simulation problems program codes individual structures availablegithubaos httpsgithubcomoceanparcelsparcelstreebenchmarkingengineering optimizations httpsgithubcomoceanparcelsparcelstreeengineering optim trialsloa httpsgithubcomoceanparcelsparcelstreelist pset array trialsdoublelinked list httpsgithubcomoceanparcelsparcelstreesorted psettrialssoa httpsgithubcomoceanparcelsparcelstreesoa benchmark7 conclusion paper aimed quantifying detrimental performanceimpact static arraylike collection data structures dynamic collectionoperations item insertion removal geophysics especially oceanicapplications following expected negative impact detrimental data localitynew highperformance collection data structures python designeddeveloped interfaces easily ckernels actual physicscalculations performance gain optimised data structures vanishcalculations require slow native python processing processspecifically analysed large datasets cases n 215 data structureperformance limits increasingly impacting overall simulation runtimedemonstrated quantified negative performance impactstatusquo experiments section 3 listing runtimecostly code operationsincreasingly limit performance growing datasets qualitatively callsinsertion concatenate deletion remove functions relatedarray reordering functions prime performance barriersconsequently paper introduces new collection data structures circumventperformance bottlenecks collections arraylike structuressoa loa doublelinked list structure experiments showednewly proposed data structures yield significant runtime improvementspaper shows major experiment cases static dataset fullydynamic dataset insertion removal b cases doublelinked listfastestcomputing data structure soa efficient concerningruntime improvement memory consumption combinationresults insights gained specific lagrangian oceanic fluidflow simulation generalisable problems geophysics generaldata science demonstrated section 6 developed data structuresgained insight performance facilitate new application scenarios modelling casesphysical oceanography demonstrates impact researchappendix removalonly insertiononly experimentsseparate experiments conducted removalonly figure 11 insertiononlyfigure 12 casesremovalonly experiment responds similar static case exceptions firstly loa collections partially slower aos collectionattributed mergeoperation nodes sublists length n nlimsecondly nodal list provide expected speedup compared arraylike collections especially soa ctypes jitinterfacesimulations node removal relinking requires additional operationsc kehl e van sebille gibsontotal timeb memoryconsumptionc compute vs ioratiod speedup relativeaosfigure 11 runtime behaviour different collection data structures dynamic removalelements simulationtraditional replacement previous pointertotal timeb memoryconsumptionc compute vs ioratiod speedup relativeaosfigure 12 runtime behaviour different collection data structures dynamic insertionelements simulationinsertiononly case similar fullydynamic case showing particleinsertion represents major runtime expense distinct fastinsertion complexitynodal lists visible improved runtime soa performance comparablenodal list particles unordered particle insertionperformed simple array concatenationacknowledgments work tracking plastic seastopios project supported funding european research council erc european unions horizon 2020 research innovation programme grant agreement 715386 simulations carried dutchnational einfrastructure support surf cooperative project 163712019034references1 m abadi p barham j chen z chen davis j dean m devin s ghemawatg irving m isard et al tensorflow largescale machine learning12th usenix symposium operating systems design implementation osdi16 2016 pp 2652832 e anderson z bai c bischof j demmel j dongarra j du croz greenbaum linear algebra package 19993 j bergstra o breuleux f bastien p lamblin r pascanu g desjardinsj turian d wardefarley y bengio theano cpu gpu math expression compiler proceedings python scientific computing conference scipyvol 4 austin tx 2010 pp 17speeding pythonbased lagrangian particle simulations4 l s blackford petitet r pozo k remington r c whaley j demmel j dongarra duff s hammarling g henry et al updated set basic linear algebrasubprograms blas acm transactions mathematical software 28 2002 pp 1351515 p cetinaheredia e van sebille r j matear m roughan nitratesources supply phytoplankton growth great australian bighteulerianlagrangian modeling approach journal geophysical research oceans 1232018 pp 759772 httpsdoiorghttpsdoiorg1010022017jc013542 httpsagupubsonlinelibrarywileycomdoiabs1010022017jc013542 httpsarxivorgabshttpsagupubsonlinelibrarywileycomdoipdf1010022017jc0135426 f chollet et al keras python deep learning library ascl 2018 pp ascl18067 m davis e bray n schlmer y xiong et al snakeviz 2014 httpsjiffyclubgithubiosnakeviz8 m la varga schaaf f wellmann gempy 10 opensource stochastic geologicalmodeling inversion geoscientific model development 12 2019 pp 132 httpsdoiorg105194gmd1212019 httpsgmdcopernicusorgarticles12120199 p delandmeter e van sebille parcels v20 lagrangian framework new field interpolation schemes geoscientific model development 12 2019 pp 35713584 httpsdoiorg105194gmd1235712019 httpsgmdcopernicusorgarticles123571201910 d hfner r l jacobsen c eden m r b kristensen m jochum r nuterman b vinter veros v01 fast versatile ocean simulator pure python geoscientific model development 11 2018 pp 32993312 httpsdoiorg105194gmd1132992018 httpsgmdcopernicusorgarticles113299201811 c r harris k j millman s j van der walt r gommers p virtanend cournapeau e wieser j taylor s berg n j smith r kern m picuss hoyer m h van kerkwijk m brett haldane j fernndez del rom wiebe p peterson p grardmarchant k sheppard t reddy w weckesser h abbasi c gohlke t e oliphant array programming numpynature 585 2020 p 357362 httpsdoiorg101038s415860202649212 c intel intel 64 ia32 architectures optimization reference manual intel corporationsept 2014 pp 212 215 sec 45 improving memory utilization13 c kehl performance measurement data speeding lagrangian fluidflowparticle simulations python dynamic collections data repository 1 utrechtuniversity 2021 httpsdoiorg1024416uu01cv3oeh httpsdoiorg1024416uu01cv3oeh14 m lange e van sebille parcels v09 prototyping lagrangian ocean analysis framework petascale age geoscientific model development 10 2017pp 41754186 httpsdoiorg105194gmd1041752017 httpsgmdcopernicusorgarticles104175201715 lm lebreton s greer j borrero numerical modelling floating debrisworlds oceans marine pollution bulletin 64 2012 pp 653 661 httpsdoiorghttpsdoiorg101016jmarpolbul201110027 httpwwwsciencedirectcomsciencearticlepiis0025326x1100567416 p lemenkova processing oceanographic data python libraries numpy scipy pandas aquatic research 2 2019 pp 7391 httpsdoiorg103153ar19009 httpshalarchivesouvertesfrhal0209349117 r mller j cannon x qin r watson m gurnis s williams gplates buildingvirtual earth deep time geochemistry geophysics geosystems 19 2018 httpsdoiorg1010292018gc00758418 p d nooteboom p k bijl e van sebille s von der heydt h dijkstratransport bias ocean currents sedimentary microplankton assemblages implications paleoceanographic reconstructions paleoceanography paleoclimatology 342019 pp 11781194 httpsdoiorghttpsdoiorg1010292019pa003606 httpsagupubsonlinelibrarywileycomdoiabs1010292019pa003606 httpsarxivorgabshttpsagupubsonlinelibrarywileycomdoipdf1010292019pa00360619 t nordam r duran numerical integrators lagrangian oceanographygeoscientific model development 13 2020 pp 59355957 httpsdoiorg105194gmd1359352020 httpsgmdcopernicusorgarticles135935202020 t e oliphant python scientific computing computing science engineering 92007 pp 102021 f pedregosa g varoquaux gramfort v michel b thirion o griselm blondel p prettenhofer r weiss v dubourg et al scikitlearn machinelearning python journal machine learning research 12 2011 pp 28252830c kehl e van sebille gibson22 k perlin image synthesizer siggraph comput graph 19 1985 p 287296 httpsdoiorg101145325165325247 httpsdoiorg10114532516532524723 j scutt phillips sen gupta senina e van sebille m lange p lehodeyj hampton s nicol individualbased model skipjack tuna katsuwonuspelamis movement tropical pacific ocean progress oceanography 164 2018pp 63 74 httpsdoiorghttpsdoiorg101016jpocean201804007 httpwwwsciencedirectcomsciencearticlepiis007966111730289624 r sedgewick algorithms c parts 14 fundamentals data structure sortingsearching algorithms c pearson education 1998 httpsbooksgooglenlbooksidzcchaeprwvyc25 s van der walt s c colbert g varoquaux numpy array structureefficient numerical computation computing science engineering 13 2011 pp 223026 s van der walt j l schnberger j nuneziglesias f boulogne j d warnern yager e gouillart t yu scikitimage image processing python peerj 22014 p e45327 p virtanen r gommers t e oliphant m haberland t reddy d cournapeaue burovski p peterson w weckesser j bright et al scipy 10 fundamentalalgorithms scientific computing python nature methods 17 2020 pp 261272supplementary materials speeding pythonbasedlagrangian fluidflow particle simulationsdynamic collection data structuresarxiv210500057v1 physicscompph 30 apr 2021christian kehl erik van sebille angus gibsonsm1 memory access patterns contiguous arrays n xm arraysarrays aligned patterns usual simple matter 1 majoraxis represents structure attributes aligned contiguously memoryminor axis represents multiple array items alternatively 2 major axisrepresent array items contiguously aligned memory attributesfollow minor axis formally n x0 x1 xn mxai representing item structure attributes arraysstructured n xm 1 2 m xn performance implicationsfunctional evaluation array differing traditional sequentialmodern vectorized evaluation shown figure sm1 n xm arrays namedarray structures aos figure sm2 m xn arrays named structurearrays soacomparing memory access patterns terms performancetraditional sequential processing soa pattern faster requires 1cache update iteration requires 4 updates soa patternmodern computing architectures iteration actually executes 2multithreaded cpus 32 gpu warps iterations simultaneously viewperiteration peritem computations invalid simultaneous computation referred vectorization cpus simultaneous multiprocessingsmp general processors comparing numbers 2item evaluationaos requires 2 cache updates soa requires 8 cache updates assumingsequential processing vectorized processing evaluating 2 items requires14 updates aos 4 updates soa furthermore number cachechanges approximately m pnu p u number processing unitsscaling favourably number processing units threads software naturally makes soa superior performance modern processorsm n conversely n m switch array axes lastlypractice layout change easily achieved changing fortrancontiguous ccontiguous order python arrays vice versa equallyachieved matrix transposition obviously establishing correct item orderallocation keeping order static vital periteration matrix transpositionconsumes vastly processing cycles saved soa evaluationsubmittedsiam journal scientific computing editors 20210125funding work funded european research council erc topios project grant 715386 simulations carried surfs dutch national einfrastructureproject 16371 2019034institute marine atmospheric research utrecht university netherlandsckehluunl evansebilleuunlaustralian national university angusgibsonanueduausm1sm2c kehl e van sebille gibsonfigure sm1 memory access patterns related simple particle advection functionn xm array structures sequential vectorized evaluation listed assembly mnemonicssupplementary materials speeding pythonbased lagrangian particle simulationssm3figure sm2 memory access patterns related simple particle advection functionm xn structure arrays sequential vectorized evaluation listed assembly mnemonics