Isolation Without Taxation:
Near Zero Cost Transitions for SFI
Matthew Kolosick∗ Shravan Narayan∗ Conrad Watt†
Michael LeMay‡ Deepak Garg§ Ranjit Jhala∗ Deian Stefan∗

arXiv:2105.00033v1 [cs.CR] 30 Apr 2021

∗

UC San Diego

†

University of Cambridge

‡

Intel Labs

§

Max Planck Institute for Software Systems

and thus require frequent domain crossings. Similarly, SFI
allows Fastly to service thousands of tenants per second (per
core), each of which calls into the runtime multiple times when
handling a request - all within fractions of a millisecond [19].
While there have been significant strides on SFI enforcement
(e.g., on x86 [2], [9], [14], [20], x86-64 [21], SPARC® [22], and
ARM® [21], [23], [24]), context switching in SFI systems remains largely unexplored. Since Wahbe et al.'s original work [1],
almost all SFI systems have used heavyweight transitions for
context switching. These transitions switch domains by tying
into the underlying SFI enforcement mechanism. For example,
when transitioning into a sandbox they might set segment
registers [9] or memory protection keys [25], [26] to ensure
the sandbox code is memory isolated. They also save, scrub,
and restore machine state (e.g., the stack pointer, program
counter, and callee-save registers) to ensure confidentiality
and integrity. This code is not only hard to get right (e.g., it
must account for different architectures, platforms, and their
quirks [27]) but also has significant overheads (§VI).
I. I NTRODUCTION
In this paper we revisit context switching in SFI systems and
Software-based fault isolation (SFI) is a lightweight alterna- realize the 90's vision of reducing the cost a context switch to
tive to process-based isolation, which isolates untrusted code (roughly) that of a function call. Through five contributions we
with runtime checks that restrict (sandbox) the code to a specific show how to design SFI systems with near zero-cost transitions:
region of the address space [1], [2]. Though SFI runtime
checks typically slow down the code running in the sandbox, 1. Formal model of secure transitions (§III). Simply rein application domains where sandboxed "components are moving heavyweight transitions for many SFI systems is
tightly coupled and require frequent domain crossings," the unsafe; without transitions an attacker can easily escape the
low overhead of SFI transitions more than makes up for the SFI sandbox. Thus, our first contribution is the first formal,
added cost [3]. For example, SFI has been used to isolate code declarative, and high-level model that elucidates the role of
in OS kernels [4]–[7], browsers [8]–[10], runtime systems [11]– transitions in making SFI secure (§II). Intuitively, secure
transitions protect the integrity and confidentiality of machine
[13], and storage systems [1], [14], [15].
More recently, Mozilla started using WebAssembly (Wasm) state across the domain transition and provide well-bracketed
based SFI to sandbox third-party C libraries in Firefox [16], control flow, i.e., that returns actually return to their call sites.

Abstract-Almost all SFI systems use heavyweight transitions
that incur significant performance overhead from saving and
restoring registers when context switching between application
and sandbox code. We identify a set of zero-cost conditions that
characterize when sandboxed code is well-structured enough
so that security can be guaranteed via lightweight zero-cost
transitions. We show that using WebAssembly (Wasm) as an
intermediate representation for low-level code naturally results
in a SFI system with zero-cost transitions, and modify the Lucet
Wasm compiler and its runtime to use zero-cost transitions. Our
modifications speed up image and font rendering in Firefox by
up to 29.7% and 10% respectively. We also describe a new
purpose-built fast SFI system, SegmentZero32, that uses x86
segmentation and LLVM with mostly off-the-shelf passes to
enforce our zero-cost conditions. While this enforcement incurs
some runtime cost within the sandboxed code, we find that, on
Firefox image and font rendering benchmarks, the time saved
per transition allows SegmentZero32 to outperform even an
idealized hardware isolation system where memory isolation
incurs zero performance overhead but the use of heavyweight
transitions is required.

[17], and companies like Fastly are using Wasm to isolate tenant 2. Zero-cost conditions for SFI (§IV). Heavyweight transicode on their edge clouds [18]. SFI allows Mozilla to isolate tions provide security by wrapping calls and returns to ensure
libraries like libgraphite (font shaping), libexpat that sandboxed code cannot, for example, read secret registers
(XML parsing), and hunspell (spell checking) that are or tamper with the stack pointer. These transitions are necessary
tightly coupled and process content in a streaming fashion - when the code running in the sandbox is arbitrary native
code. In practice, though, most SFI systems enforce some
This work was supported in part by gifts from Cisco; by the NSF under structure on sandboxed code. For example, NaCl uses controlGrant Number CNS-1514435, CCF-1918573, CAREER CNS-2048262; and,
by the CONIX Research Center, one of six centers in JUMP, a Semiconductor flow integrity (CFI) to restrict the sandbox's control flow to its
Research Corporation (SRC) program sponsored by DARPA. Conrad Watt was own code region, and requires dynamic checks on reads and
supported by the EPSRC grant REMS: Rigorous Engineering for Mainstream writes [3], [9], [10]. This structure simplifies SFI enforcement
Systems (EP/K008528/1), a Google PhD Fellowship in Programming Technology and Software Engineering, and a Research Fellowship from Peterhouse, and verification (that the enforcement is correct). Our insight
University of Cambridge.
is that imposing structure on sandboxed code also allows us

1

to replace heavyweight transitions with zero-cost transitions
which are close to bare function calls.
This insight is inspired by work on language-based isolation [28]–[33]. Language-based systems like Singularity [32]
use high-level, type- and memory-safe languages (e.g., Sing#)
to isolate code at the language level. The compositional
structure of such languages allow these systems to use
simple function calls as secure cross-domain transitions: the
language enforces well-bracketed control flow and local state
encapsulation, i.e., confidentiality and integrity of machine
state. We cannot realistically rewrite huge systems like Firefox
(or even the third-party libraries in Firefox) in a high-level
language [3], so we instead capture the essence of what makes
it possible for language-based systems to safely use zero cost
transitions and adapt this to the SFI setting.
Our second contribution precisely defines the zero-cost
conditions that sandbox code must satisfy to safely use zerocost transitions: Sandboxed code must follow a type-directed
CFI discipline, have well-bracketed control flow, enforce local
state (stack and register) encapsulation, and ensure registers
and stack slots are initialized before use. These conditions are
only slightly more onerous than the structure some SFI systems
already require of sandboxed code (e.g., compared to NaCl, we
rely on type-based CFI instead of coarse-grained CFI and use
a safe stack instead of a separate stack). We state the zero-cost
conditions in terms of a dynamic overlay semantics which we
can instantiate to model different SFI systems.
3. Instantiating the zero-cost model (§V). Our third contribution is an instantiation of our zero-cost model to two SFI
systems: Wasm and SegmentZero32.
Wasm is a low-level bytecode with a sound, static type
system designed to be targeted by compilers for languages such
as C [10]. We study Wasm as an intermediate representation
(IR) for SFI [16], [34]–[36], i.e., compiling untrusted C/C++
libraries to native binaries using Wasm as an IR, that are
then linked against an application like Firefox (which is not
compiled through Wasm). We show that Wasm satisfies our
zero-cost conditions - and replace the heavyweight transitions
used by existing Wasm SFI compilers with zero-cost transitions.
We design the SegmentZero32 SFI system to (1) use
32-bit x86 segmentation hardware to enforce (heap) memory
isolation and (2) restrict the structure of code according to
our zero-cost conditions. Unlike previous SFI systems that use
segmentation [2], [9], [14], we use a set of mostly off-the-shelf
LLVM compilation passes and one custom compilation pass
(Section V-B) to enforce our zero-cost conditions, including
type-based CFI, and ensure that SegmentZero32 can safely
use zero-cost transitions. While the prevalence of 32-bit x86
systems is declining, it nevertheless still constitutes over 20%
of the Firefox web browser's user base (around 45 million
users)1 ; SegmentZero32 would allow for high performance
library sandboxing on these machines.
4. Proofs of security. Our fourth contribution is a set of proofs
of security. We prove that NaCl's heavyweight transitions
1 See

are secure (§B) and that, when the zero-cost conditions are
met, zero-cost transitions are secure (§C). We also prove that
Wasm meets the zero-cost conditions and can therefore safely
elide heavyweight transitions while maintaining integrity and
confidentiality (§D).
5. Implementation and evaluation (§VI). Our last contribution is an implementation and evaluation of Wasm and
SegmentZero32 with zero-cost transitions. We integrate the
two SFI systems into the RLBox sandboxing framework [16],
and evaluate the performance of zero-cost transitions on
several microbenchmarks and two macrobenchmarks - image
decoding and font rendering in Firefox, which are currently
sandboxed using Wasm-based SFI. We find that zero-cost
transitions speed up Wasm-sandboxed image decoding by (up
to) 29.7% and font rendering by 10%. SegmentZero32
imposes an overhead of (at most) 24% on image decoding and
22.5% on font rendering relative to unsandboxed native code.
These overheads are significantly lower than even an idealized
hardware isolation system where memory isolation adds zero
overhead but the use of heavyweight transitions is required.
Open source and data. Our code and data will be made
available under an open source license.
II. OVERVIEW
In this section we describe the role of transitions in
making SFI secure, give an overview of existing heavyweight
transitions, and introduce our zero-cost model which makes
it possible for SFI systems to replace heavyweight transitions
with simple function calls.
A. The need for secure transitions
Consider sandboxing an untrusted font rendering library
(e.g., libgraphite) as used in a browser like Firefox:
1
2
3
4
5
6
7
8

void onPageLoad(int* text) {
...
int* screen = ...; // stored in r12
int* temp_buf = ...;
gr_get_pixel_buffer(text, temp_buf);
memcpy(screen, temp_buf, 100);
...
}

This code calls the libgraphite gr_get_pixel_buffer
function to render text into a temporary buffer and then copies
the temporary buffer to the variable screen to be rendered.
Using SFI to sandbox this library ensures that the browser's
memory is isolated from libgraphite - memory isolation
ensures that gr_get_pixel_buffer cannot access the memory of onPageLoad or any other parts of the browser stack and
heap. Unfortunately, memory isolation alone is not enough: if
transitions are simply function calls (e.g., as in [25]), attackers
can violate the calling convention at the application-library
boundary (e.g., the gr_get_pixel_buffer call and its return)
to break isolation. Below, we describe the different ways a
compromised libgraphite can do this.
Clobbering callee-save registers. Suppose the screen variable in the above onPageLoad snippet is compiled down to

https://data.firefox.com/dashboard/hardware, last visited March 2021

2

The cost of wrappers. Heavyweight springboards and trampolines guarantee secure transitions but have two significant
drawbacks. First, they impose an overhead on SFI - calls into
the sandboxed library become significantly more expensive
than simple application function calls (§VI). Heavyweight
transitions conservatively save and clear more state than
might be necessary, essentially reimplementing aspects of
an OS process switch and duplicating work done by wellbehaved libraries. Second, springboards and trampolines must
be customized to different platforms, i.e., different processors
and calling conventions. Implementation mistakes can - and
have [40]–[45] - resulted in sandbox escape attacks.

the register r12. In the System V calling convention r12 is
a callee-saved register [37], so if gr_get_pixel_buffer
clobbers r12, then it is also supposed to restore it to its original value before returning to onPageLoad. A compromised
libgraphite doesn't have to do this; instead, the attacker
can poison the register:
1
2

mov r12, h
ret

Since r12 (screen) is the used by Firefox on Line 6 to
memcpy the temp_buf from the sandbox memory, this gives
the attacker a write gadget that they can use to hijack Firefox's
control flow. To prevent such attacks, we need callee-save
register integrity, i.e., we must ensure that sandboxed code
restores callee-save registers upon returning to the application.

C. Zero-cost transitions

Heavyweight transitions are conservative because they make
few
assumptions about the structure (or possible behavior) of
Leaking scratch registers. Dually, scratch registers can
the
code
running in the sandbox. SFI systems like NaCl and
potentially leak sensitive information into the sandbox. Suppose
Wasm
do,
however, impose structure on sandboxed code to
that Firefox keeps a secret (e.g., an encryption key) in a scratch
enforce
memory
isolation. In this section we show that by
register. Memory isolation alone would not prevent an attackerimposing
structure
on sandboxed code we can make transitions
controlled libgraphite from using uninitialized registers
less
conservative.
Specifically, we describe a set of zeroand, thus, reading this secret. To prevent such leaks, we need
cost
conditions
that
impose just enough internal structure on
scratch register confidentiality.
sandboxed code to ensure that it will behave like a highReading and corrupting stack frames. Finally, if the applilevel, compositional language while maintaining SFI's high
cation and sandboxed library share a stack (e.g., as in [25]),
performance. SFI systems that meet these conditions can
the attacker can read and corrupt data (and pointers) stored
safely elide almost all the extra work done by heavyweight
on the stack. To prevent such attacks, we need stack frame
springboards and trampolines, thus moving toward the ideal
encapsulation, i.e., we need to ensure that sandboxed code
of SFI transitions as simple, fast, and portable function calls.
cannot access application stack frames.
Zero-cost conditions. We assume that the sandboxed library
code is split into functions and that each function has an
B. Heavyweight transitions
expected number of arguments of known types. We formalize
SFI toolchains - from NaCl [9] to Wasm native compilers
the internal structure required of library code via a safety
like Lucet [38] and WAMR [39] - use heavyweight transitions
monitor that checks the zero-cost conditions, i.e., the local
to wrap calls and returns and prevent the aforementioned attacks.
requirements necessary to ensure that calls-into and returnsHeavyweight transitions are secure transitions. They provide:
from the untrusted library functions are "well-behaved" and,
1. Callee-save register integrity. The springboard - the hence, that they satisfy the secure transition requirements.
transition code which wraps calls - saves callee-save registers 1. Type-directed forward-edge CFI. First, our monitor reto a separate stack stored in the protected application memory. quires that the library code enforces type-directed forwardWhen returning from the library to the application, the edge CFI. That is, for every call instruction encountered during
trampoline - the code which wraps returns - restores the execution, the jump target address is the start of one of the
registers.
library functions and the number and types of arguments
2. Scratch register confidentiality. Since any scratch register
may contain secrets, the springboard clears all scratch registers
before transitioning into the sandbox.

expected by that function match what are actually passed.
This provides two main properties that are critical for security.
First, it ensures that each function starts from a (statically)
3. Stack frame encapsulation. Most (but not all) SFI systems known stack shape, preventing a class of attack where a benign
provision separate stacks for trusted and sandboxed code and function can be tricked into overwriting other stack frames
ensure that the trusted stack is not accessible from the sandbox. or hijacking control flow because it is passed too few (or too
The springboard and trampoline account for this in three ways. many) arguments. Second, it provides the structure needed
First, they track the separate stack pointers at each transition to define a property capturing proper restoring of callee-save
in order to switch stacks. Second, the springboard copies registers (discussed in point three below).
arguments passed on the stack to the sandbox stack, since 2. Well-bracketed control-flow. Second, our monitor requires
the sandboxed code cannot access arguments stored on the that the library code adheres to well-bracketed return edges.
application stack. Finally, the trampoline tracks the actual return Abstractly, calls and returns should be well-bracketed: when
address to return on transition by keeping it in the protected f calls g and then g calls h, h ought to return to g and then
memory so that the sandboxed library cannot tamper with it. g ought to return to f. However, untrusted functions may

3

subvert the control stack to implement arbitrary control flow
between functions. Unrestricted control flow is at odds with
compositional reasoning. It also makes it difficult to define
correct restoration of callee-save registers since it is unclear
what "returning" from a function call means. Accordingly, we
require two properties of the library to ensure that calls and
returns are well-bracketed. First, each jump must stay within
the same function. This limits inter-function control flow to
function calls and returns. Second, the (specification) monitor
maintains a "logical" call stack which is used to ensure that
returns go only to the preceding caller.
3. Callee-save registers restoration. Building on wellbracketed control flow and, in particular, the resulting definition
of the beginning and end of a function call, we define functionlevel adherence to callee-save register conventions: our monitor
tracks callee-save state and checks that it has been correctly
restored at every return. Importantly, satisfying the monitor
means that application calls to a well-behaved library function
do not require a transition which separately saves and restores
callee-save registers, since the function is known to obey the
standard calling convention.
4. Local state encapsulation. Our monitor establishes local
state encapsulation by checking that all stack reads and writes
are within the current stack frame. This check allows us to
locally, i.e., by checking each function in isolation, ensure that a
library function correctly saves and restores callee-save registers
upon entry and exit. To see why local state encapsulation is
needed, consider the following idealized assembly function
library_func:
1
2
3
4
5
6
7
8

Priv
Val
Reg
Region
Immediate
Command

3
3
3
3
3
3

n
p
v
r
k
i
c

∈
::=
::=
::=
∈
::=
::=

Code
RegVals
Memory
State

3
3
3
3

C
R
M
Ψ

::=
::=
::=
::=

N
app | lib
hn, pi
rn | sp | pc
N*N
r |v |i⊕i
r ← popp | pushp i | jmpk i |
r ← loadk i | storek i := i |
gatecalln i | gateret
r ← mov i | callk i | retk
gatecalln i | storelabelp i
N * Priv × Command
Reg → Val
N → Val
error |
{pc : N, sp : N, R : RegVals,
M : Memory, C : Code}

Figure 1: Syntax

system is strict enough to ensure that a Wasm compiler
generates native code that meets these conditions. Finally, in
Section V-B we demonstrate how the zero-cost conditions can
be used to design a new SFI scheme by combining hardwarebacked memory isolation with existing LLVM compiler passes.
III. A G ATED A SSEMBLY L ANGUAGE
We formalize zero-cost transitions via an assembly language,
SFIasm, that captures key notions of an application interacting
with a sandboxed library, focusing on capturing properties of
the transitions between the application and sandboxed library.

library_func:
library_helper:
push r12
store sp - 1 := h
mov r12 ← 1
ret
load r1 ← sp - 1
add r1 ← r12
call library_helper
pop r12
ret

Code. Figure 1 summarizes the syntax of SFIasm: a R ISCstyle language with natural numbers (N) as the sole data type.
Code (C) and memory (M ) are separated, and, to capture the
separation of application code from sandboxed library code, C
is an (immutable) partial map from N to pairs of a privilege
(p) (app or lib) and a command (c), where app and lib are
our security domains.

If library_helper is called it will overwrite the stack slot
where library_func saved r12, and library_func will
then "restore" r12 to the attacker's desired value. Our monitor States. Memory is a (total) map from N to values (v). We
prohibits such cross-function tampering, thus ensuring that all assume that the memory is subdivided into disjoint regions
subsequent reasoning about callee-save integrity can be carried (Mp ) so that the application and library have separate memory.
Each of these regions is further divided into a disjoint heap
out locally in each function.
5. Confidentiality. Finally, our monitor uses dynamic informa- Hp and stack Sp . We write Ψ to denote the states or machine
tion flow control (IFC) tracking to define the confidentiality of configurations, which comprise code, memory, and a fixed,
scratch registers. The monitor tracks how (secret application) finite set of registers mapping register names (rn ) to values,
values stored in scratch registers flow through the sandboxed with a distinguished stack pointer (sp) and program counter
code, and checks that the library code does not leak this (pc) register. We write ΨLcMp for Ψ.C(Ψ.pc) = (p, c), that is
information. Concretely, our implementations enforce this by that the current instruction is c in security domain p. We write
ensuring that, within each function's localized control flow, all Ψ0 ∈ Program to mean that Ψ0 is a valid initial program
state. The definition of validity varies between different SFI
register and local stack variables are initialized before use.
We prove that these five zero-cost conditions characterize techniques (e.g.,, heavyweight transitions make assumptions
libraries that can be securely isolated with zero-cost transitions, about the initial state of the separate stack).
using the combination of memory isolation and function calls Gated calls and returns. We capture the transitions between
without the overhead of springboards and trampolines (see the application and the library by defining a pair of instructions
Theorem 1). In Section V-A we show that the Wasm type gatecalln i and gateret, that serve as the only way to switch

4

between the two security domains. The first, gatecalln i,
represents a call from the application into the sandbox or
a callback from the sandbox to the application with the n
annotation representing the number of arguments to be passed.
The second, gateret, represents the corresponding return from
sandbox to application or vice-versa. We leave the reduction
rule for both implementation specific in order to capture the
details of a given SFI system's trampolines and springboards.

Ψ1 → Ψ2
Ψ2 Lc2 Mp2

Ψ1 Lc1 Mp1
p1 = p2 = p

p

Ψ −→ Ψ0



Ψ−
→ Ψ0

Ψ−
→ Ψ0

p

Ψ−
→ Ψ0

Ψ1 −
→ Ψ2

wb




Ψ → Ψ1 −
→∗ Ψ2 → Ψ0
ΨLgatecalln iM
Ψ2 LgateretM
wb

Ψ −→ Ψ0
Memory isolation. SFIasm provides abstract mechanisms for
enforcing SFI memory isolation by equipping the standard
Figure 2: Well-Bracketed Transitions
load, store, push, and pop with (optional) statically annotated checks. To capture different styles of enforcement we
model these checks as partial functions that map a pointer
to its new value or are undefined when a particular address systems that enable zero-cost transitions and for exploring
is invalid. This lets us, for instance, capture NaCl's coarse the correctness of particular implementations of springboards
grained, dynamically enforced isolation (sandboxed code may and trampolines. As a baseline we prove that NaCl-style
read and write anywhere in the sandbox memory) by requiring heavyweight transitions satisfy the high-level properties.
that all loads and stores are annotated with f (n)|n∈Mlib = n. Well-bracketed gated calls. SFI systems may allow arbitrary
Control-flow integrity. SFIasm also provides abstract control- nesting of calls into and callbacks out of the sandbox. Thus,
flow integrity enforcement via annotations on jmp, call, and it is insufficient to define that callee-save registers have
ret. These are also enforced dynamically. However, we require been properly restored by simply equating register state upon
that the standard control flow operations remain within their entering and exiting the sandbox. Instead we make the notion
own security domain so that gatecall and gateret remain of an entry and its corresponding exit precise, by using
SFIasm's gatecall and gateret to define a notion of wellthe only way to switch security domains.
bracketed gated calls that serve as the backbone of transition
Operational semantics. We capture the dynamic behavior via
integrity properties. A well-bracketed gated call, which we
0
a deterministic small step operational semantics (Ψ → Ψ ).
wb
write
Ψ −→ Ψ0 (Figure 2), captures the idea that Ψ is a gated
The rules are standard; we show the rule for load here:
call from one security domain to another, followed by running
haddri = VΨ (i)
addr0 = k(addr)
in the new security domain, and then Ψ0 is the result of a gated
0
0
v = Ψ.M (addr )
R = Ψ.R[r 7→ v]
return that balances the gated call from Ψ. This can include
potentially recursive but balanced gated calls. Well-bracketed
ΨLr ← loadk iM → Ψ++ [R := R0 ]
gated calls let us relate the state before a gated call with the
VΨ (i) evaluates the immediate value based on the register file state after the corresponding gated return, capturing when the
and Ψ++ increments pc, checking that it remains within the library has fully returned to the application.
same security domain. If the function k(addr) is undefined
(addr is not within bounds), the program will step to a Integrity. Relations between the states before calling into the
distinguished, terminal state error. ΨLcM is simply shorthand sandbox and then after the corresponding return capture SFI
for ΨLcMp when we do not care about the security domain. transition system integrity properties. We identify two key
Lastly, we do not include a specific halt command, instead integrity properties that SFI transitions must maintain:
1. Callee-save register integrity requires that callee-save
halting when pc is not in the domain of C.
registers are restored after returning from a gated call into
A. Secure transitions
the library. This ensures that an attacker cannot unexpectedly
Our goal is to specify when sandboxed code has enough modify the internal state of an application function.
2. Return address integrity requires that the sandbox 1) restructure to elide springboards and trampolines while mainturns
to the instruction after the gatecall, 2) does not tamper
taining the same security guarantees. One way to do so, is by
with
the
stack pointer, and 3) does not modify the call stack
stipulating that zero-cost sandboxed code is equivalent with or
itself.
Together
these ensure that an attacker cannot tamper
without springboards and trampolines. Unfortunately, such a
with
the
application
control flow.
specification would be unpleasantly operational. First, it would
These integrity properties are crucial to ensure that the
be hard to get right: springboards and trampolines are tricky
and involve a significant amount of low-level implementation sandboxed library cannot break application invariants. To
detail. Second, such a specification would be platform-specific capture them formally, we first define an abstract notion of
as each architecture and calling-conventions requires different an integrity property across a well-bracketed gated call. This
not only allows us to cleanly define the above properties, but
springboards and trampolines.
Instead, we use SFIasm to declaratively specify high-level also provides a general framework that can capture integrity
properties that capture the intended security goals of transition properties for different architectures.
systems. This lets us use SFIasm both as a setting for studying
Specifically, we define an integrity property by a predicate

5

I : Trace × State × State → P that captures when integrity is
preserved across a call (P is the type of propositions). The first
argument is a trace, a sequence of steps that our program has
taken before making the gated call. The next two arguments
are the states before and after the well-bracketed gated call. I
defines when these two states are properly related. This leads
to the following definition of I-Integrity:

then a pair of a N and a label p. We also extend our instruction
set with r ← movlabelp and storelabelp i that allow the
application to dynamically assign the label p to the value stored
in register r or pointed to by i, respectively.

Definition 2 (Callee-Save Register Integrity). Let CSR be
the callee-save registers and define CSR(_, Ψ1 , Ψ2 ) ,
Ψ2 .R(CSR) = Ψ1 .R(CSR). If an SFI transition system has
CSR-integrity then we say it has callee-save register integrity.

A further consideration that we must account for in defining
a noninterference property is that, during a callback to the
application, the application may choose to declassify additional
information. For instance, a sandboxed image decoding library
might, after parsing the file header, make a callback requesting
the appropriate data to decode the rest of the image. This
application callback will then transfer that data (which was
previously confidential application data) over to the sandboxed
memory, declassifying it in the transfer.

Next we ask what comprises a public output: that is, what
should be considered as leaking the secret (app-labeled) data?
In these low-level systems, leaks occur when secret data could
Definition 1 (I-Integrity). Let I : Trace × State × State → P. be written to a file or exfiltrated over the network. However,
Then, if Ψ0 ∈ Program, π = Ψ0 →∗ Ψ1 , Ψ1 L_Mapp , and sandboxed libraries aren't given direct access to system calls
wb
Ψ1 −→ Ψ2 imply that I(π, Ψ1 , Ψ2 ), we say that an SFI that would enable such exfiltration and are only given indirect
access through callbacks provided by the host application. We
transition system has I-integrity.
thus over-approximate the public outputs as the set of values
We instantiate this to define our two integrity properties:
returned to the application: this includes all the values that
Callee-save register integrity. We define callee-save register could be leaked. The returned values include all arguments to
integrity as an I-integrity property that ignores the Trace a gatecall callback, the return value when doing a gateret
argument but requires the callee-save registers' values to be to the application, and all values stored in the sandboxed heap
equal in both states:
(Hlib ) which may be referenced by other returned values.

Return address integrity. We specify that the library returns
to the expected instruction as a relation between Ψ1 and Ψ2 ,
namely that Ψ2 .pc = Ψ1 .pc+1. Restoration of the stack pointer
can similarly be specified as Ψ2 .sp = Ψ1 .sp. Specifying call
stack integrity is more involved as Ψ1 lacks information on
where return addresses are saved: they look like any other
data on the stack. Instead, return addresses are defined by
the history of calls and returns leading up to Ψ1 , which we
capture with the trace argument π. We thus define a function
return-address(π) (details in the appendix, see Figure 16) that
computes the set of locations of return addresses based on a
trace. The third clause of return address integrity is then that
these locations' values are preserved from Ψ1 to Ψ2 , yielding:

Due to the possibility of intentional declassification, we
choose to follow [46] and define confidentiality as disjoint
non-interference as follows. We use Ψ =lib Ψ0 to mean that Ψ
and Ψ0 agree on all values with label lib, representing varying
secret inputs. We further use Ψ =call m Ψ0 for when Ψ and
Ψ0 agree on all sandboxed heap values, the program counter,
and the m arguments passed to a callback and Ψ =ret Ψ0
for when Ψ and Ψ0 agree on all sandboxed heap values, the
program counter, and the value in the return register (written
rret ).3 This lets us define noninterference as follows:

Definition 3 (Return Address Integrity).
RA(π, Ψ1 , Ψ2 ) , Ψ2 .pc = Ψ1 .pc + 1 ∧ Ψ2 .sp = Ψ1 .sp ∧

Definition 4 (Disjoint Noninterference).

Ψ2 .M (return-address(π)) = Ψ1 .M (return-address(π))

If, for all Ψ0 ∈ Program, Ψ1 L_Mlib , Ψ3 L_Mapp , Ψ0 →∗
lib
Ψ1 −−→n Ψ2 → Ψ3 , and, for all Ψ01 such that Ψ1 =lib Ψ01 ,
lib
we have that Ψ01 −−→n Ψ02 → Ψ03 , Ψ03 L_Mapp , Ψ3 .pc =
Confidentiality. SFI systems must make sure that secrets Ψ0 .pc, and 1) Ψ Lgatecall iM, Ψ0 Lgatecall iM, and
2
3
2
m
m
cannot be leaked to the untrusted library, that is they must Ψ =
0
0
3
call m Ψ3 or 2) Ψ2 LgateretM, Ψ2 LgateretM, and
provide confidentiality. We specify confidentiality as non- Ψ = Ψ0 , then we say that the SFI transition system has
3
ret
3
interference: "changing secret inputs does not affect public the disjoint noninterference property.
outputs." In the context of library sandboxing we associate
"secret" with application data and "non-secret" with library data,
This definition states that, for any consecutive sequence of
as the purpose of library sandboxing is isolating untrusted
executing exactly n steps within the sandbox then returning
2
components. We thus augment values with labels app or
control to the application, varying confidential inputs does not
lib where lib v app (non-secret can flow to secret) and
influence the public outputs and the library returns control to the
app 6v lib (secret cannot "flow to" non-secret). Values are
application in the same number of steps. Thus, an SFI transition
system satisfying Disjoint Noninterference is guaranteed to not
2 This could also be extended to a setting with mutually distrusting
components.
declassify new data while running within the sandbox.
If an SFI transition system has RA-integrity then we say the
system has return address integrity.

6

: N
Frame 3 SF ::= { base
ret-addr -loc : N
: ℘(Reg × N) }
csr -vals
Function 3 F ::= { instrs : N * Command
entry : N
type : N
}
oState 3 Φ ::= oerror
: State
| { Ψ
funcs : N * Function
stack : [Frame]
}

O C ALL

hn, libi = VΦ (i)
n0 = k(n)
sp0 = Φ.sp + 1
0
0
M = Φ.M [sp 7→ Φ.pc + 1]
stack = [SF ] ++ Φ.stack
SF = new-frame(Φ, n0 , sp0 )
typechecks(Φ, n0 , sp0 )
0
0
0
Φ = Φ[stack := stack , pc := n , sp := sp0 , M := M 0 ]
ΦLcallk iMlib
Φ0
0

O R ET

is-ret-addr(Φ, Φ.sp)
hni = Φ.M (Φ.sp)
n0 = k(n)
0
csr-restored(Φ)
Φ = pop-frame(Φ)
ΦLretk Mlib
Φ0 [pc := n0 , sp := Φ.sp − 1]

Figure 3: oSFIasm Extended Syntax

O J MP

hn, libi = VΦ (i)
n0 = k(n)
in-same-func(Φ, Φ.pc, n0 )
ΦLjmpk iMlib
Φ[pc := n0 ]

IV. Z ERO -C OST T RANSITION C ONDITIONS
We define our zero-cost conditions as a safety monitor with
a language oSFIasm overlaid on top of SFIasm. This language
extends SFIasm with additional structure and dynamic type
checks that ensure the invariants needed for zero-cost transitions
are maintained upon returning from library functions, providing
both an inductive structure for proofs of security for zero-cost
implementations and providing a top level guarantee that our
integrity and confidentiality properties are maintained.

O S TORE

hn, libi = VΦ (i)
v = h_, pi0 i = VΦ (i0 )
0
0
M = Φ.M [n 7→ v]
writeable(Φ, n0 )
0
n = k(n)
pi0 = app =⇒ n0 ∈
/ Hlib
++
0
ΦLstorek i := i Mlib
Φ [M := M 0 ]

Syntax of oSFIasm. Figure 3 shows the extended syntax of
Figure 4: oSFIasm Operational Semantics Excerpt
oSFIasm. Overlay state, written Φ, wraps the state of SFIasm,
extending it with two extra pieces of data. First, oSFIasm
F = Φ.funcs(target)
F .entry = target
sp ∈ Sp
requires the sandboxed code be organized into functions
[SF ] ++ _ = Φ.stack
sp ≥ SF .ret-addr + F .type
(Φ.funcs). Φ.funcs maps each command in the sandboxed
library to its parent function. Functions (F ) also store the
typechecks(Φ, target, sp)
code indices of their commands as the field F .instrs, store the
entry point (F .entry), and track the number of arguments the
[SF ] ++ _ = Φ.stack
F ∈ cod(Φ.funcs)
function expects (F .type). This partitioning of sandboxed code
ret-addr = SF .ret-addr
n, n0 ∈ F .instrs
into functions is static. Second, the overlay state dynamically
is-ret-addr(Φ, ret-addr )
in-same-func(Φ, n, n0 )
tracks a list of overlay stack frames (Φ.stack ). These stack
frames (SF ) are solely logical and inaccessible to instructions.
[SF ] ++ _ = Φ.stack
They instead serve as bookkeeping to implement the dynamic
∀(r, n) ∈ SF .csr -vals. Φ.R(r) = n
type checks of oSFIasm by tracking the base address of each
csr-restored(Φ)
stack frame (SF .base), the stack location of the return address
(SF .ret-addr ), and the values of the callee save registers upon
[SF ] ++ _ = Φ.stack
entry to the function (SF .csr -vals). We are concerned with
n ∈ Sp =⇒ n ≥ SF .base ∧ n 6= SF .ret-addr
the behavior of the untrusted library, so the logical stack does
writeable(Φ, n)
not finely track application stack frames, but keeps a single
large "stack frame" for all nested application stack frames.
Figure 5: oSFIasm Semantics Auxiliary Predicates
When code fails the overlay's dynamic checks it will result
in the state oerror. Our definition of monitor safety, which
will ensure that zero-cost transitions are secure, is then simply
(with auxiliary definitions shown in Figure 5) shows an excerpt
that a program does not step to an oerror.
of the checks, which we describe below. Full definitions can
be found in Appendix C.
A. Overlay monitor
oSFIasm enforces our zero-cost conditions by extending the Call. In the overlay, the reduction rule for library call instrucoperational semantics of SFIasm with additional checks in the tions (O C ALL) checks type safe execution with typechecks,
overlay's small step operational semantics, written Φ
Φ0 . a predicate over the state (Φ), call target (target), and stack
Each of these steps is a refinement of the underlying SFIasm pointer (sp) that checks that 1) the address we are jumping to
step, that is Φ.Ψ → Φ0 .Ψ whenever Φ0 is not oerror. Figure 4 is the entry instruction of one of the functions, 2) the stack
pointer remains within the stack (sp ∈ Sp ), and 3) the number
3 Full definitions are in Appendix A Definition 8 and Definition 9.
of arguments expected by the callee have been pushed to the

7

stack. On top of this check, call also creates a new logical
stack frame recording the base of the new frame, location of
the return address, and the current callee-save register values,
pushing the new frame onto the overlay stack. To ensure IFC,
we require that i has the label lib to ensure that control flow
is not influenced by confidential values; a similar check is done
when jumping within library code, obviating the need for a
program counter label. Further, because the overlay captures
zero-cost transitions, gatecall behaves in the exact same way
except there is an additional IFC check that the arguments are
not influenced by confidential values.

B. Overlay Semantics Enforce Security
The goal of the overlay semantics and our zero-cost conditions is to capture the essential behavior necessary to ensure
that individual, well-behaved library functions can be composed
together into a sandboxed library call that enforces SFI integrity
and confidentiality properties. Thus, library code that is wellbehaved under the dynamic overlay type system will behave
equivalently to library code with springboard and trampoline
wrappers, and therefore well-behaved library code can safely
elide those wrappers and their overhead. We prove theorems
showing that the overlay semantics is sound with respect to
each of our security properties; we show the statement for
callee-save register integrity below.

Jmp. Our zero-cost conditions rely on preventing invariants
internal to a function from being interfered with by other
functions. A key protection enabling this is illustrated by the Theorem 1 (Overlay Callee-Save Register Soundness). If Φ0 ∈
∗
∗
Φ1 , Φ1 .p = app, and Φ1
Φ2 such
reduction for jmp (O J MP), which enforces that the only inter- Program, Φ0
wb
function control flow is via call and ret: the in-same-func that Φ2 6= oerror and Φ1 .Ψ −→ Φ2 .Ψ, then Φ2 .R(CSR) =
predicate checks that the current (n) and target (n0 ) instructions Φ1 .R(CSR).
are within the same overlay function. The same check is added
V. I NSTANTIATING Z ERO -C OST
to the program counter increment operation, Φ++ . These checks
We describe two isolation systems that securely support
ensure that the logical call stack corresponds to the actual
zero-cost
transitions: they meet the overlay monitor zero-cost
control flow of the program, enabling the overlay stack's use
conditions.
The first is an SFI system using WebAssembly
in maintaining invariants at the level of function calls.
as an IR before compiling to native code using the Lucet
Store. The reduction rule for store (O S TORE) demonstrates toolchain [38]. Here we rely on the language-level invariants
the other key protection enabling function local reasoning, with of Wasm to satisfy our zero-cost requirements. The second,
the check that the address (n) is writeable given the current SegmentZero32, is our novel SFI system combining the x86
state of the overlay stack. writeable guarantees that, if the segmented memory model for memory isolation with several
operation is writing to the stack, then that write must be within security-hardening LLVM compiler passes to enforce our zerothe current frame and cannot be the location of the stored return cost conditions.
address. This allows reasoning to be localized to each function:
A. WebAssembly
they do not need to worry about their callees tampering with
WebAssembly (Wasm) is a low-level bytecode with a sound,
their local variables. Protecting the stored return address is
static
type system. Wasm's abstract state includes global
crucial for ensuring well-bracketing which guarantees that each
variables
and heap memory which are zero-initialized at startfunction returns to its caller.
up. All heap accesses are explicitly bounds checked, meaning
To guarantee IFC, O S TORE first requires that the pointer have that compiled Wasm programs inherently implement heap
the label lib, ensuring that the location we write to is not isolation. Beyond this, Wasm programs enjoy several languagebased on confidential data. Second, the check pi0 = app =⇒ level properties which, in combination with a trusted compiler,
n0 ∈
/ Hlib enforces that confidential values cannot be written produce binaries satisfying the conditions required to support
to the library heap. Similar checks, based on standard IFC secure zero-cost transitions. We describe these below.
techniques, are implemented for all other instructions.
Control flow. There are no arbitrary jump instructions in Wasm,
Ret. With control flow checks and memory write checks in only structured intra-function control flow. Functions may only
place, we guarantee that, when we reach a ret instruction, the be entered through a call instruction, and may only be exited by
logical call frame will correspond to the "actual" call frame. executing a return instruction. Functions also have an associated
ret is then responsible for guaranteeing well-bracketing and type; direct calls are type checked at compile time while indirect
ensuring callee-save registers are restored. This is handled calls are subject to a runtime type check. This ensures that
by two extra conditions on ret instructions: is-ret-addr and compiled Wasm meets our type-directed forward-edge CFI
csr-restored. csr-restored checks that callee save registers condition.
have been properly restored by comparing against the values Protecting the stack. A Wasm function's type precisely
that were saved in the logical stack frame by call. is-ret-addr describes the space required to allocate the function's stack
checks that the value pointed to by the stack pointer (ret-addr ) frame (including spilled registers). All accesses to local
corresponds to the location of the return address saved in the variables and arguments are performed through statically known
logical stack frame. Memory writes were checked to enforce offsets from the current stack base. It is therefore impossible for
that the return address cannot be overwritten, so this guarantees a Wasm operation to access other stack frames or alter the saved
the function will return to the expected program location.
return address. This ensures that compiled Wasm meets our

8

local state encapsulation condition, and, in combination with theorem of a logical relation for a whole Wasm library:
type checking function calls, guarantees that Wasm's controlTheorem 2 (Fundamental Theorem for Wasm Libraries). For
flow is well-bracketed. We therefore know that compiled Wasm
any number of steps n ∈ N and compiled Wasm library L,
functions will always execute the register-saving preamble and,
(n, L) ∈ L.
upon termination, will execute the register-restoring epilogue.
Further, the function body will not alter the values of any This theorem states that every function in a compiled Wasm
registers saved to the stack, thereby ensuring the proper library, when making calls to other Wasm functions or
restoration of callee-save registers.
application callbacks, is well-behaved with respect to the zeroConfidentiality. Wasm code may store values into function- cost conditions. The number of steps is a technical detail related
local variables or a function-local "value stack" similar to that to step-indexing. Zero-cost security then follows by adequacy
of the Java Virtual Machine [47]. The Wasm spec requires of the logical relation and Theorem 1:
that compilers initialize function-local variables either with a Theorem 3 (Adequacy of Wasm Logical Relation). For any
function argument or with a default value. Further, accesses to number of steps n ∈ N, library L such that (n, L) ∈ L,
the Wasm value stack are governed by a coarse-grained data- program Φ0 ∈ Program using L, and n0 ≤ n, if Φ0 n0 Φ0
flow type system, with explicit annotations at control flow joins. then Φ0 6= oerror.
These are used to check at compile-time that an instruction
cannot pop a value from the stack unless a corresponding value Details of the logical relation and proofs are in Appendix D.
was pushed earlier in the same function. This guarantees that B. SegmentZero32
local variable and value stack accesses can be compiled to
SegmentZero32 is our novel design of a 32-bit SFI
register accesses or accesses to a statically-known offset in the
scheme
developed using the zero-cost conditions as a design
stack frame.
guide.
SegmentZero32
leverages Clang/LLVM compiler
When executing a compiled Wasm function without heavypasses
to
directly
enforce
the
structure required for zero-cost
weight transitions, confidential values from prior computations
transitions
on
C
code,
rather
than relying on Wasm as an
may linger in these spilled registers or parts of the stack.
IR.
Similar
to
NaCl
[9]
and
vx32
[14], SegmentZero32
However, the above checks ensure that these locations will
takes
advantage
of
the
x86
segmented
memory model [48] for
only be read if they have been previously overwritten during
memory
isolation.
Segmentation
allows
programs to demarcate
execution of the same function by a low-confidentiality Wasm
the
memory
regions
that
are
used
as
the
stack, data (heap), and
library value.
code regions, with hardware support for range checks. However,
Proving Wasm secure. We prove that compiled Wasm libraries both NaCl and vx32 employ only a single memory range that
can safely elide springboards and trampolines while maintaining is shared by the sandbox stack and heap. SegmentZero32
integrity and confidentiality, by showing that the compiled code instead separates these two, and then leverages existing exploit
would not violate the safety monitor. This allows us to apply mitigation passes (along with a pass of our design) to provide
Theorem 1 and its analogues. It is relatively straightforward isolation while supporting zero-cost transitions. We describe
(with one exception) to verify that the properties of Wasm these passes and how we use them below:
as described above satisfy the necessary safety conditions, by
Protecting the stack. Simply using separate stack and nonshowing that the linear instructions of each basic block within
stack segments does not protect the return addresses and context
a function are safe and that each basic block properly initializes
saved on the stack from a standard buffer overflow attack. We
the local state for any block it jumps to. Type-safe execution
solve this issue by applying the SafeStack [49], [50] compiler
of calls is guaranteed by Wasm's required type checking, and
pass, an LLVM pass designed to protect against stack corruption.
confidentiality is preserved by the language invariant that all
The pass splits the sandboxed stack into a safe and unsafe
registers and stack slots are either written before use or zerostack. The safe stack contains only data that the compiler can
initialized.
statically verify is always accessed safely, e.g., return addresses,
The crucial exception in the proof is function calls to other
spilled registers, and allocations that are only accessed locally
Wasm functions. We must inductively assume that the called
using verifiably safe offsets within the function that allocates
function is safe, i.e., doesn't change any variables in our stack
them.4 All other stack values else are moved to the heap.
frame, restores callee-save registers, etc. Unfortunately, a naive
While the above modifications are sufficient for stack safety,
attempt does not lead to an inductively well-founded argument.
in practice we ran into a compatibility challenge when using the
Instead, we use the overlay monitor's notion of a well-behaved
stack segment to access the safe stack: code emitted by LLVM
function to define a step-indexed logical relation (detailed in
may use the data segment when accessing the safe stack because
Appendix D-A) that captures a semantic notion of well-behaved
the compiler assumes a flat, non-segmented memory model. To
functions (as a relation F), and then lift this to a relation over
correct this, we develop an additional LLVM pass that annotates
an entire Wasm library (as a relation L). This gives a basis for
instructions with stack and data segment override prefixes as
an inductively well-founded argument where we can locally
prove that each Wasm function is semantically well-behaved
4 We also employ LLVM's existing stack-heap clash detection (flag -fstack(is in F) and then use this to prove the standard fundamental clash-protection) to prevent the stack growing into the heap.

9

needed. The pass assumes that only esp points to the safe
stack at the start of each function. We then track the flow
of addresses derived from esp to other registers throughout
the function to determine whether any given memory operand
refers to the safe stack. If a memory operand references the
incorrect segment, the pass emits a segment override prefix.
With this issue patched, all heap and global loads and stores
are statically assigned a non-stack segment register (in our
model this appears as a guard f (n) with codomain Hlib ) and
all stack operations use verifiably safe offsets and thus can
remain unguarded. This guarantees both local state isolation and
protects saved register values, the stack pointer, and the return
address. Notably, we achieve these properties deterministically
as the segmentation based memory isolation ensures that, even
if an attacker guesses the stack location, they cannot dereference
a pointer to the stack.
Control flow. The above protects the callee-save registers
and the return address saved in each sandbox call frame,
guaranteeing the restoration of callee-save registers and wellbracketing iff forward control flow is enforced. Fortunately,
enforcing forward edge CFI has been widely studied [51].
We use a CFI pass as implemented in Clang/LLVM [52],
[53] including flags to dynamically protect indirect function calls, ensuring forward control flow integrity. Further,
SegmentZero32 conservatively bans non-structured control
flow (including setjmp/longjmp) in the C source code.
A more permissive approach is possible in principle, akin to
the FixIrreducibleControlFlow LLVM pass already used in
WebAssembly compilation, but we leave this for future work.
Confidentiality. To guarantee confidentiality we employ an
existing (experimental) Clang pass that ensures all local
variables (i.e., stack slots or registers) are auto initialized [54].
This ensures that scratch registers cannot leak secrets as all
sandbox values are written before use. This demonstrates
how our zero-cost transition scheme enables a more platform
agnostic defense: we do not need to account for the details of
what scratch registers a processor has, as no application values
can flow to sandbox variables.
We do not include an explicit proof of security for
SegmentZero32 as it closely follows the proof of Wasm
security. The main differences are administrative changes to the
logical relation definitions and a different control-flow graph
for the blocks within each compiled function.
VI. E VALUATION
We evaluate zero-cost transitions by asking three questions:
I What is the performance overhead of zero-cost and
heavyweight transitions in different SFI systems? (§VI-A)
I Do zero-cost transitions improve the end-to-end performance of applications that use WebAssembly SFI? (§VI-B)
I Can our SegmentZero32 isolation scheme outperform
isolation schemes which require heavyweight transitions
(e.g., Native Client) in real workloads? (§VI-C)

10

Implementation. To answer these questions we study the
performance of native (unsandboxed) code and seven isolation
scheme implementations.
The first four isolation builds vary the transition models
for a WebAssembly SFI system based on the Lucet [38]
compiler; this lets us understand the benefits of zero-cost
transitions in WebAssembly-based SFI systems. We investigate
the following builds: the WasmLucet build uses the original
heavyweight springboards and trampolines shipped with the
Lucet runtime written in Rust. WasmHeavy adopts techniques
from NaCl's implementations and uses optimized assembly
instructions to save and restore application context during
transitions. WasmZero implements our zero-cost transition
system, meaning transitions are simple function calls that do
not perform any additional register saving/restoring or stack
switching (library and application code execute on the same
stack). In order to distinguish between the overhead of register
saving/restoring and stack switching, we also test a WasmReg
build which saves/restores registers similar to WasmHeavy,
but shares the library and application stack like WasmZero.
The next three builds use different hardware based isolation schemes to measure whether a purpose-built zero-cost
isolation scheme (SegmentZero32) can outperform stateof-the-art isolation schemes that do not support zero-cost
transitions. Since SegmentZero32 uses segmentation-a
hardware feature supported only in 32-bit x86 programs-
the next three builds are all run in 32-bit mode for a fair
comparison. SegmentZero32, is the zero-cost segmentation
scheme described in §V-B. NaCl32, is the Native Client 32bit isolation scheme [9], as modified by Narayan et al. [16]
to support library isolation; this scheme also leverages segmentation but employs transitions similar to WasmHeavy. We
also compare against IdealHeavy32, an "optimal" hardware
isolation scheme that is not zero-cost compatible; this scheme
incurs no slowdowns to enforce, enable, or disable isolation.
To simulate the performance of IdealHeavy32, we simply
measure the performance of native code with heavy-weight
trampolines.
We integrate each SFI scheme into Firefox using the RLBox
framework [16]. RLBox already provides plugins for the
WasmLucet and NaCl32 builds, we implement the plugins
for the remaining builds above.5
Machine / software setup. We run all benchmarks on a
machine with Intel® CoreTM i7-6700K with four 4GHz cores,
64GB RAM, running Ubuntu 20.04.1 LTS (kernel version 5.4.058). Benchmarks are run with a shielded isolated cpuset [55]
consisting of one core with hyperthreading disabled and the
clock frequency pinned to 2.2GHz. Wasm sandboxed code is
generated with a two-part toolchain-C/C++ is first compiled
to the Wasm format with Clang-11, and then to native code
using the fork of the Lucet used by RLBox (snapshot from Dec
9th 2020). NaCl sandboxed code is generated with a modified
5 While the SegmentZero32 plugin accurately model transition costs,
we emphasize that this is not production ready. In particular, we relax the
restrictions on accessible address ranges as we need to allow access to static
data sections in ELF binaries.

Wasm build

Direct call

Indirect call

Callback

Syscall

Func (in C)
WasmLucet
WasmHeavy
WasmReg
WasmZero

1ns
N/A
120ns
120ns
7ns

56ns
1137ns
209ns
210ns
66ns

56ns
N/A
172ns
172ns
67ns

24ns
N/A
192ns
192ns
60ns

than IdealHeavy32 and NaCl32 transitions and only
23ns slower than Func for direct calls. SegmentZero32
incurs some overhead over WasmZero as hardware isolation
schemes like SegmentZero32 and NaCl32 must invoke
extra instructions to enable or disable the hardware based
memory isolation in their transitions.

32-bit hardware
isolation build

Direct call

Indirect call

Callback

Syscall

B. Zero-cost transitions for WebAssembly SFI

Func (in C, 32-bit)
IdealHeavy32
NaCl32
SegmentZero32

1ns
324ns
N/A
24ns

74ns
179ns
714ns
108ns

74ns
154ns
373ns
80ns

37ns
181ns
356 ns
88ns

Figure 6: Costs of transitions in different isolation models.
Zero-cost transitions are shown in boldface. Func is the
performance of vanilla unsandboxed C to serve as a baseline.

version of Clang-4. All other C/C++ source code including
SegmentZero32 sandboxed code as well as the benchmarks
applications are compiled with Clang-11. We implement our
Firefox benchmarks on a top of Firefox Nightly (from August
22, 2020).

We evaluate the end-to-end performance impact of the different transition models using two libraries currently sandboxed
in Firefox: font rendering with libgraphite, and image
rendering with libjpeg. The performance of these sandboxed
libraries was previously observed by Narayan et al. [16] to be
particularly affected due to the high-number of transitions.
Font rendering. We evaluate the performance of
libgraphite isolated with Wasm-based schemes using
Kew's benchmark6 , which was also used by Narayan et al. The
benchmark reflows the text on a page ten times, adjusting the
size of the fonts each time to negate the effects of font caches.
We run this benchmark 100 times and report the median
execution time below (all values have standard deviations
within 1%).

A. Transition microbenchmarks
We measure the cost of different uses of transitions - direct
and indirect calls into the sandbox, callbacks from the sandbox
and syscall invocations from the sandbox - for the different
isolation builds described. To expose overheads fully, we choose
extremely fast payloads-either a function that just adds two
numbers or the gettimeofday syscall, which relies on
Linux's vDSO to avoid CPU ring changes. The results are
shown in Figure 6. All numbers are averages of one million
repetitions, and repeated runs have negligible standard deviation.
Note that Lucet's and NaCl's existing implementations do not
support direct sandbox calls and Lucet also does not support
custom callbacks or invocation of syscalls, so we do not report
these numbers.
Among Wasm-based SFI schemes, zero-cost transitions
(WasmZero) are significantly faster than even optimized
assembly instructions implementing heavy-weight transitions
(WasmHeavy). Lucet's existing indirect calls written in Rust
(WasmLucet) are significantly slower than both. Stack switching (the difference of WasmHeavy and WasmReg) adds
a very small overhead for transitions. The performance of
Func and WasmZero should be identical but is not. This is
not because our transitions have a hidden cost; rather, it is
because we are comparing code produced by two different
compilers: Func is native code produced by Clang, while
WasmZero is code produced by Lucet, and Lucet's code
generation is not yet highly optimized [56]. For example, in
the benchmark that adds two numbers, Clang eliminates the
function prologue and epilogue that save and restores the frame
pointer, while Lucet does not. For hardware-based isolation,
we compare our zero-cost transitions in SegmentZero32
to heavyweight transitions in NaCl32 and IdealHeavy32
We find that SegmentZero32 transitions are much faster

11

Font render

WasmLucet WasmHeavy

WasmReg WasmZero

8173ms

2230ms

2246ms

2032ms

As expected, zero-cost transitions (WasmZero) result in the
best performance. Compared to WasmZero, Lucet's existing
transitions slow down rendering by over 4×. Even when using
the optimized transitions of WasmHeavy, performance is over
10% slower than WasmZero. Stack switching accounts for
about 0.8% of WasmHeavy's extra cost.
Image rendering. Firefox renders images in streaming mode,
calling libjpeg to decode every row of an image. Hence,
the amount of work done in our Wasm-sandboxed libjpeg,
per call, is proportional to the width of the image, and the
complexity of the rendering a row of the image. We expect the
effect of per-transition overhead to decrease with increasing
image width and increasing image complexity. Our benchmark
thus varies the width and image complexity.
Figure 7 shows the costs of rendering three kinds of
jpeg images-a simple image consisting of a single color
(SimpleImage), a stock image from the Image Compression
benchmark suite7 (StockImage), and an image of random
pixels (RandomImage). Each image is rendered 500 times.
We report the median decoding time (standard deviations are all
under 1%). The costs are normalized to WasmZero to highlight
the relative overheads of different transitions as compared to our
zero-cost transitions. The results of WasmLucet are included
in the Appendix (Figure 26) because the rendering times are
up to 9.2× longer than the other builds and skews our graphs.
We instead focus on evaluating the overheads of optimized
heavy transitions. The WasmLucet performance numbers do
highlight the fact that care is needed in implementing optimized
6 Available
7 Online:

at https://jfkthame.github.io/test/udhr_urd.html
https://imagecompression.info/test_images/. Visited Dec 9, 2020.

Normalized overhead

1.3

1.10

WasmZero
WasmHeavy
WasmReg

1.2

1.10
WasmZero
WasmHeavy
WasmReg

1.05

WasmZero
WasmHeavy
WasmReg

1.05

1.1
1.00

1.0

1.00

0.95

0.9
500

1000
Image width (pixels)

0.95
500

1500

1000
Image width (pixels)

1500

500

(b) StockImage

(a) SimpleImage

1000
Image width (pixels)

1500

(c) RandomImage

95%
48%

19
20

>

19
20

14
40
14
40

to

96
0
96
0

to

48
0
to

to
48
0

24
0

to

24
0

12
0
12
0

to
60

30

to
30

to

to
15

0

60

0%

15

Cumulative
image percent

Figure 7: Performance of different wasm transitions on rendering of (a) a simple image with one color, (b) a stock image and
(c) a complex image with random pixels, normalized to WasmZero. WasmZero transitions outperform other transitions. The
difference diminishes with width, but narrower images are more common on the web.

Image width (pixels)-log scale

Figure 8: Cumulative distribution of image widths on the
landing pages of the Alexa top 500 websites. Over 80% of the
images have widths under 480 pixels. Narrower images have a
higher transition rate, and thus higher relative overheads when
using expensive transitions.

heavyweight transitions, and that the transitions available in
current tools may not be fully optimized.
As expected, WasmZero significantly outperforms other
transitions when images are narrower and simpler. On
SimpleImage, WasmHeavy and WasmLucet can take as
much as 29.7% and 9.2× longer to render the image as with
WasmZero transitions. However, this performance difference
diminishes as image width increases. For StockImage and
RandomImage, the WasmHeavy trends are similar, but the
rendering time differences start at about 4.5%. However, Lucet's
existing transitions (WasmLucet) are still significantly slower
than zero-cost transitions (WasmZero) even on wide images.
Though the differences between the transitions are smaller
as the image width increases, we find that most images on
the web are narrow. Figure 8 shows the distribution of images
on the landing pages of the Alexa top 500 websites. Of the
10.6K images, 8.6K (over 80%) have widths between 1 and
480 pixels, a range in which zero-cost transitions noticeably
outperform the other kinds of transitions.
C. Zero-cost transitions for native isolation
In this section, we compare the performance of native code
against code isolated with SegmentZero32 with zero-cost
transitions, against code isolated with NaCl (NaCl32) which
does not support zero-cost transitions. SegmentZero32
and NaCl32 isolate native-compiled libraries (without going
through Wasm) and use hardware support to enforce isolation.
Additionally, we also compare against a hypothetical isolation

12

with no isolation enforcement overhead (IdealHeavy32)
with heavyweight transitions; this simulates the performance
of isolation schemes using hardware such as MPK [25] which
have negligible overhead but require heavyweight transitions.
The IdealHeavy32 performance is simulated by running
native unsandboxed code with heavyweight transitions.
To measure performance, we rerun our libgraphite
and libjpeg benchmarks from the previous section,
but isolate the libraries using SegmentZero32, NaCl32
and IdealHeavy32. Since both SegmentZero32 and
NaCl32 use segmentation which is supported only in 32bit mode, we implement these three isolation builds in
32-bit mode and compare it to native 32-bit unsandboxed
code. We find that for these benchmarks, SegmentZero32
with zero-cost transitions outperforms NaCl32 as well as
the hypothetical IdealHeavy32 isolation. We describe the
individual benchmarks next.
Font rendering. The impact of these isolation schemes on
font rendering is shown below (standard deviations under 1%).
Unsandboxed IdealHeavy32 NaCl32 Segment
32-bit code
-Zero32
Font render

1441ms

2399ms

2769ms

1765ms

We observe that NaCl32 and IdealHeavy32 incur overhead of 92% and 66% respectively compared to unsandboxed
code. In contrast, SegmentZero32 only has an overhead of
22.5% as it does not have to save and restore registers or switch
stacks. The overhead of SegmentZero32 over native code
itself is due to a few different factors: first, SegmentZero32
must change segments to enable/disable isolation during
function calls; second, it uses indirect function calls for
invocation (a choice that simplifies engineering but is not
fundamental), and finally, there is a small slowdown imposed
by code structure enforced to allow zero-cost transitions.
Image rendering. The impact of the above sandboxing
schemes on image rendering is compared in Figure 9 (standard deviations under 1%). For narrow images of width 10
pixels, SegmentZero32 overheads relative to the native
unsandboxed code are 24%, 1%, and 6.5% for SimpleImage,
StockImage and RandomImage, respectively. This is lower
than the corresponding overheads for NaCl32 which are 312%,
29%, and 66% respectively as well as IdealHeavy32 which
are 208%, 28% and 45% respectively. As observed in Wasm

Normalized overhead

4

Unsandboxed 32-bit Code
SegmentZero32
IdealHeavy32
NaCl32

3
2
1

1.6

Unsandboxed 32-bit Code
SegmentZero32
IdealHeavy32Reg
NaCl32

1.4
1.2
1.0

500

1000
Image width (pixels)

(a) SimpleImage

1500

1.6

Unsandboxed 32-bit Code
SegmentZero32
IdealHeavy32
NaCl32

1.4
1.2
1.0

500

1000
Image width (pixels)

(b) StockImage

1500

500

1000
Image width (pixels)

1500

(c) RandomImage

Figure 9: Performance of image rendering with libjpeg sandboxed with SegmentZero32 and NaCl32 and IdealHeavy32.
Times are relative to unsandboxed code. NaCl32 and IdealHeavy32 relative overheads are as high as 312% and 208%
respectively, while SegmentZero32 relative overheads do not exceed 24%.

workloads, these overheads reduce as image width increases
and the complexity of the image increases. Additionally, we
observe that the overheads are negligible for images wider than
480 pixels but, as we have seen earlier, such images constitute
less than 20% of all images on the Alexa top 500 websites.

reading uninitialized scratch registers and therefore cannot
ensure confidentiality without heavyweight springboards that
clear scratch registers. They also do not specify the CFG
granularity, so it is not clear if is strong enough to satisfy the
zero-cost type safe CFI requirement.

Conclusion. From our evaluation, we conclude that the perfor- WebAssembly based isolation. WasmBoxC [35] sandboxes C
mance of an isolation scheme that supports zero-cost transitions code through compilation to Wasm followed by (de)compilation
can be significantly lower for certain workloads, especially back to C, ensuring that the sandboxed C code will inherit
those with a large number of transitions. Additionally, for isolation properties from Wasm. The sandboxed library code
workloads that do not transition frequently (e.g., rendering can be safely linked with C applications, enabling a form
wide images), the additional runtime overheads imposed by of zero-cost transition. The zero-cost Wasm SFI system
zero-cost condition enforcement do not result in significant described by this paper was designed and released prior to and
performance overheads.
independently of WasmBoxC, as the creators of WasmBoxC
acknowledge. Moreover, we believe that the theory developed
VII. R ELATED WORK
in this paper provides a foundation for analyzing and proving
A considerable amount of research has gone into efficient the security of WasmBoxC though such analysis would need
implementations of memory isolation and CFI techniques to to account for possible undefined behavior introduced in
provide SFI across many platforms [2], [3], [5]–[8], [11], compiling Wasm to C.
[12], [14], [20]–[22], [38], [57]–[60]. However, these systems
Sledge [13] describes a Wasm runtime for edge computing,
either implement or require the user to implement heavyweight that relies on Wasm properties to enable efficient isolation of
springboards and trampolines to guarantee security.
serverless components. However, Sledge focuses on function
SFI systems. Wahbe et al. [1] suggest two ways to optimize scheduling including preempting running Wasm programs, and
transitions: (1) partitioning the registers used by the application its needs for context saving differ from library sandboxing as
and the sandboxed component and (2) performing link time contexts must be saved even in the middle of function calls.
optimizations (LTO) that conservatively eliminates register
SFI Verification. Our work includes the compiler in the TCB.
saves that are never used in the entire sandboxed component
Previous work on SFI (e.g., [2], [4], [9], [62]) instead uses
(not just the callee). Register partitioning would cause slowa verifier (a small verified trusted program) or a theorem
downs due to increased spilling. Native Client [9] optimized
prover [23], [63] to validate the relevant SFI properties
transitions by clearing and saving contexts using machine
of compiled sandbox code. However these verifiers do not
specific mechanisms like the Intel® fxrstor instruction
currently establish sufficient properties for zero-cost transitions.
which clears floating point state and SIMD registers. We show
Our safety monitor definition provides the appropriate context
(§VI) that such transitions still impose significant overhead.
for extending existing SFI verification work to validate that
While CPU makers continue to add optimized context switching
compiled code meets both SFI and zero-cost conditions.
instructions, such instructions do not yet eliminate all overhead.
Zeng et al. [61] combine an SFI scheme with a rich CFI Hardware based isolation. Hardware features such as memory
scheme enforcing structure on executing code. While a similar protection keys [25], [26], extended page tables [64], virtuapproach, their goal is to safely perform optimizations to elide alization instructions [64], [65], or even dedicated hardware
SFI and CFI bounds checks, and they do not impose sufficient designs [66] can be used to speed up memory isolation. These
structure to enforce well-bracketing, a necessary property for works focus on the efficiency of memory isolation as well
zero-cost transitions. XFI [4] also combines an SFI scheme as switching between protected memory domains but require
with a rich CFI scheme and adopts a safe stack model. While heavyweight transitions. IdealHeavy32 in Section VI studmeeting many of the zero-cost conditions, it does not prevent ies an idealized version of such a scheme.

13

Capabilities. [67] and [68] both look at protecting interacting components on systems that provide hardware enforced
capabilities. [67] specifically looks at how register saving and
restoration can be optimized based on different levels of trust
between components, however their analysis does not offer any
formal security guarantees. [68] investigate a calling-convention
based on capabilities such as those of CHERI [69] that
allows safe sharing of a stack between distrusting components.
Their definition of well-bracketed control flow and local state
encapsulation via an overlay system inspired our work, and
our logical relation is also based on their work. However, their
technique does not yet ensure an equivalent notion to our
confidentiality property, and further is tied to machine support
for hardware capabilities.

LTO. We show that zero-cost transitions applied to Wasm
reduce transitions to a simple function call. This then allows
LTO to optimize code across calls across the application-Wasm
boundary. We don't use LTO across the application sandbox
boundary in our benchmarks, however LTO speedups for Wasm
sandboxed code have been examined by Zakai [35].

Type safety for isolation. There has also been work on using
strongly-typed languages to provide similar security benefits.
SingularityOS [32], [70], [71], explored using Sing# to build
an OS with cheap transitions between mutually untrusting
processes. Unlike the work on SFI techniques that zero-cost
transitions extend, tools like SingularityOS require engineering
effort to rewrite unsafe components in new safe languages.
At a lower level, Typed Assembly Language (TAL) [33],
[72], [73] is a type safe compilation target for high-level type
safe languages. Its type system enables proofs that assembly
programs follow calling conventions, and enables an elegant
definition of stack safety through polymorphism. Unfortunately,
SFI is designed with unsafe code in mind, so cannot generally
be compiled to meet TAL's static checks. To handle this our
zero-cost and security conditions instead capture the behavior
that TAL's type system is designed to ensure.

[1] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, "Efficient
software-based fault isolation," in Proceedings of the Fourteenth
ACM Symposium on Operating Systems Principles, ser. SOSP '93.
Association for Computing Machinery, 1993, pp. 203–216. [Online].
Available: https://doi.org/10.1145/168619.168635
[2] S. McCamant and G. Morrisett, "Evaluating SFI for a CISC architecture," 2006. [Online]. Available: https://www.usenix.org/conference/
15th-usenix-security-symposium/evaluating-sfi-cisc-architecture
[3] G. Tan et al., Principles and implementation techniques of software-based
fault isolation. Now Publishers, 2017.
[4] Ú. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, "XFI:
Software guards for system address spaces," in OSDI, 2006.
[5] M. Castro, M. Costa, J.-P. Martin, M. Peinado, P. Akritidis, A. Donnelly,
P. Barham, and R. Black, "Fast byte-granularity software fault isolation,"
in OSDI, 2009.
[6] J. N. Herder, H. Bos, B. Gras, P. Homburg, and A. S. Tanenbaum, "Fault
isolation for device drivers," in DSN. IEEE, 2009.
[7] M. I. Seltzer, Y. Endo, C. Small, and K. A. Smith, "Dealing with disaster:
Surviving misbehaved kernel extensions," in OSDI, vol. 96, no. 56, 1996.
[8] S. Lucco, O. Sharp, and R. Wahbe, "Omniware: A universal substrate
for web programming," in WWW, 1995.
[9] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka,
N. Narula, and N. Fullagar, "Native client: A sandbox for portable,
untrusted x86 native code," in 2009 30th IEEE Symposium on Security
and Privacy, 2009, pp. 79–93, ISSN: 2375-1207.
[10] A. Haas, A. Rossberg, D. L. Schuff, B. L. Titzer, M. Holman,
D. Gohman, L. Wagner, A. Zakai, and J. Bastien, "Bringing the web up
to speed with WebAssembly," in Proceedings of the 38th ACM SIGPLAN
Conference on Programming Language Design and Implementation.
Association for Computing Machinery, 2017, pp. 185–200. [Online].
Available: http://dl.acm.org/citation.cfm?doid=3062341.3062363
[11] J. Siefers, G. Tan, and G. Morrisett, "Robusta: Taming the native beast
of the JVM," in CCS, 2010.
[12] B. Niu and G. Tan, "RockJIT: Securing just-in-time compilation using
modular control-flow integrity," in CCS, 2014.
[13] P. K. Gadepalli, S. McBride, G. Peach, L. Cherkasova, and G. Parmer,
"Sledge: a serverless-first, light-weight wasm runtime for the edge," in
Middleware, 2020.
[14] B. Ford and R. Cox, "Vx32: Lightweight user-level sandboxing on the
x86." in USENIX ATC, 2008.
[15] B. Ford, "VXA: A virtual architecture for durable compressed archives."
in FAST, vol. 5, 2005.
[16] S. Narayan, C. Disselkoen, T. Garfinkel, N. Froyd, E. Rahm, S. Lerner,
H. Shacham, and D. Stefan, "Retrofitting fine grain isolation in the
Firefox renderer," in USENIX Sec, 2020.
[17] 1566288 - rlbox - port libgraphite usage code to use the rlbox
api. [Online]. Available: https://bugzilla.mozilla.org/show_bug.cgi?id=
1566288
[18] Pat Hickey, "Announcing Lucet: Fastly's native WebAssembly
compiler
and
runtime,"
https://www.fastly.com/blog/
announcing-lucet-fastly-native-webassembly-compiler-runtime, 2019.
[19] T. McMullen, "Lucet: A compiler and runtime for high-concurrency
low-latency sandboxing," in PriSC, 2020.
[20] M. Payer and T. R. Gross, "Fine-grained user-space security through
virtualization," 2011.

VIII. D ISCUSSION
Zero-cost transitions significantly simplify the transitions
between application and sandbox and, as shown in Section VI,
improve the performance of real workloads. Additionally, they
may also offer benefits in performance and clarity in designing
isolation schemes; we discuss these briefly.
Multi-threading and separate stacks. We believe that stack
switching can incur larger overheads than shown in Section VI
when running workloads where multiple application threads can
invoke sandboxed code in parallel. Here, the application must
maintain an n-to-n stack mapping, i.e., a corresponding sandbox
stack for each application thread that invokes a sandboxed
function. In large applications like browsers, it is not clear
which threads invoke sandboxed code ahead of time; thus,
existing tools [16] maintain and check the mapping lazily as
part of the heavyweight trampoline, thereby adding additional
latency to heavyweight transitions.
Alternate ABIs. We measure transition overhead with the
System V 32-bit and 64-bit calling. However, other conventions
such as the one used in Windows [74] requires saving and
restoring 10 additional floating point registers and may incur
large overhead. Further, heavyweight trampolines get more
complicated and expensive with any ISA extensions that
introduce more registers.

14

Zero-cost transition compatible hardware. As we have
demonstrated, hardware support for memory isolation can be
used for zero-cost transitions if it can separate heap and stack
operations. This simple observation provides a blueprint for how
future isolation hardware (including any hardware extensions
for 64-bit CPUs) could support zero-cost schemes.
R EFERENCES

[21] D. Sehr, R. Muth, K. Schimpf, C. Biffle, V. Khimenko, B. Yee, B. Chen,
and E. Pasko, "Adapting software fault isolation to contemporary CPU
architectures," in USENIX Sec, 2010.
[22] A.-R. Adl-Tabatabai, G. Langdale, S. Lucco, and R. Wahbe, "Efficient
and language-independent mobile programs," in PLDI, 1996.
[23] L. Zhao, G. Li, B. De Sutter, and J. Regehr, "ARMor: fully verified
software fault isolation," in EMSOFT, 2011.
[24] Y. Zhou, X. Wang, Y. Chen, and Z. Wang, "Armlock: Hardware-based
fault isolation for arm," in Proceedings of the 2014 ACM SIGSAC
Conference on Computer and Communications Security, 2014, pp. 558–
569.
[25] A. Vahldiek-Oberwagner, E. Elnikety, N. O. Duarte, M. Sammler,
P. Druschel, and D. Garg, "ERIM: Secure, efficient in-process isolation
with protection keys (MPK)," in 28th {USENIX} Security Symposium
({USENIX} Security 19). {USENIX} Association, 2019, pp. 1221–1238.
[26] M. Hedayati, S. Gravani, E. Johnson, J. Criswell, M. L. Scott, K. Shen,
and M. Marty, "Hodor: Intra-process isolation for high-throughput data
plane libraries," in USENIX ATC, 2019.
[27] F. Alder, J. Van Bulck, D. Oswald, and F. Piessens, "Faulty Point Unit:
ABI poisoning attacks on Intel SGX," in ACSAC, 2020.
[28] S. Maffeis, J. C. Mitchell, and A. Taly, "Object capabilities and isolation
of untrusted web applications," in IEEE S&P, 2010.
[29] A. Mettler, D. A. Wagner, and T. Close, "Joe-E: A security-oriented
subset of Java." in Network and Distributed System Security Symposium
(NDSS), 2010.
[30] M. Grimmer, R. Schatz, C. Seaton, T. Würthinger, and H. Mössenböck, "Memory-safe execution of C on a Java VM," in Workshop on
Programming Languages and Analysis for Security (PLAS), 2015.
[31] M. Miller, M. Samuel, B. Laurie, I. Awad, and M. Stay, "Caja: Safe
active content in sanitized javascript," http://google-caja.googlecode.com/
files/caja-spec-2008-06-07.pdf, June 2008.
[32] G. C. Hunt and J. R. Larus, "Singularity: rethinking the software stack,"
SIGOPS Operating Systems Review, vol. 41, no. 2, 2007.
[33] G. Morrisett, K. Crary, N. Glew, D. Grossman, R. Samuels, F. Smith,
D. Walker, S. Weirich, and S. Zdancewic, "TALx86: A Realistic Typed
Assembly Language," ACM SIGPLAN Workshop on Compiler Support
for System Software, pp. 25–35, 1999.
[34] J. Bosamiya, B. Lim, and B. Parno, "WebAssembly as an intermediate
language for provably-safe software sandboxing," PriSC, 2020.
[35] A. Zakai, "Wasmboxc: Simple, easy, and fast vm-less sandboxing," https:
//kripken.github.io/blog/wasm/2020/07/27/wasmboxc.html, 2020.
[36] S. Narayan, T. Garfinkel, S. Lerner, H. Shacham, and D. Stefan, "Gobi:
Webassembly as a practical path to library sandboxing," 2019.
[37] H. Lu, M. Matz, M. Girkar, J. Hubička, A. Jaeger, and M. Mitchell,
"System v application binary interfaceamd64 architecture processor
supplement(with lp64 and ilp32 programming models)," Tech. Rep.,
2018. [Online]. Available: https://software.intel.com/content/dam/develop/
external/us/en/documents/intro-to-intel-avx-183287.pdf
[38] Lucet. [Online]. Available: https://github.com/bytecodealliance/lucet
[39] Webassembly micro runtime. [Online]. Available: https://github.com/
bytecodealliance/wasm-micro-runtime
[40] Native Client team, "Native Client security contest archive," https:
//developer.chrome.com/docs/native-client/community/security-contest/,
2009.
[41] "Issue 2919: Security: Naclswitch() leaks naclthreadcontext pointer to
x86-32 untrusted code," https://bugs.chromium.org/p/nativeclient/issues/
detail?id=2919, 2012.
[42] "Issue 775: Uninitialized sendmsg syscall arguments in sel_ldr," https:
//bugs.chromium.org/p/nativeclient/issues/detail?id=775, 2010.
[43] "Issue 1607: Signal handling change allows inner sandbox escape on
x86-32 linux in chrome," https://bugs.chromium.org/p/nativeclient/issues/
detail?id=1607, 2011.
[44] "Issue 1633: Inner sandbox escape on 64-bit windows via kiuserexceptiondispatcher," https://bugs.chromium.org/p/nativeclient/issues/detail?id=
1633, 2011.
[45] A. Bartel and J. Doe, "Twenty years of escaping the Java sandbox," in
Phrack, 2018.
[46] A. Matos and G. Boudol, "On declassification and the non-disclosure policy," in 18th IEEE Computer Security Foundations Workshop (CSFW'05),
2005, pp. 226–240.
[47] "Java platform, standard edition: Java virtual machine guide," Tech.
Rep., 2019. [Online]. Available: https://docs.oracle.com/en/java/javase/
13/vm/java-virtual-machine-guide.pdf
[48] "Intel® 64 and IA-32 architectures software developer's manual," 2020.

15

[49] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and
D. Song, "Code-pointer integrity," in 11th {USENIX} Symposium on
Operating Systems Design and Implementation ({OSDI} 14), 2014, pp.
147–163. [Online]. Available: https://www.usenix.org/conference/osdi14/
technical-sessions/presentation/kuznetsov
[50] Safestack, Clang 12 documentation. [Online]. Available: https:
//clang.llvm.org/docs/SafeStack.html
[51] N. Burow, S. A. Carr, J. Nash, P. Larsen, M. Franz, S. Brunthaler, and
M. Payer, "Control-Flow Integrity: Precision, Security, and Performance,"
ACM Computing Surveys, vol. 50, pp. 16:1–16:33, Apr. 2017. [Online].
Available: https://doi.org/10.1145/3054924
[52] Control Flow Integrity, Clang 12 documentation. [Online]. Available:
https://clang.llvm.org/docs/ControlFlowIntegrity.html
[53] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway, Ú. Erlingsson,
L. Lozano, and G. Pike, "Enforcing forward-edge control-flow integrity in
GCC & LLVM," in Proceedings of the 23rd USENIX Security Symposium,
K. Fu and J. Jung, Eds., 2014, pp. 941–955.
[54] Automatic variable initialization. [Online]. Available: https://reviews.
llvm.org/rL349442
[55] Shielding
linux
resources-introduction.
[Online].
Available: https://documentation.suse.com/sle-rt/15-SP1/html/SLE-RT-all/
cha-shielding-intro.html
[56] L. T. Hansen, "Cranelift: Performance parity with Baldr on x86-64,"
https://bugzilla.mozilla.org/show_bug.cgi?id=1539399, 2019.
[57] N. Goonasekera, W. Caelli, and C. Fidge, "LibVM: an architecture
for shared library sandboxing," vol. 45, no. 12, pp. 1597–1617, 2015.
[Online]. Available: https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.
2294
[58] A. Bittau, P. Marchenko, M. Handley, and B. Karp, "Wedge: Splitting
applications into reduced-privilege compartments," in 5th USENIX
Symposium on Networked Systems Design & Implementation, NSDI
2008, April 16-18, 2008, San Francisco, CA, USA, Proceedings,
J. Crowcroft and M. Dahlin, Eds. USENIX Association, 2008, pp.
309–322. [Online]. Available: http://www.usenix.org/events/nsdi08/tech/
full_papers/bittau/bittau.pdf
[59] J. Litton, A. Vahldiek-Oberwagner, E. Elnikety, D. Garg, B. Bhattacharjee,
and P. Druschel, "Light-weight contexts: An os abstraction for safety
and performance," in Proceedings of the 12th USENIX Conference on
Operating Systems Design and Implementation, ser. OSDI'16. USENIX
Association, 2016, p. 49–64.
[60] Y. Chen, S. Reymondjohnson, Z. Sun, and L. Lu, "Shreds: Fine-grained
execution units with private memory," in 2016 IEEE Symposium on
Security and Privacy (SP), 2016, pp. 56–71.
[61] B. Zeng, G. Tan, and G. Morrisett, "Combining control-flow integrity
and static analysis for efficient and validated data sandboxing,"
in Proceedings of the 18th ACM Conference on Computer and
Communications Security, ser. CCS '11. New York, NY, USA:
Association for Computing Machinery, 2011, p. 29–40. [Online].
Available: https://doi.org/10.1145/2046707.2046713
[62] E. Johnson, D. Thien, Y. Alhessi, S. Narayan, F. Brown, S. Lerner,
T. McMullen, S. Savage, and D. Stefan, "Trust, but verify: SFI safety
for native-compiled Wasm," in Network and Distributed System Security
Symposium (NDSS). Internet Society, February 2021.
[63] J. A. Kroll, G. Stewart, and A. W. Appel, "Portable software fault
isolation," in 2014 IEEE 27th Computer Security Foundations Symposium.
IEEE, 2014, pp. 18–32.
[64] W. Qiang, Y. Cao, W. Dai, D. Zou, H. Jin, and B. Liu, "Libsec:
A hardware virtualization-based isolation for shared library," in 2017
IEEE 19th International Conference on High Performance Computing
and Communications; IEEE 15th International Conference on Smart
City; IEEE 3rd International Conference on Data Science and Systems
(HPCC/SmartCity/DSS), 2017, pp. 34–41.
[65] A. Belay, A. Bittau, A. Mashtizadeh, D. Terei, D. Mazières, and
C. Kozyrakis, "Dune: Safe user-level access to privileged cpu features,"
in Proceedings of the 10th USENIX Conference on Operating Systems
Design and Implementation, ser. OSDI'12. USA: USENIX Association,
2012, p. 335–348.
[66] D. Schrammel, S. Weiser, S. Steinegger, M. Schwarzl, M. Schwarz,
S. Mangard, and D. Gruss, "Donky: Domain keys – efficient
in-process isolation for risc-v and x86," in 29th USENIX Security
Symposium (USENIX Security 20). USENIX Association, Aug. 2020,
pp. 1677–1694. [Online]. Available: https://www.usenix.org/conference/
usenixsecurity20/presentation/schrammel

[67] P. A. Karger, "Using registers to optimize cross-domain call
performance," in Proceedings of the Third International Conference
on Architectural Support for Programming Languages and Operating
Systems, ser. ASPLOS III. New York, NY, USA: Association
for Computing Machinery, 1989, p. 194–204. [Online]. Available:
https://doi.org/10.1145/70082.68201
[68] L. Skorstengaard, D. Devriese, and L. Birkedal, "StkTokens: enforcing
well-bracketed control flow and stack encapsulation using linear
capabilities," Proceedings of the ACM on Programming Languages,
vol. 3, no. POPL, pp. 1–28, Jan. 2019. [Online]. Available:
http://dl.acm.org/citation.cfm?doid=3302515.3290332
[69] R. N. M. Watson, J. Woodruff, P. G. Neumann, S. W. Moore, J. Anderson,
D. Chisnall, N. Dave, B. Davis, K. Gudka, B. Laurie, S. J. Murdoch,
R. Norton, M. Roe, S. Son, and M. Vadera, "Cheri: A hybrid capabilitysystem architecture for scalable software compartmentalization," in 2015
IEEE Symposium on Security and Privacy, 2015, pp. 20–37.
[70] M. Aiken, M. Fähndrich, C. Hawblitzel, G. Hunt, and J. Larus,
"Deconstructing process isolation," in Workshop on Memory system
performance and correctness, 2006.
[71] M. Fähndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. Hunt, J. R.
Larus, and S. Levi, "Language support for fast and reliable messagebased communication in Singularity OS," in EuroSys. ACM, 2006.
[72] G. Morrisett, D. Walker, K. Crary, and N. Glew, "From System F
to Typed Assembly Language," ACM Transactions on Programming
Languages and Systems, vol. 21, pp. 527–568, May 1999. [Online].
Available: https://doi.org/10.1145/319301.319345
[73] G. Morrisett, K. Crary, N. Glew, and D. Walker, "StackBased Typed Assembly Language," Journal of Functional
Programming, vol. 12, pp. 43–88, Jan. 2002, publisher:
Cambridge
University
Press.
[Online].
Available:
https:
//www.cambridge.org/core/journals/journal-of-functional-programming/
article/abs/stackbased-typed-assembly-language/
FAA86C307845C6E28B88F57EE64C6F3B
[74] "x64 calling convention," Tech. Rep., 2020. [Online]. Available: https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?
view=msvc-160

16

A PPENDIX A
L ANGUAGE D EFINITIONS

Figure 10 presents the syntax of our sandbox language model. For all programs we define the regions M , Mp , Hp , Sp , Cp ,
and I. M = N and represents the whole memory space. Mp , Hp , and Sp are the memory, heap, and stack of the application or
library where the heap and stack sit disjointly inside the memory. Cp is set of instruction indices such that C(n) = (p, _). I is
the set of import indices, the beginnings of application functions that the library is allowed to jump to.
A note on calling convention: arguments are passed on the stack and the return address is placed above the arguments. When
the application passes arguments to the library it marks their integrity as lib.

Priv
Val
Reg
Check
Immediate
Command

3
3
3
3
3
3

pc, sp, n, `
p
v
r
k
i
c

Code
RegVals
Memory
State

3
3
3
3

C
R
M
Ψ

∈
::=
::=
::=
∈
::=
::=
|
|
|
|
|
|
|
|
|
|
|
::=
::=
::=
::=
|

N
app | lib
hn, pi
rn | sp | pc
N*N
r |v |i⊕i
r ← popp
pushp i
r ← loadk i
storek i := i
r ← mov i
callk i
retk
jmpk i
r ← movlabelp
storelabelp i
gatecalln i
gateret
N * Priv × Command
Reg → Val
N → Val
error
{ pc : N
sp : N
R : RegVals
M : Memory
C : Code
}

Figure 10: Syntax

Figure 11 and Figure 13 define the base small step operational semantics. We separate this into transitions ΨLcM → Ψ0 and
error transitions ΨLcM → error.

17

ΨLcM → Ψ0
v = VΨ (i)
sp0 = Ψ.sp + 1
0
M = Ψ.M [sp 7→ v]
sp0 ∈ Sps
ps v p
++
ΨLpushp iM → Ψ [sp := sp0 , M := M 0 ]

Ψ.sp ∈ Sps
ps v p
v = Ψ.M (Ψ.sp)
R0 = R[r 7→ v]
ΨLr ← popp M → Ψ++ [sp := Ψ.sp − 1, R := R0 ]
hni = VΨ (i)
n0 = k(n)
0
0
v = Ψ.M (n )
R = Ψ.R[r 7→ v]
ΨLr ← loadk iM → Ψ++ [R := R0 ]

0

hni = VΨ (i)
v = VΨ (i0 )
0
n = k(n)
M = Ψ.M [n0 7→ v]
ΨLstorek i := i0 M → Ψ++ [M := M 0 ]
0

M 0 = Ψ.M [n := hm, pi]
hni = VΨ (i)
hmi = Ψ.M (n)
ΨLstorelabelp iM → Ψ++ [M := M 0 ]
hni = VΨ (i)
n0 = k(n)
ΨLjmpk iM → Ψ[pc := n0 ]

v = VΨ (i)
R0 = Ψ.R[r 7→ v]
ΨLr ← mov iM → Ψ++ [R := R0 ]

hni = VΨ (i)
n0 = k(n)
sp0 = Ψ.sp + 1
0
0
M = Ψ.M [sp 7→ hΨ.pc + 1, libi]
sp0 ∈ Sps
ΨLcallk iM → Ψ[pc := n0 , sp := sp0 , M := M 0 ]

hni = Ψ.M (Ψ.sp)
n0 = k(n)
Ψ.sp ∈ Sps
ΨLretk M → Ψ[pc := n0 , sp := Ψ.sp − 1]

hni = Ψ.R(r)
R0 = Ψ.R[r := hn, pi]
ΨLr ← movlabelp M → Ψ++ [R := R0 ]

hvi = VΨ (i)
ΨLsp ← mov iM → Ψ++ [sp := v]
Figure 11: Operational Semantics
ΨLcM → error
Ψ.sp ∈ Sps
ps 6v p
ΨLr ← popp M → error
hni = VΨ (i)
k(n) undefined
ΨLstorek i := i0 M → error

Ψ.sp + 1 ∈ Sps
ps 6v p
ΨLpushp iM → error
Ψ.sp + 1 ∈
/ Sps
ΨLcallk iM → error

hni = VΨ (i)
k(n) undefined
ΨLr ← loadk iM → error

hni = VΨ (i)
k(n) undefined
ΨLcallk iM → error

Ψ.sp ∈
/ Sps
ΨLretk M → error

hni = VΨ (i)
k(n) undefined
ΨLjmpk iM → error

hni = Ψ.M (Ψ.sp)
k(n) undefined
ΨLretk M → error

Figure 12: Operational Semantics

C(Ψ.pc) = (_, c)
ΨLcM

Ψ → ∗ Ψ0
¬∃Ψ . Ψ → Ψ00
Ψ0 6= error
Ψ ⇓ Ψ0
00

C(Ψ.pc) = (p, c)
ΨLcMp
VΨ (v)
VΨ (r)
VΨ (sp)
VΨ (pc)
VΨ (i ⊕ i0 )

,
,
,
,
,

0

v
Ψ.R(r)
hΨ.sp, libi
hΨ.pc, libi
hv ⊕ v 0 , p u p0 i
where hv, pi = VΨ (i)
hv 0 , p0 i = VΨ (i0 )

hni , hn, _i
Ψ++ , Ψ[pc := Ψ.pc + 1]
Figure 13: Operational Semantics: Auxiliary Definitions

18

lib v app

Figure 14 defines unguarded derived forms for memory operations.

r ← pop
push i
r ← load i
store i := i0
jmp i
call i
ret

,
,
,
,
,
,
,

r ← pop>
push> i
r ← loadid i
storeid i := i0
jmpid i
callid i
retid

Figure 14: Derived Forms
A. Sandbox Properties

Ψ1 → Ψ2
Ψ2 Lc2 Mp2



Ψ1 Lc1 Mp1
p1 = p2 = p

p

Ψ −→ Ψ

Ψ−
→ Ψ0

Ψ−
→ Ψ0

Ψ−
→Ψ

p



Ψ1 −
→ Ψ2

wb

0



0

Ψ → Ψ1 −
→∗ Ψ2 → Ψ0
ΨLgatecalln iM
Ψ2 LgateretM
wb

Ψ −→ Ψ0

Figure 15: Well-Bracketed Transitions
1) Integrity: Integrity is all about maintaining application invariants across calls into the sandbox. These invariants vary
significantly from program to program, so to capture this generality we define I-Integrity and then instantiate it in several
specific instances.
Definition 5 (I-Integrity).
wb
Let I : Trace × State × State → P. Then, if Ψ0 ∈ Program, π = Ψ0 →∗ Ψ1 , Ψ1 .p = app, and Ψ1 −→ Ψ2 imply that
I(π, Ψ1 , Ψ2 ), we say that an SFI transition system has I-integrity.
Informally, callee-save register integrity says that the values of callee-save registers are restored by gated calls into the
sandbox:
Definition 6 (Callee-Save Register Integrity).
Let CSR be the list of callee-save registers and define
CSR(_, Ψ1 , Ψ2 ) , Ψ1 .R(CSR) = Ψ2 .R(CSR).
If an SFI transition system has CSR-integrity then we say the system has callee-save register integrity.

return-addressp : Trace → ℘(N)
∗

return-addressp (Ψ0 → ΨLcallk iMp → Ψ0 ) , return-addressp (Ψ0 →∗ Ψ) ∪ {Ψ.sp + 1}
return-addressp (Ψ0 →∗ ΨLretk Mp → Ψ0 ) , return-addressp (Ψ0 →∗ Ψ) − {Ψ.sp}

return-addressp (Ψ0 →∗ ΨLgatecalln iMp → Ψ0 ) , return-addressp (Ψ0 →∗ Ψ) ∪ {Ψ.sp + 1}
return-addressp (Ψ0 →∗ ΨLgateretMp → Ψ0 ) , return-addressp (Ψ0 →∗ Ψ) − {Ψ.sp}
return-addressp (Ψ0 →∗ ΨLcM → Ψ0 ) , return-addressp (Ψ0 →∗ Ψ)
return-addressp (Ψ0 →0 Ψ0 ) , ∅
Figure 16: Call stack return address calculation
Definition 7 (Return Address Integrity). Define
RA(π, Ψ1 , Ψ2 ) , (Ψ1 .M (return-addressapp (π)) = Ψ2 .M (return-addressapp (π))) ∧ (Ψ2 .sp = Ψ1 .sp) ∧ (Ψ2 .pc = Ψ1 .pc + 1)
If an SFI transition system has RA-integrity then we say the system has return address integrity.

19

2) Confidentiality: Let V be a map from some type A to Val . We then define V |lib as the following restriction of V :
(
n
when V (a) = hn, libi
V |lib (a) =
undefined otherwise
We then say that Ψ =lib Ψ0 if Ψ.R|lib = Ψ0 .R|lib and Ψ.M |lib = Ψ.M |lib where equality of partial functions requires that
they have the same domain. We then define two notions of observational equivalence.
Definition 8. We say Ψ =call n Ψ0 if
1) Ψ.M (Hlib ) = Ψ0 .M (Hlib )
2) Ψ.pc = Ψ0 .pc
3) Ψ.sp = Ψ0 .sp
4) For all i ∈ [1, n], there exists some n0 such that hn0 , libi = Ψ.M (Ψ.sp − i) = Ψ0 .M (Ψ.sp − i).
Second, let rret be the calling convention return register.
Definition 9. We say Ψ =ret Ψ0 if
1) Ψ.M (Hlib ) = Ψ0 .M (Hlib )
2) Ψ.pc = Ψ0 .pc
3) There exists some n such that hn, libi = Ψ.R(rret ) = Ψ0 .R(rret ).
Definition 10 (Disjoint Noninterference).
lib
If, for all Ψ0 ∈ Program, Ψ1 L_Mlib , Ψ3 L_Mapp , Ψ0 →∗ Ψ1 −−→n Ψ2 → Ψ3 , and, for all Ψ01 such that Ψ1 =lib Ψ01 , we have
lib
that Ψ01 −−→n Ψ02 → Ψ03 , Ψ03 L_Mapp , Ψ3 .pc = Ψ03 .pc, and
1) Ψ2 Lgatecalln0 iM, Ψ02 Lgatecalln0 iM, and Ψ3 =call n0 Ψ03 or
2) Ψ2 LgateretM, Ψ02 LgateretM, and Ψ3 =ret Ψ03 ,
then we say that the SFI transition system has the disjoint noninterference property.
A PPENDIX B
N AC L
NaCl context in application
ctx − 0
library stack pointer
...
ctx∗
ctx
NaCl context in library
ctx − 0
application stack pointer
ctx − 1
CSR0
CSR1
ctx − 2
...
...
ctx − len(CSR)
CSRlen(CSR)−1
...
ctx∗
ctx
Figure 17: Transition Context Layout
nacl-springboard(n, i) ,
r0 ← load ctx∗
r1 ← load r0
j ∈ (len(CSR), 0] store r0 := CSRj ; r0 ← r0 + 1
r1 ← r1 + n
sp ← sp − 1
j ∈ [0, n) r2 ← pop; storeMlib r1 := r2 ; r1 ← r1 − 1
r2 ← sp + (n + 1); store r0 := r2
sp ← r1 + n
store ctx∗ := r0
r ∈ R r ← mov h0, libi
jmp i

20

//
//
//
//
//
//
//
//
//

r1 holds the library stack pointer
save callee save registers
set r1 to the new top of the library stack
move the stack pointer to the first argument
copy arguments to library stack
save stack pointer
set new stack pointer
update ctx
clear registers

nacl-trampoline ,
j ∈ [0, len(CSR))

r0 ← load ctx∗
r0 ← r0 − 1; CSRj ← load r0
r0 ← load ctx∗
r1 ← load r0
r0 ← r0 − len(CSR); store r0 := sp
store ctx∗ := r0
sp ← mov r1
ret

nacl-cb-springboard(n, i) ,
r0 ← load ctx∗
r1 ← load r0
r0 ← r0 + 1; store r0 := sp
store ctx∗ := r0
sp ← sp − 1
r1 ← r1 + n
j ∈ [0, n) r2 ← popMlib ; store r1 := r2 ; r1 ← r1 − 1
sp ← r1 + n
jmpI i
nacl-cb-trampoline ,
r0 ← load ctx∗
r1 ← load r0
r0 ← r0 − 1; store ctx∗ := r0
sp ← mov r1
r ∈ R r ← mov h0, libi
retClib

//
//
//
//
//
//
//

//
//
//
//

// restore callee save registers
//
//
//
//

r1 holds the application stack pointer
save library stack pointer
update ctx
switch to application stack

r1 holds the application stack pointer
save stack pointer
update ctx
move the stack pointer to the first argument
set r1 to the new top of the library stack
copy arguments to application stack
set new stack pointer

r1 holds the library stack pointer
update ctx
switch to library stack
clear registers

A. Programs
A NaCl program Ψ is defined by the following conditions:
1) All memory operations in the sandboxed library are guarded:
∀n.Ψ.C(n) = (lib, r ← popp ) =⇒ p = lib
Ψ.C(n) = (lib, pushp i) =⇒ p = lib
Ψ.C(n) = (lib, r ← loadchk i) =⇒ chk ⊆ Mlib
Ψ.C(n) = (lib, storechk i := i) =⇒ chk ⊆ Mlib .
2) The application does not write app data to the sandbox memory.
3) Gated calls are the only way to move between application and library code:
∀n.Ψ.C(n) = (p, callchk i) =⇒ chk ⊆ Cp
Ψ.C(n) = (p, retchk ) =⇒ chk ⊆ Cp
Ψ.C(n) = (p, jmpchk i) =⇒ chk ⊆ Cp
4) The sandboxed library cannot change integrity labels:
∀n.Ψ.C(n) 6= (lib, r ← movlabelp )
Ψ.C(n) 6= (lib, storelabelp i).
5) The program starts in the application: Ψ.pc = 0 and Ψ.C(0) = (app, _).
6) ctx∗ and ctx start initialized to the library stack:
ctx∗ ∈ Happ
hctxi = Ψ.M (ctx∗ ) ∈ Happ
Ψ.M (ctx) = Slib [0] − 1.

21

B. Properties
Throughout the following we will use the shorthand ctxΨ , Ψ.M (ctx∗ ).
Proposition 1. NaCl has the disjoint noninterference property.
Proof. Follows immediately from the fact that all reads and writes are guarded to be within Mlib , all values in Mlib have
label lib, and all jumps remain within the library code.
Lemma 1. The trampoline context is in Happ .
Lemma 2. ctx ≥ ctx0 .
p

Lemma 3. If Ψ1 LcMlib and Ψ1 −
→∗ Ψ2 , then Ψ00 .Mapp = Ψ0 .Mapp .

Proof. There are two cases for p: p = app and p = lib. If p = app, then Ψ2 = Ψ1 and therefore trivially Ψ2 .Mapp = Ψ1 .Mapp .
If p = lib, then for all Ψ such that Ψ1 →∗ Ψ →+ Ψ2 , Ψ.C(Ψ.pc) = (lib, _). By the structure of a NaCl program, this
ensures that Ψ2 .Mapp = Ψ1 .Mapp .
p

Lemma 4. If Ψ −
→∗ Ψ0 then Ψ.p = Ψ0 .p.
wb

Lemma 5. If Ψ −→ Ψ0 where Ψ →∗ Ψ00 → Ψ0 , then Ψ00 .p 6= Ψ.p and Ψ0 .p = Ψ.p.
wb

wb

Proof. We proceed by simultaneous induction on the well-bracketed transition Ψ −→ Ψ0 and the length of Ψ0 →∗ Ψ −→ Ψ0 .
Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM.
00
Here Ψ = Ψ2 . By inspection of the reduction for gatecalln i we know that Ψ1 .p 6= Ψ.p and therefore by Lemma 4
Ψ00 .p 6= Ψ.p. By inspection of the reduction for gateret, Ψ0 .p = Ψ.p.
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. Here
00
Ψ = Ψ2 . By inspection of the reduction for gatecalln i we know that Ψ1 .p 6= Ψ.p. We now show, by induction on
 ∗
Ψ1 −
→ Ψ2 , that Ψ2 .p = Ψ1 .p 6= Ψ.p.




Proof. If there are no steps then clearly Ψ2 .p = Ψ1 .p 6= Ψ.p. There are two possible cases for Ψ1 −
→∗ Ψ3 −
→ Ψ4 . When
p
wb
Ψ3 −
→ Ψ4 , Lemma 4 gives us that Ψ4 .p = Ψ3 .p = Ψ1 .p 6= Ψ.p. When Ψ3 −→ Ψ4 , our outer inductive hypothesis gives us
that Ψ4 .p = Ψ3 .p = Ψ1 .p 6= Ψ.p.

0
Lastly, by inspection of the reduction for gateret, Ψ .p = Ψ.p.


Lemma 6. If Ψ −
→∗ Ψ0 , then Ψ0 .p = Ψ.p.
Proof. By induction, Lemma 4, and Lemma 5.
wb

Lemma 7 (Context Integrity). Let Ψ0 ∈ Program, Ψ0 →∗ Ψ, and Ψ −→ Ψ0 . Then
1) if Ψ.p = app, then Ψ.M ([ctxΨ0 , ctxΨ )) = Ψ0 .M ([ctxΨ0 , ctxΨ0 )) and ctxΨ = ctxΨ0 ,
2) if Ψ.p = lib, then Ψ.M ([ctxΨ0 , ctxΨ ]) = Ψ0 .M ([ctxΨ0 , ctxΨ0 ]) and ctxΨ = ctxΨ0 .
wb

Proof. We proceed by mutual, simultaneous induction on the well-bracketed transition Ψ1 −→ Ψ2 and the length of Ψ0 →∗
wb
Ψ −→ Ψ0 .
First we consider the case where ΨLcMapp .
Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM.
By Lemma 3 we have that Ψ1 .Mapp = Ψ2 .Mapp . By assumption we have that ΨLgatecalln iMapp and therefore by
Lemma 5 we have that Ψ2 LgateretMlib . By Lemma 1, Lemma 2, and inspection of the reduction rules for gatecalln i
and gateret we have that Ψ.M ([ctxΨ0 , ctxΨ )) = Ψ0 .M ([ctxΨ0 , ctxΨ0 )) and ctxΨ = ctxΨ0 .
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we have that ctxΨ1 = ctxΨ + len(CSR). We now show, by induction on
 ∗
Ψ1 −
→ Ψ2 , that ctxΨ2 = ctxΨ1 and Ψ1 .M ([ctxΨ0 , ctxΨ1 ]) = Ψ2 .M ([ctxΨ0 , ctxΨ2 ]).
Proof. If there are no steps then clearly ctxΨ2 = ctxΨ1 and all of Ψ1 .Mapp = Ψ2 .Mapp . There are two possible cases
p
 ∗

for Ψ1 −
→ Ψ3 −
→ Ψ4 , and notice that in both Ψ3 .p = Ψ1 .p = lib (by Lemma 6). When Ψ3 −
→ Ψ4 , Lemma 3 gives

22

wb

us that Ψ3 .Mapp = Ψ4 .Mapp and then Lemma 1 gives us that ctxΨ4 = ctxΨ3 = ctxΨ1 . When Ψ3 −→ Ψ4 , case 2
of our inductive hypothesis gives us that Ψ1 .M ([ctxΨ0 , ctxΨ1 ]) = Ψ3 .M ([ctxΨ0 , ctxΨ3 ]) = Ψ4 .M ([ctxΨ0 , ctxΨ4 ]) and
ctxΨ4 = ctxΨ3 = ctxΨ1 .

Finally, by Lemma 6 we get that Ψ2 = lib and then inspection of the reduction rule for gateret gives us that
Ψ.M ([ctxΨ0 , ctxΨ )) = Ψ0 .M ([ctxΨ0 , ctxΨ0 )) and ctxΨ = ctxΨ0 .
Second we consider the case where ΨLcMlib .
Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM. By
the structure of a NaCl program we have that ctxΨ1 = ctxΨ2 and Ψ1 .M ([ctxΨ0 , ctxΨ1 ]) = Ψ2 .M ([ctxΨ0 , ctxΨ2 ]). By
assumption we have that ΨLgatecalln iMlib and therefore by Lemma 5 we have that Ψ2 LgateretMapp . By Lemma 2 and
inspection of the reduction rules for gatecalln i and gateret we have that Ψ.M ([ctxΨ0 , ctxΨ )) = Ψ0 .M ([ctxΨ0 , ctxΨ0 ))
and ctxΨ = ctxΨ0 .
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we have that ctxΨ1 = ctxΨ + 1. We now show, by induction on
 ∗
Ψ1 −
→ Ψ2 , that ctxΨ2 = ctxΨ1 and Ψ1 .M ([ctxΨ0 , ctxΨ1 )) = Ψ2 .M ([ctxΨ0 , ctxΨ2 )).
Proof. If there are no steps then clearly ctxΨ2 = ctxΨ1 and all of Ψ1 .Mapp = Ψ2 .Mapp . There are two possible cases
p
 ∗

for Ψ1 −
→ Ψ3 −
→ Ψ4 , and notice that in both Ψ3 .p = Ψ1 .p = app (by Lemma 6). When Ψ3 −
→ Ψ4 , the structure of a
wb
NaCl program gives us that ctxΨ1 = ctxΨ2 and Ψ1 .M ([ctxΨ0 , ctxΨ1 ]) = Ψ2 .M ([ctxΨ0 , ctxΨ2 ]). When Ψ3 −→ Ψ4 , case
1 of our inductive hypothesis gives us that Ψ1 .M ([ctxΨ0 , ctxΨ1 )) = Ψ3 .M ([ctxΨ0 , ctxΨ3 )) = Ψ4 .M ([ctxΨ0 , ctxΨ4 )) and
ctxΨ4 = ctxΨ3 = ctxΨ1 .

Finally, by Lemma 6 we get that Ψ2 = app and then inspection of the reduction rule for gateret gives us that
Ψ.M ([ctxΨ0 , ctxΨ ]) = Ψ0 .M ([ctxΨ0 , ctxΨ0 ]) and ctxΨ = ctxΨ0 .
Proposition 2. NaCl has callee-save register integrity.
Proof. Follows from Lemma 7, Lemma 5, and inspection of the reduction rules for gatecalln i and gateret.
Lemma 8. Let Ψ0 ∈ Program, π
Ψ.M (return-addressapp (π)).

=

Ψ0

→∗

Ψ, and Ψ

wb

−→

Ψ0 , then Ψ0 .M (return-addressapp (π))

=

Proof. First we consider the case where ΨLcMapp .
Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we see that Ψ1 .M (Ψ.sp + 1) = Ψ.pc + 1. This is adding to the top of the
stack, so by the structure of a NaCl program we have that Ψ1 .M (return-addressapp (π)) = Ψ.M (return-addressapp (π)).
By Lemma 3 we have that Ψ1 .Mapp = Ψ2 .Mapp and therefore Lemma 1 gives us that ctxΨ2 = ctxΨ1 and
Ψ2 .M (return-addressapp (π)) = Ψ1 .M (return-addressapp (π)). If we inspect the trampoline code we see that, right
before we execute the ret, we have set sp to Ψ2 .M (ctxΨ2 ) = Ψ1 .M (ctxΨ1 ) = Ψ.sp + 1. Thus, after returning the
only part of the application stack that we modify is Ψ.sp + 1. This, and the fact that Ψ2 .M (return-addressapp (π)) =
Ψ.M (return-addressapp (π)) gives us that Ψ.M (return-addressapp (π)) = Ψ0 .M (return-addressapp (π)).
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we see that Ψ1 .M (Ψ.sp + 1) = Ψ.pc + 1. This is adding to the top of the
stack, so by the structure of a NaCl program we have that Ψ1 .M (return-addressapp (π)) = Ψ.M (return-addressapp (π)).
 ∗
We now show, by induction on Ψ1 −
→ Ψ2 that Ψ2 .M (ctxΨ2 ) = Ψ.sp + 1 and Ψ2 .M (return-addressapp (π)) =
Ψ1 .M (return-addressapp (π)).


Proof. If there are no steps then Ψ2 = Ψ1 and both goals hold immediately. There are two possible cases for Ψ1 −
→∗
p

Ψ3 −
→ Ψ4 and notice that in both Ψ3 .p = Ψ1 .p = lib (by Lemma 6). If Ψ3 −
→ Ψ4 then Lemma 3 gives us that
wb
Ψ4 .Mapp = Ψ3 .Mapp and our goal holds (as all of return-addressapp (π) is in Sapp ). If Ψ3 −→ Ψ4 , then Lemma 7
gives us that ctxΨ3 = ctxΨ4 and Ψ3 .M ([ctxΨ0 , ctxΨ3 ]) = Ψ4 .M ([ctxΨ0 , ctxΨ4 ]) and therefore that Ψ4 .M (ctxΨ4 ) =
Ψ.sp + 1. return-addressapp (Ψ0 →∗ Ψ3 ) = return-addressapp (π) ] Ψ.sp + 1, so our inductive hypothesis gives us that
Ψ4 .M (return-addressapp (π)) = Ψ3 .M (return-addressapp (π)).

Second we consider the case where ΨLcMlib .

23

Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we see that Ψ1 .M (return-addressapp (π)) = Ψ.M (return-addressapp (π)).
By the structure of a NaCl program we have that any call stack elements that are added during the callback will
be popped before the gateret. Thus, Ψ2 .M (return-addressapp (π)) = Ψ1 .M (return-addressapp (π)). Inspection of
the reduction rule for gateret then gives us that Ψ0 .M (return-addressapp (π)) = Ψ2 .M (return-addressapp (π)) =
Ψ.M (return-addressapp (π)).
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. By inspection
of the reduction rule for gatecalln i we see that Ψ1 .M (return-addressapp (π)) = Ψ.M (return-addressapp (π)). We now
 ∗
show, by induction on Ψ1 −
→ Ψ2 that Ψ2 .M (return-addressapp (π)) = Ψ1 .M (return-addressapp (π)).




→∗ Ψ3 −
→
Proof. If there are no steps then Ψ2 = Ψ1 and the goal holds immediately. There are two possible cases for Ψ1 −
p
→ Ψ4 then the structure of a NaCl program gives
Ψ4 and notice that in both Ψ3 .p = Ψ1 .p = app (by Lemma 6). If Ψ3 −
us that any call stack elements that are added during the callback will be popped before the gateret, and therefore our
wb
inductive invariant is maintained. If Ψ3 −→ Ψ4 , then notice that return-addressapp (Ψ0 →∗ Ψ3 ) = return-addressapp (π),
so our inductive hypothesis gives us that Ψ4 .M (return-addressapp (π)) = Ψ3 .M (return-addressapp (π)).

Inspection of the reduction rule for gateret then
Ψ2 .M (return-addressapp (π)) = Ψ.M (return-addressapp (π)).

gives

us

that

Ψ0 .M (return-addressapp (π))

=

Proposition 3. NaCl has return address integrity.
wb

Proof. We have that Ψ0 ∈ Program, π = Ψ0 →∗ Ψ, Ψ.p = app, and Ψ −→ Ψ0 and wish to show that
Ψ.M (return-addressapp (π)) = Ψ0 .M (return-addressapp (π)), Ψ0 .sp = Ψ.sp, and Ψ0 .pc = Ψ.pc + 1.
Lemma 8 gives us that Ψ.M (return-addressapp (π)) = Ψ0 .M (return-addressapp (π)). We proceed by simultaneous induction
wb
wb
on the well-bracketed transition Ψ −→ Ψ0 and the length of Ψ0 →∗ Ψ −→ Ψ0 to show that Ψ0 .sp = Ψ.sp, and Ψ0 .pc = Ψ.pc + 1.
Case No callbacks
p
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 , and p such that Ψ → Ψ1 −
→∗ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we see that Ψ1 .M (Ψ.sp + 1) = Ψ.pc + 1 and Ψ1 .M (ctxΨ1 ) = Ψ.sp + 1.
By Lemma 3 we have that Ψ1 .Mapp = Ψ2 .Mapp and therefore Lemma 1 gives us that ctxΨ2 = ctxΨ1 . If we inspect the
trampoline code we see that, right before we execute the ret, we have set sp to Ψ2 .M (ctxΨ2 ) = Ψ1 .M (ctxΨ1 ) = Ψ.sp+1.
Thus, after returning we have that Ψ0 .pc = Ψ.pc + 1, Ψ0 .sp = Ψ.sp.
Case Callbacks
 ∗
We have that ΨLgatecalln iM and there exist Ψ1 , Ψ2 such that Ψ → Ψ1 −
→ Ψ2 → Ψ0 where Ψ2 LgateretM. By
inspection of the reduction rule for gatecalln i we see that Ψ1 .M (Ψ.sp + 1) = Ψ.pc + 1 and Ψ1 .M (ctxΨ1 ) = Ψ.sp + 1.
 ∗
We now show, by induction on Ψ1 −
→ Ψ2 that Ψ2 .M (Ψ.sp + 1) = Ψ.pc + 1 and Ψ2 .M (ctxΨ2 ) = Ψ.sp + 1.




Proof. If there are no steps then Ψ2 = Ψ1 and both hold immediately. There are two possible cases for Ψ1 −
→∗ Ψ3 −
→ Ψ4
p
and notice that in both Ψ3 .p = Ψ1 .p = lib (by Lemma 6). If Ψ3 −
→ Ψ4 then Lemma 3 gives us that Ψ4 .Mapp =
wb
Ψ3 .Mapp and both hold (as the invariants are on Mapp ). If Ψ3 −→ Ψ4 , then Lemma 7 gives us that ctxΨ3 = ctxΨ4 and
Ψ3 .M ([ctxΨ0 , ctxΨ3 ]) = Ψ4 .M ([ctxΨ0 , ctxΨ4 ]) and therefore that Ψ4 .M (ctxΨ4 ) = Ψ.sp + 1. return-addressapp (Ψ0 →∗
Ψ3 ) = return-addressapp (π) ] Ψ.sp + 1 so Lemma 8 gives us that Ψ4 .M (Ψ.sp + 1) = Ψ3 .M (Ψ.sp + 1) = Ψ.pc + 1. 
Finally, if we inspect the trampoline code we see that, right before we execute the ret, we have set sp to Ψ2 .M (ctxΨ2 ) =
Ψ.sp + 1. Thus, after returning we have that Ψ0 .pc = Ψ.pc + 1, Ψ0 .sp = Ψ.sp.

A PPENDIX C
OVERLAY S EMANTICS
Figure 19, Figure 20, and Figure 21 define the overlay monitor operational semantics.

24

Frame

3

SF

::=

Function

3

F

::=

oState

3

Φ

::=
|

{

: N
base
ret-addr -loc : N
: ℘(Reg × N) }
csr -vals
{ instrs : N * Command
entry : N
: N
type
}
oerror
: State
{ Ψ
funcs : N * Function
stack : [Frame]
}

Figure 18: Overlay Extended Syntax
ΨLcM

hn, pi i = VΦ (i)
n0 = k(n)
sp0 = Φ.sp + 1
M 0 = Φ.M [sp0 7→ Φ.pc + 1]
0
0
typechecks(Φ, n , sp )
SF = new-frame(Φ, n0 , sp0 )
pi v lib
0
ΦLcallk iMlib
Φ[stack := [SF ] ++ Φ.stack , pc := n , sp := sp0 , M := M 0 ]
is-ret-addr-loc(Φ, Φ.sp)
hni = Φ.M (Φ.sp)
n0 = k(n)
0
csr-restored(Φ)
Φ = pop-frame(Φ)
0
ΦLretk Mlib
Φ [pc := n0 , sp := Φ.sp − 1]
hn0 i = VΦ (i)
sp0 = Φ.sp + 1
M 0 = Φ.M [sp0 7→ Φ.pc + 1]
0
0
n ∈I
typechecks(Φ, n , sp )
args-secure(Φ, sp0 , n)
SF = new-frame(Φ, n0 , sp0 )
ΦLgatecalln iMlib
Φ[stack := [SF ] ++ Φ.stack , pc := n0 , sp := sp0 , M := M 0 ]
0

hn0 i = VΦ (i)
sp0 = Φ.sp + 1
0
M = Φ.M [sp 7→ Φ.pc + 1]
SF = new-frame(Φ, n0 , sp0 )
ΦLgatecalln iMapp
Φ[stack := [SF ] ++ Φ.stack , pc := n0 , sp := sp0 , M := M 0 ]
0

0

ΦLretM
Φ0
p0 v p
0
hn, p i = Φ.R(rret )
ΦLgateretMp
Φ0

hn, pi i = VΦ (i)
v = h_, pi0 i = VΦ (i0 )
0
0
M = Φ.M [n 7→ v]
writeable(Φ, n0 )
0
n = k(n)
pi v p
pi0 6v p =⇒ n0 ∈
/ Hlib
++
0
ΦLstorek i := i Mp
Φ [M := M 0 ]

0

v = VΦ (i)
sp = Φ.sp + 1
sp ∈ Sp
M 0 = Φ.M [sp0 7→ v]
writeable(Φ, sp0 )
ΦLpushp iM
Φ++ [sp := sp0 , M := M 0 ]
hn, pi i = VΦ (i)
n0 = k(n)
pi v p
0
v = h_, pn0 i = Φ.M (n )
R0 = Φ.R[r 7→ v]
ΦLr ← loadk iMp
Φ++ [R := R0 ]

hv, pi i = VΦ (i)
ΦLsp ← mov iMp

Φ

vp
[sp := v]

pi
++

pr 6v p0 =⇒ pr v p
hn, pr i = Φ.R(r)
R0 = Φ.R[r := hn, p0 i]
ΦLr ← movlabelp0 Mp
Φ++ [R := R0 ]

hn, pi i = VΦ (i)
n0 = k(n)
pi v p
in-same-func(Φ, Φ.pc, n0 )
ΦLjmpk iMp
Φ[pc := n0 ]

hn, pi i = VΦ (i)
hm, pm i = Φ.M (n)
pi v p
M 0 = Φ.M [n := hm, p0 i]
pm 6v p0 =⇒ pm v p
ΦLstorelabelp0 iMp
Φ++ [M := M 0 ]

Φ.ΨLcM → Ψ0
in-same-func(Φ, Φ.Ψ.pc, Ψ0 .pc)
ΦLcM
Φ[Ψ := Ψ0 ]

Figure 19: Overlay Operational Semantics

25

Ψ0

F = Φ.funcs(target)
F.entry = target
sp ∈ Sp
[SF ] ++ _ = Φ.stack
sp ≥ SF .ret-addr -loc + F .type
typechecks(Φ, target, sp)

[SF ] ++ _ = Φ.stack
n ∈ Sp =⇒ n ≥ SF .base ∧ n 6= SF .ret-addr -loc
writeable(Φ, n)
[SF ] ++ _ = Φ.stack
ret-addr -loc = SF .ret-addr -loc
is-ret-addr-loc(Φ, ret-addr -loc)

[SF ] ++ _ = Φ.stack
∀(r, n) ∈ SF .csr -vals. Φ.R(r) = n
csr-restored(Φ)

∀F ∈ cod(Φ.funcs). n ∈
/ dom(F .instrs)
in-same-func(Φ, n, n0 )

F ∈ cod(Φ.funcs)
n, n0 ∈ dom(F .instrs)
in-same-func(Φ, n, n0 )

∀i ∈ [1, n]. Φ.M (sp − i) = h_, libi
args-secure(Φ, sp, n)

Figure 20: Overlay Operational Semantics: Auxiliary Judgments

new-frame(Φ, target, ret-addr -loc) ,

pop-frame(Φ) ,
Φ++

,

{

= ret-addr -loc − Φ.funcs(target).type
= ret-addr -loc
= {(r, Φ.R(r))}r∈CSR

base
ret-addr -loc
csr -vals

}

Φ[stack := S] where [SF ] ++ S = Φ.stack
(
Φ[Ψ := Ψ++ ]
error

in-same-func(Φ, Φ.pc, Φ.pc + 1)
otherwise

Figure 21: Overlay Operational Semantics: Auxiliary Definitions
Lemma 9 (Overlay is a refinement). For any Φ

Φ0 , if Φ0 6= oerror, then Φ.Ψ → Φ0 .Ψ
app

Lemma 10 (Overlay is equivalent on application reduction). For any Φ, if Φ.Ψ −−→ Ψ0 , then Φ
Φ.funcs, stack := Φ.stack }.
Theorem 4 (Overlay Integrity Soundness). If Φ0 ∈ Program, Φ0
with π = Φ0 .Ψ →n Φ1 .Ψ, then
1) CSR(π, Φ1 .Ψ, Φ2 .Ψ)
2) RA(π, Φ1 .Ψ, Φ2 .Ψ)

n

Φ1 , Φ1 L_Mapp , and Φ1

∗

{Ψ := Ψ0 , funcs :=
wb

Φ2 such that Φ1 .Ψ −→ Φ2 .Ψ

Proof. By induction over the definition of a well-bracketed step and nested induction over the logical call stack. The last step
follows by the fact that Φ2 6= oerror, and therefore the restoration checks in the overlay monitor passed.
lib

Theorem 5 (Overlay Confidentiality Soundness). If Φ0 ∈ Program, Φ1 L_Mlib , Φ3 L_Mapp , Φ0 .Ψ →∗ Φ1 .Ψ −−→n Φ2 .Ψ → Φ3 .Ψ,
lib
Φ1 n+1 Φ3 , and Φ1 =lib Φ01 , then Φ01 .Ψ −−→n Φ02 .Ψ → Φ03 .Ψ, Φ01 n+1 Φ03 Φ03 L_Mapp , Φ3 .pc = Φ03 .pc, and
1) Φ2 Lgatecalln0 iM, Φ02 Lgatecalln0 iM, and Φ3 =call n0 Φ03 or
2) Φ2 LgateretM, Φ02 LgateretM, and Φ3 =ret Φ03 ,
Proof. Proof is standard for an IFC enforcement system.

A PPENDIX D
W EBA SSEMBLY

0

ΨLcall iM → Ψ
ΨLgatecalln iMapp → Ψ0 [p := lib]

0

ΨLcallI iM → Ψ
ΨLgatecalln iMlib → Ψ0 [p := app]

Figure 22: WebAssembly Trampoline and Springboard

26

ΨLretM → Ψ0
p = lib ⇔ p = app
ΨLgateretMp → Ψ0 [p := app]
0

sp −→

current block spill slots
...
function locals
...
saved CSR
...
return address
arguments
...

Figure 23: WebAssembly Stack Frame

WebAssemblyFunction

WF

::=

Block

B

::=

Indirect Block

IB

::=

{

:
|args|
|locals| :
:
entry
:
exits
blocks :
{ start
end
|slots|
inputs
indirects
:
{ start
:
end
parent :

N
N
Block
℘(Block)
℘(Block) }
: N
: N
: N
: ℘(N + Reg)
: ℘(IB)
}
N
N
Block }

Figure 24: WebAssembly Structure
A compiled WebAssembly library is divided into disjoint functions F which have a fixed number of arguments and locals. Each
function is composed of a set of disjoint blocks B where the block's code is C([B.start, B.end]), with a distinguished entry
block and set of exit blocks. There are a fixed number of stack slots associated to each block along with a subset of the slots
or registers assigned as the inputs to the block. Each non-exit block is terminated (C(B.end)) by a branch or jump. The exit
blocks in a function are uniformly terminated by a retClib or gateret. To simplify things, we will assume that WebAssembly
functions cannot call a function whose exit blocks terminate in gateret and the application code always calls such a function.
Branches and jumps cannot appear anywhere except at the end of a block.
Call instructions only appear in a block within one of two sequences of instructions. The first correspond to direct calls in
WebAssembly:
sp ← sp + (F.|locals| + B.|slots|);
push arg1 ; * * * ; push argF 0 .|args| ;
call F 0 .entry.start;
sp ← sp − (F.|locals| + B.|slots| + F 0 .|args|)
The second correspond to indirect calls each of which have an associated expected type of the callee:
typecheck(r, |expected-args|);
sp ← sp + (F.|locals| + B.|slots|);
push arg1 ; * * * ; push arg|expected-args| ;
callT r;
sp ← sp − (F.|locals| + B.|slots| + |expected-args|)
T is the set of entry points to functions corresponding to the WebAssembly table used by this indirect call, and typecheck is
implementation specific code that checks that the function at the address in register r expects |expected-args|.
In both cases the call instruction can be replaced with a gated call instruction:

27

sp ← sp + (F.|locals| + B.|slots|);

typecheck(r, n);

push arg1 ; * * * ; push argn ;

sp ← sp + (F.|locals| + B.|slots|);

gatecalln v;

push arg1 ; * * * ; push argn ;

sp ← sp − (F.|locals| + B.|slots| + n)

gatecalln r;
sp ← sp − (F.|locals| + B.|slots| + n)

v is an address in I that expects n arguments.
There are three kinds of memory accesses allowed within a block. Firstly, heap accesses which are guarded to be in the
sandboxed heap: r ← loadHlib i and storeHlib i := i0 . Secondly, argument, local, or variable accesses which are addressed by
constant offsets from the stack pointer; r ← load sp + x or store sp + x := i where x ∈ [−(CSR|F + F.|args|), −CSR|F ) ∪
[1, F.|locals| + B.|slots|]. Lastly, initializing a block's inputs before jumping. These immediately precede a constant branch
or jump instruction to some B 0 .start: store sp + x := i where x ∈ F.|locals| + B 0 .inputs. Any reads from stack slots or
registers are preceded by writes to that stack slot or register within the block or the stack slot or register is in the block's input
set B.inputs.
WebAssembly's indirect branches are compiled to an indirect jump to an Indirect Block (IB). These blocks are terminated by
a constant jump instruction to a block B and consist entirely of initializing the inputs to B. An indirect block IB may read
variables according to the rules of its parent block (IB.parent). As such an indirect jump at the end of a block B is guarded:
jmpB.indirects.start r.
Lastly, a WebAssembly function F 's entry block begins by pushing the subset of the callee-save registers in F.blocks (written
CSR|F ) and each exit block pops these back into their corresponding register.

A. Logical Relation

L

::=

{

interface
library
code

World ,

: N*N
: N * WasmFunction
: Code

}

N × (N * N) × (N * N)

. : World → World
.(0, fi , fl ) , (0, fi , fl )
.(n, fi , fl ) , (n − 1, fi , fl )
(C, F2 , F3 ) :W

, for i ∈ {1, 2} :
Fi .entry = dom(πi (W ))
∀Fi ∈ Fi . Fi .type = πi (W )(Fi .entry)
∀Fi ∈ Fi . (.W, Fi , C|Fi .instrs ) ∈ F

28

F

L

,

,





























∀ρ ∈ [Frame], ret-addr , A ∈ [N], sp, R, M, C, Fi , Fl .
let ρ0 = ρ ++ {base := sp − |A|, ret-addr -loc := sp, csr -vals := R(CSR)}
|A| = F .type
sp > top(ρ).ret-addr -loc + |A|
[sp 7→ ret-addr , (sp − |A| + i 7→ Ai )i∈[0,|A|) ] ≤ M
(C, Fi , Fl ) :W
c≤C
dom(c) = F .instrs
(W, F , c)


∀` ∈ dom(M ) ∩ Mlib . hn, libi = M (`)




let Ψ = {pc := F .entry, sp := sp, R := R, M := M, C := C}




let
Φ = {Ψ := Ψ, stack := ρ0 , funcs := [F 0 .entry 7→ F 0 ]F 0 ∈Fi ]Fl }




=⇒



ρ0 0


∀n0 ≤ W.n. Φ n Φ0 =⇒ Φ0 6= oerror


ρ0 0


or ∃n0 ≤ W.n. Φ n −1 Φ0
Φ00



0
0
where (Φ LretM ∨ Φ LgateretM) ∧ Φ0 .stack = ρ0 ∧ Φ00 6= oerror
















(n, L)

∀i ∈ dom(L.library).
let WF = L.library(i)
let W = (n, L.interface,
λi → L.library(i).|args|)
U
let instrs = B∈WF.blocks [B.start, B.end]
let F = {instrs := instrs, entry := WF.entry.start, type := WF.|args|}
(W, F , L.code|instrs ) ∈ F







































































Figure 25: Function and Library Relations
Lemma 11 (FTLR for functions). Let W ∈ World and c be the code for a compiled WebAssembly function WF such that WF
expects application functions
in the interface with locations and types π2 (W ) and in the library with locations and types π3 (W ).
U
Further let instrs = B∈WF.blocks [B.start, B.end] and F = {instrs := instrs, entry := WF.entry.start, type := WF.|args|}.
Then (W, F , c) ∈ F.
Proof. We first unroll the assumptions of (W, F , c) ∈ F reusing the variable names defined there. We will maintain that any
steps do not step to oerror so WOLOG
we will continually assume n0 ≤ W.n such that n0 greater than the number of steps
ρ 0 n0
we have taken, otherwise the case Φ
Φ0 =⇒ Φ0 6= oerror holds.
By the structure of a compiled WebAssembly function and assumption we have that the stack and stack pointer represent
WF.|args| arguments. The structure of an entry block means that we begin by pushing CSR ∩ Rc where Rc is all registers
mentioned in c. After this we generalize over which block in WF.blocks we are in, adding the antecedent that we do not touch
the return address or callee-save registers, and then continue with our proof. The structure of a compiled WebAssembly block
then lets us proceed until we reach one of 1) a function call to a library function WF0 such that WF0 .entry.start ∈ Fl .entry,
2) an application function F 0 such that F 0 .entry ∈ Fi .entry, 3) or the end of the block.
1) We have by assumption that we have pushed WF0 .|args| = π3 (W )(WF0 .entry.start) arguments or failed a dynamic
type check and terminated (thus stepping to a terminal state that is not an oerror). We thus set ρ2 = ρ0 and see that
we have constructed ρ02 = ρ2 ++ {base := sp − WF0 .|args|, ret-addr -loc := sp, csr -vals := R(CSR)}. We further set
ret-addr = pc + 1, A = WF0 .|args|, sp = sp, R = R, M = M , C = C, Fi = Fi , and Fl = Fl . By the structure of
compiled WebAssembly we have that all of the remaining checks in F pass and that the instantiated Φ is equal to our
current state. We therefore instantiate (.Fl , C|Fl .instrs ) ∈ F. If this uses the remaining steps then we are done. Otherwise
we get that we return to pc + 1 with all values restored and no new app values written to the library memory, and our
walk through the block may continue.
2) Identical to the case for (1).
3) The end of a block is followed by a direct jump to another block B 0 , an indirect block IB , or we are at an exit block. In
the case of another block B 0 we have by the structure of compiled WebAssembly code that we have instantiated B 0 .inputs.
We thus jump to the block and follow the same proof structure as detailed here. The same is true of an intermediate block
IB except with the extra steps of setting up the inputs jumping to another block B 00 . Lastly if we have reached the end of
an exit block then we have not touched the pushed return address or callee-save registers and the stack pointer is in the
expected location. We thus execute ret or gateret and pass the overlay monitor checks.

29

Lemma 12 (FTLR for libraries). For any number of steps n ∈ N and compiled WebAssembly library L, (n, L) ∈ L.
Proof. By unrolling the definition of L and Lemma 11
Theorem 6 (Adequacy of L). For any number of steps n ∈ N, library L such that (n, L) ∈ L, program Φ0 ∈ Program using
0
L, and n0 ≤ n, if Φ0 n Φ0 then Φ0 6= oerror.
Proof. Straightforward: by assumption for steps in the application, and by assumption about application code properly calling
the library code and the unrolling of L and F.

Normalized overhead

A PPENDIX E
L UCET I MAGE B ENCHMARKS
WasmLucet (Simple)
WasmLucet (Stock)
WasmLucet (Random)

8
6
4
2
500

1000
Image width (pixels)

1500

Figure 26: Performance of the WasmLucet heavyweight transitions included in the Lucet runtime on the image benchmarks
in Section VI. Performance when rendering (a) a simple image with one color, (b) a stock image and (c) a complex image with
random pixels. The performance is the overhead compared to WasmZero.

30

