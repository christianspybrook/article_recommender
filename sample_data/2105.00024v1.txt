arXiv:2105.00024v1 [cs.LO] 30 Apr 2021

Types Are Internal ∞-Groupoids
(Extended Version)
Eric Finster

Antoine Allioux

Matthieu Sozeau

Cambridge University
Department of Computer Science
ericfinster@gmail.com

Inria & IRIF, Université de Paris
France
antoine.allioux@irif.fr

Inria & LS2N, Université de Nantes
France
matthieu.sozeau@inria.fr

Abstract-By extending type theory with a universe of definitionally associative and unital polynomial monads, we show how
to arrive at a definition of opetopic type which is able to encode
a number of fully coherent algebraic structures. In particular,
our approach leads to a definition of ∞-groupoid internal to
type theory and we prove that the type of such ∞-groupoids is
equivalent to the universe of types. That is, every type admits
the structure of an ∞-groupoid internally, and this structure is
unique.

I. I NTRODUCTION
Homotopy Type Theory has brought a new perspective to
intensional Martin-Löf type theory: the higher identity types
of a type endow it with the structure of an ∞-groupoid, and
ideas from homotopy theory provide us with a means to predict
and understand the resulting tower of identifications. While
this perspective has been enormously clarifying with respect
to our understanding of the notion of proof-relevant equality,
leading, as it has, to a new class of models as well as new
computational principles, a number of difficulties remain in
order to complete the vision of type theory as a foundation
for a new, structural mathematics based on homotopy-theoretic
and higher categorical principles.
Foremost among these difficulties is the following: how does
one describe a well behaved theory of algebraic structures
on arbitrary types? The fundamental difficulty in setting up
such a theory is that, in a proof relevant setting, nearly all
of the familiar algebraic structures (monoids, groups, rings,
and categories, to take a few) become infinitary in their
presentation. Indeed, the axioms of these theories, which take
the form of a finite list of mere properties when the underlying
types are sets, constitute additional structure when they are no
longer assumed to be so. Consequently, in order to arrive at a
well-behaved theory, the axioms themselves must be subject
to additional axioms, frequently referred to generically as
"coherence conditions". In short, in a proof relevant setting, it
no longer suffices to describe the equations of an algebraic
structure at the "first level" of equality. Rather, we must
specify how the structure behaves throughout the entire tower
of identity types, and this is an infinite amount of data. How
do we organize and manipulate this data?
Similar problems have arisen in the mathematics of homotopy theory and higher category theory, and many solutions
and techniques are known. Bafflingly, however, all attempts to

import these ideas into plain homotopy type theory have, so
far, failed. This appears to be a result of a kind of circularity:
all of the known classical techniques at some point rely on
set-level algebraic structures themselves (presheaves, operads,
or something similar) as a means of presenting or encoding
higher structures. Internally to type theory, however, we do
not have recourse to such techniques. Indeed, without further
hypotheses, we do not even expect that the most basic objects
of the theory, types themselves, are presented by set-level
structures. This leaves us in a strange position: absent a theory
of algebraic structures, we have nothing to use to encode
algebraic structures!
We suggest that a possible explanation for this phenomenon
is the following: contrary to our experience with set-level
mathematics, where an algebraic structure (i.e. a "structured
set") can itself be defined just in terms of sets: underlying
sets, functions, sets of relations and so on, when we pass to
the world of homotopy theoretic mathematics, the notion of
type and structured type are simply no longer independent
of each other in the same way. Consequently, some primitive
notion of structured type must be defined at the same time as
the notion of type itself. The present work is a first attempt at
rendering this admittedly somewhat vague idea precise.
We begin by imagining a type theory which, in addition
to defining a universe U of types, defines at the same time
a universe S of structures. Of course, we will need to be
somewhat more precise about what exactly we mean by structure. Category theory suggests that one way of representing a
structure is by the monad on U which it defines, so we might
think of S as a universe of monads. In practice, however, it
will be useful to restrict to a particularly well behaved class of
monads, having reasonable closure properties, and for which
we have a good understanding of their higher dimensional
counterparts. We submit that a reasonable candidate for such a
well-behaved collection is the class of polynomial monads [1].
We feel that this is an appropriate class of structures for
a number of reasons. A first reason is that this class of
monads arises quite naturally in type theory already: indeed,
a large literature exists on the interpretation of inductive
and coinductive types as initial algebras and terminal coalgebras for polynomial monads, and we consider our work as
deepening and extending this connection. Furthermore, this
class of algebraic structures enjoys some pleasant properties

which make them particularly amenable to "weakening". For
example, the very general approach to weakening algebraic
structures developed by Baez and Dolan in [2] can be smoothly
adapted to the polynomial case. While the cited work employs
the language of symmetric operads, connections with the
theory of polynomial functors were already described in [3],
and moreover, recent work [4] has shown that, in type theory,
we should expect symmetric operads to in fact be subsumed
by the theory of polynomial monads.
The central intuition of Baez and Dolan's approach, is
that each polynomial monad M determines its own higher
dimensional collection of shapes (the M -opetopes) generated
directly from the syntactic structure of its terms. They go
on to introduce the notion of an M -opetopic type which
is, roughly, a collection of well formed decorations of these
shapes, and the notion of weak M -algebra is then defined as an
M -opetopic type satisfying certain closure properties. In this
sense, their approach differs from, say, approaches based on
simplices, cubes or spheres in that the geometry is not fixed
ahead of time, but adapted to the particular structure under
consideration.
With these considerations in mind, our plan in the present
work is to put the idea of a type theory with primitive
structures to the test. What might it look like, and what might
it be able to prove? In order to answer these questions, we
will build a prototype of the theory 1 in the proof assistant
Agda, and exploit the recent addition of rewrite rules [5] which
permits us to extend definitional equality by new well-typed
reductions. The use of such rewrites is necessary to ensure
that our primitive structures are not subject to the same infinite
regress of coherence conditions which has so far obstructed
more naive attempts and defining such objects.
Concretely, we will introduce a universe M,2 whose elements we think of as codes for polynomial monads and
describe the structures they decode to. Because we think of
the objects of the universe M as primitives of our theory,
on the same level as types, we allow ourselves the freedom
to prescribe their computational behavior: in particular, we
will equip them with definitional associativity and unit laws
using the rewrite mechanism alluded to above. We emphasize
that if structures are taken as defined in parallel with types,
then this kind of definitional behavior should be no more
surprising than, say, the definitional associativity of function
composition.
We then show how the existence of our universe M has some
strong consequences. In particular, it allows us to implement
the Baez and Dolan definition of opetopic type alluded to
above, and subsequently to define a number of weak higher dimensional structures. Among the structures which we are able
to define using this technique are A∞ -monoids and groups,
(∞, 1)-categories and presheaves over them (in particular, our
1 The Agda source is available here: https://github.com/ericfinster/
opetopic-types
2 We mean by this notation to distinguish the universe M of this particular
implementation from the generic idea of a universe of structures S, the
properties of which we expect to be refined by further investigation.

setup leads to a definition of simplicial type), and as a special
case, ∞-groupoids themselves.
There arises, then, the problem of justifying the correctness
of our definitions. In order to do so, we will take up the
example of ∞-groupoids in some detail. Indeed, since the
homotopical interpretation of type theory asserts that types
should "be" ∞-groupoids, it seems natural to compare these
two objects. Our main result is the following:
Theorem. There is an equivalence
U ' ∞-Grp
In other words, every type admits the structure of an ∞groupoid in our sense, and that structure is unique. This
theorem, therefore, can be regarded as a (constructive) internalization of the intuition provided by the various metatheoretic results to this effect [6], [7].
A. Related Work
The so-called coherence problem, which is the main motivation for the present work, has been considered by a number of
authors. We briefly compare our approach with two prominent
other strains of thought.
1) Synthetic Structures: One way to avoid some of the
problems posed by the definition of higher dimensional structures is to simply enlarge the collection of basic objects to
include them. Such approaches may be described as synthetic,
in that they do not reduce higher structures to more primitive
objects in exactly the same way that homotopy type theory
itself does not define ∞-groupoids in terms of sets. This
point of view is often adopted, for example, in the research
into directed type theories, whether they be aimed at specific
structures like higher categories as in [8], or allow for more
general directed spaces as in [9].
While our theory does indeed add some new primitive
structures to type theory, we collect these structures in a
universe and decode them into collections of ordinary types
and maps between them. Moreover, we go on to use these
additional strict structures to give analytic, internal definitions
of higher structures.
2) Two-Level Type Theory: Perhaps the closest related work
to the current approach is that of Two-Level Type Theory
[10]. There it is advocated to add a second "level" to type
theory with a set-truncated equality type which one can then
use to make meta-theoretic statements about the inner level,
whose objects are typically taken to be the homotopically
meaningful ones. The two-level approach provides, thus, a
great deal of generality and flexibility at the cost of restricting
the applicability of homotopical interpretation of types to
the inner theory. It is likely, for example, that our theory
could be developed inside a two-level system and many of
the rewrites we employ proven as theorems in the outer
level. By constrast, our approach is, we feel, somewhat more
economical, extending the theory with a specific set of rewrite
rules, and pointing towards the possibility of a useful theory
of higher structures without the need to restrict homotopical
principles like univalence.

B. Preliminaries
The basis of our metatheory is the type theory implemented
in Agda [11] which is an extension of the predicative part of
Martin-Löf type theory [12]. Among the particular types that
Agda implements, we shall use inductive types, records and
coinductive records.
As such, we adopt a style similar to Agda code, writing
(x : A) → B x for the dependent
product (although we ocQ
casionally also employ the (x:A) B x notation if it improves
readability). We also make use of the implicit counterpart of
the dependent products, written {x : A} → B x. This allows
us to hide arguments which can be inferred from the context
and hence clarify our notation. Non-dependent functions are
denoted A → B, as usual. Functions enjoy the usual η
conversion rule.
We shall make extensive use of coinductive record types,
as well as copatterns for producing elements of these types.
We write P
> for the empty record with a constructor tt : >.
We write (x:A) B x for the dependent sum as a record with
constructor , and projections fst and snd . Pairs which are
not dependent are denoted A × B.
We write ⊥ for the empty type, using absurd patterns where
appropriate, and writing ⊥-elim for the unique function for ⊥
to any type.
The identity type ≡ : {A : U} (x y : A) → U is an
inductive type with one constructor refl : (x : A) → x ≡ x.
We shall make use of the notion of contractible type denoted
is-contr whose center of contraction will be referred to as ctr .
Other notions defined in the HoTT book [13] will be employed
including equivalence of types denoted X ' Y , function extensionality denoted funext, as well as the Univalence Axiom.
We write U for the universe of small types, and U1 for the
next universe when necessary.
In order to unclutter and clarify the presentation, we occasionally take liberties with the formal definitions, for example, silently inserting applications to functional extensionality
when necessary, or reassociating Σ-types in order to avoid
a proliferation of commas. Our formal development in Agda
allows no such informalities to remain.
II. A U NIVERSE OF P OLYNOMIAL M ONADS
As we have explained in the introduction, type theory
appears to lack the ability to speak about infinitely coherent algebraic structures, and our strategy for addressing this
problem will be to distinguish a collection of such structures
which we consider as defined by the theory itself. We do so
using a common technique in the type theory literature: that
of introducing a universe. We write M : U for our universe,
and we think of its elements as codes for polynomial monads.
Just as a typical type theoretic universe has some collection of
base types and some collection of type constructors, so we will
populate our universe with a collection of "base monads" and
"monad constructors". In other words: we will have a syntax
of structures which parallels the syntax for types.
Typically, a universe of types U comes equipped with a
decoding function El : U → U. In the case of our universe of

monads M, each element M : M will decode not to a single
type, but to a collection of types and type families equipped
with some structure. We will use rewrite rules to specify the
computational behavior of this structure.
A. Polynomial Structure
To begin, we first equip each M : M with an underlying
polynomial or indexed container [14]. This is accomplished
by postulating the following collection of decoding functions:
Idx : M → U
Cns : (M : M) → Idx M → U
Pos : (M : M) {i : Idx M } → Cns M i → U
Typ : (M : M) {i : Idx M } (c : Cns M i)
→ Pos M c → Idx M
Polynomials of this sort appear in the computer science
literature as the "data of a datatype declaration". They can
equivalently be seen as a way to describe the signature of an
algebraic theory: concretely, the elements of Idx M , which we
refer to as indices serve as the sorts of the theory, and for
i : Idx M , the type Cns M i is the collection of operation
symbols whose "output" sort is i. The type Pos M c then
assigns to each operation a collection of "input positions"
which are themselves assigned an index via the function Typ .
It follows that every monad M induces a functor [ ] :
(Idx M → U) → (Idx M → U) called its extension given
by
X
[M ] X i =
(p : Pos M c) → X (Typ M c p)
(c:Cns M i)

We may think of the value of this functor at a type family
X : Idx M → U as the type of constructors of M with inputs
decorated by elements of X. Indeed, we will frequently refer
to a dependent function of the form
(p : Pos M c) → X (Typ M c p)
where X is as above, as a decoration of c by elements of X.
B. Monadic Structure
Next, for each monad M : M, we are going to equip
the underlying polynomial of M with an algebraic structure:
specifically, that structure required on the underlying polynomial so that the associated extension [M ] becomes a monad.
In the case at hand, this takes the form of a pair of functions
η : (M : M) (i : Idx M ) → Cns M i
μ : (M : M) {i : Idx M } (c : Cns M i)
→ (δ : (p : Pos M c) → Cns M (Typ M c p))
→ Cns M i
which equip M with a multiplication and unit operation. We
remark that the second argument δ of the multiplication μ is
a decoration of c in the family Cns M of constructors, so that
we can think of the input to this function as a "two-level" tree.
Crucial for what follows will be that the monads we
consider are cartesian in the sense of [1]. Type theoretically,

the means we require each monad M to come equipped with
equivalences
Pos M (η M i) ' >
P
Pos M (μ M c δ) ' (p:Pos M c) Pos M (δ p)

→ Pos M (μ M c δ) → Pos M c

In the case of η, for example, we postulate introduction and
elimination rules of the form
η-pos : (M : M) (i : Idx M ) → Pos M (η M i)
η-pos-elim : (M : M) (i : Idx M )
→ (X : (p : Pos M (η M i)) → U)
→ (u : X (η-pos M i))

→ {δ : (p : Pos M c) → Cns M (Typ M c p)}
→ (p : Pos M (μ M c δ))
→ Pos M (δ (μ-pos-fst M p))
with typing rule
Typ M (μ M c δ) p

(Typ-μ)

Typ M (δ (μ-pos-fst M p))
(μ-pos-snd M p)
and computation rules
μ-pos-fst M (μ-pos M p q)

p (μ-pos-fst)

μ-pos-snd M (μ-pos M p q)

q (μ-pos-snd)

μ-pos M (μ-pos-fst M p) (μ-pos-snd M p)

p

(μ-pos-η)

With the handling of positions in place, we can now state
the unitality and associativity axioms for the monads in our
universe. These take the form of reductions:
c

(μ-η-r)

μ M (η M i) δ
δ (η-pos M i)
μ M (μ M c δ) 

with typing rule
i

(Typ-η)

and computation rule
u

Notice these are exactly the rules for an inductively defined
indexed unit type.3 In particular, decorations of the constructor
η M i in a type family X : Pos M (η M i) → U are completely
determined by a single element x : X i, a fact which we record
in the following definition to reduce clutter below:
η-dec M X {i} x = η-pos-elim M i (λ → Xi) x
Next, for the multiplication μ, our rules simply mimic the
pairing and projections of the dependent sum. That is, we
postulate an introduction rule
μ-pos : (M : M) {i : Idx M } {c : Cns M i}
→ {δ : (p : Pos M c) → Cns M (Typ M c p)}
→ (p : Pos M c) → (q : Pos M (δ p))
→ Pos M (μ M c δ)

3 In

μ-pos-snd : (M : M) {i : Idx M } {c : Cns M i}

μ M c (λ p → η M (Typ M c p))

→ (p : Pos M (η M i)) → X p

η-pos-elim M i X u (η-pos M i)

μ-pos-fst : (M : M) {i : Idx M } {c : Cns M i}
→ {δ : (p : Pos M c) → Cns M (Typ M c p)}

Since we are already modifying the definitional equality of our
type theory, it may be tempting to require these equivalences
definitionally by asserting that the type of positions reduces
when applied to constructors of the appropriate form. However, this will not work: as we will see below, when we come
to populate our universe with concrete monads and monad
constructors, the equivalences we find are often in fact not
definitional, even if they remain provable. As an alternative,
we will equip each monad with introduction, elimination
and computation rules for its positions which will in effect
guarantee that we always have the required equivalence. Each
monad definition will then be required to implement these
rules in a manner consistent with the various required typing
laws.

Typ M (η M i) p

and elimination rules

principle, we would also like to have an η-rule for the unit η, (that is, we
would prefer the negative version as we have below for μ) but unfortunately
this is not possible with the current implementation of rewriting in Agda.

(μ-η-l)
(μ-μ)

μ M c (λ p → μ M (δ p) (λ q →  (μ-pos M p q)))
Additionally, we must posit laws which assert that the constructors and eliminators for positions are compatible with
these equations. We omit these for brevity, but the interested
reader may consult the development for details.
While we will not undertake an extensive investigation of
the meta-theoretic properties of our system in this article, we
wish to pause briefly to make at least of few observations
to justify its well-formedness. For example, there are critical
pairs in the rewrite equations for the monad laws (between the
first equation and the others) so we need to ensure confluence
and termination.
Lemma 1 (Strong confluence for η and μ). The rewrite rules
are strongly confluent [15], hence globally confluent.
Proof. The rewrite system is strongly confluent using the rules
(Typ-η) and (Typ-μ) and the associated reduction rules for
μ-pos . We show the case for μ-η-r and μ-η-l. We omit M
which is fixed here.
μ (η i) (λ p → η (Typ (η i) p))

μ-η-r

μ (η i) (λ p → η (Typ (η i) p))

μ-η-l

ηi

(λ p → η (Typ (η i) p)) (η-pos i)
η (Typ (η i) (η-pos i))

Typ-η

ηi

β

The resolution of the μ-η-r/μ-μ pair can be found in the
appendix of the extended version of this article [16, Lemma
3].

since its extension induces the identity monad on U up to
equivalence). The polynomial part of Id decodes as follows:

Proposition 1 (Termination of rewriting). All of the above
rules form a terminating rewrite system.
Proof. The μ-pos , η-pos and (Typ-η) rewrite rules are obviously terminating. For (Typ-μ), (μ-η-r), (μ-η-l) and (μ-μ), we
need to use a dependency-pairs path ordering as introduced
by [17] to verify termination. In particular for associativity,
a lexicographic lifting of the subterm relation is not enough
to verify (μ-μ)'s termination as we are going under binders
and applying the δ and  functions to subterms. This is a
variant of the ordinal type eliminator proven to terminate
in [17, Example 14, p11], which requires to ensure that the
constructor types of our monads are inductively generated. All
the monads considered in this article satisfy this.
The instances of the μ and η operations for specific monads
will themselves be defined by structural recursion on inductive
datatypes and can be shown to respect the associativity and
unitality laws prositionally. Results such as can be found
in [5, Lemma 6.8], therefore, guarantee the consistency of the
system. Furthermore, we conjecture that the rewrite system
is strongly normalizing in conjunction with the definitional
equality of Agda.
C. Populating the Universe
In the previous section, we described the generic structure
associated to every monad M : M. We now proceed to
implement this structure in concrete cases, describing in each
case the most salient features and omitting unnecessary details
where we feel it will improve the presentation. Complete
definitions can be found in the Agda formalization.
In the material which follows, we allow ourselves the freedom to use standard techniques such as inductive definitions
and pattern matching during the definition of each monad.
In practice, this agrees with the implementation: there, we
first define all the necessary structure using ordinary Agda
definitions and subsequently install rewrites which connect the
decoding functions to their desired implementations. So for
example, in order to define the indices of the identity monad
(see below), we first make an ordinary Agda definition
IdIdx : U
IdIdx = >
and then postulate the rewrite
Idx Id

Idx Id

=>

Cns Id tt

=>

Pos Id tt

=>

Typ Id tt tt

= tt

Given the triviality of the associated polynomial, it is perhaps
not surprising that its unit and multiplication are equally trivial.
Indeed, they are given by:
η Id i = tt
μ Id δ = δ tt
We omit the remaining structure, which has a similar flavor.
2) The pullback monad: Our first monad constructor starts
from a monad M : M and a family X : Idx M → U and refines
the indices of M by additionally decorating the inputs and
output of each constructor by elements of X. We refer to the
resulting monad as the pullback of M along X (cf. [2, Section
2.4]). We implement this construction by first postulating a
function
Pb : (M : M) (X : Idx M → U) → M
which adds the necessary code to our universe. We next define
the polynomial part of Pb M X as follows:
P
Idx (Pb M X)
= (i:Idx M ) X i
Cns (Pb M X) (i, x)
P

(c:Cns M i)

=
Q

(p:Pos M c)

X (Typ M c p)

Pos (Pb M X) (c, ν)

= Pos M c

Typ (Pb M X) (c, ν) p

= (Typ M c p , ν p)

The unit for the pullback monad simply calls the unit of the
underlying monad and decorates its input with the same value
as its output:
η (Pb M X) (i , x) = (η M i , η-dec M X x)
As for the multiplication of the pullback monad, it again
simply calls the multiplication of the underlying monad, this
time decorating the result using the decorations of the secondlevel constructors, and forgetting the intermediate decoration.
That is, we have
μ (Pb M X) (c , ν) δ = (μ M c δ 0 , ν 0 )
where
δ 0 p = fst (δ p)
ν 0 p = snd (δ (μ-pos-fst p)) (δ (μ-pos-snd p))

IdIdx

In the presentation which follows, we omit this auxiliary step
and just write "=" when defining the structure associated to
each monad.
1) The identity monad: We begin by adding a constant Id :
M to the universe to represent the identity monad (so named

The remaining structure is easily worked out from these
definitions, and we omit the details.
3) The Slice Monad: The Baez-Dolan slice construction is
at the heart of the opetopic approach: it is this construction
which allows us to "raise the dimension" of the coherences in
our algebraic structures. In our setting, it will take the form of a

monad constructor Slice : M → M. The basic intuition is that,
for a monad M : M, the monad Slice M may be described as
the monad of relations in M . In order to realize this intuition,
we have to find a way to encode the relations of M as some
kind of data, just as the identity type encodes the relations
in an ordinary type as data. This data will then serve as the
constructors for the slice monad.
To begin, for a monad M : M, let us define
P
Idx (Slice M ) = (i:Idx M ) Cns M i
That is, the indices of the monad Slice M are exactly the
constructors of the monad M . Next, we are going to capture
the notion of relation in M with the help of a certain inductive
family, defined as follows:
data Tree : Idx (Slice M ) → U where

by position p:
Typ (Slice M ) (lf i) ()
Typ (Slice M ) (nd {i} c δ ) (inl tt)

= (i , c)

Typ (Slice M ) (nd {i} c δ ) (inl (p , q))

=

Typ (Slice M ) ( p) q
It remains to describe the unit and multiplication of the slice
monad. In accordance with the general laws for monads, the
unit constructor needs to have a unique position, and since
the positions of a given tree are given by occurrences of
constructors, this implies that the unit at a given constructor c
should be the corolla, that is, a tree with one node consisting
of c itself. Therefore we set:
η (Slice M ) (i , c)

nd c (λ p → η M (Typ M c p))

lf : (i : Idx M ) → Tree (i , η M i)

(λ p → lf (Typ M c p))

nd : {i : Idx M } (c : Cns M i)
→ (δ : (p : Pos M c) → Cns M (Typ M c p))
→ ( : (p : Pos M c) → Tree (Typ M c p, δ p))
→ Tree (i , μ M c δ)
And we define Cns (Slice M ) = Tree.
The reader familiar with the theory of inductive types may
recognize this as a modified form of the indexed W -type
associated to a polynomial or indexed container. Here, as in
that case, the elements of this type are trees generated by
the constructors of the polynomial in question (the underlying
polynomial of M , in the case at hand). The difference in
the present setup is that our polynomial is equipped with a
multiplication and unit, and we reflect this fact by indexing
our trees not just over the indices (as is typically the case)
but also over the constructors, applying the multiplication
and unit as appropriate. The result is that we may view an
element σ : Cns (Slice M ) (i , c) as "a tree generated by the
constructors of M whose image under iterated multiplication
is c". It is in this sense that this definition captures the relations
in the original monad M .
We now turn to the rest of the structure required to complete
the definition of Slice M . Intuitively speaking, the positions of
a tree σ will be its internal nodes. This can be accomplished
by defining the positions by recursion on the constructors as
follows:
Pos (Slice M ) (lf i)

=⊥

Pos (Slice M ) (nd c δ )

=
X

>t

=

Note that this definition would not be type correct without
the assumption that M is definitionally right unital. A similar
remark applies to the rest of the definitions of the slice monad
in this section. Indeed, it is exactly the problem of completing
the definition of the slice monad without any assumptions
of truncation which motives the introduction of our monadic
universe in the first place.
Let us now sketch the definition of the multiplication in
the slice monad. As hypotheses, we are given a tree σ :
Cns (Slice M )(i , c) for some i : Idx M and c : Cns M i, as
well as a decoration
φ : (p : Pos (Slice M ) σ) → Cns (Slice M ) (Typ (Slice M ) σ p)
In view of the preceding discussion, this means that φ assigns
to every position of σ a tree which multiplies to the constructor
which inhabits that position. The multiplication of Slice M
may intuitively be described as "substituting" each of these
trees into the node it decorates.
The definition of μ(Slice M ) will require an auxillary function γ with the following type:
γ : (M : M) {i : Idx M } (c : Cns M i)
→ (σ : Cns (Slice M ) (i , c))
→ (φ : (p : Pos M c) → Cns M (Typ M c p))
→ (ψ : (p : Pos M c) → Cns (Slice M ) (Typ M c p , φ p))
→ Cns (Slice M )(i , μ M c φ)

Pos (Slice M ) ( p)

(p:Pos M c)

In other words, if our tree is a leaf, it has no positions, and
if it is a node, its positions consist of either the unit type (to
record the current node) or else the choice of a position of the
base constructor and, recursively, a node of the tree attached
to that position.
Finally, the typing function Typ (Slice M ) σ p just projects
out the constructor of M occurring at the node of σ specified

The intuition of this function is that γ grafts the tree specified
by ψ onto the appropriate leaf of the tree σ (indeed, γ may
be seen as an incarnation of multiplication in the free monad
generated by the underlying polynomial of M ). This function
simply operates by induction and may be defined as follows:
γ M (lf i) δ 

=  (η-pos M i)

γ M (nd c δ ) φ ψ

= nd c δ 0 0

where we define
φ0 p q = φ(μ-pos M c δ p q)

ψ 0 p q = ψ(μ-pos M c δ p q)
0

0

δ p = μ M (δ p) (φ p)
0 p = γ M ( p) (ψ 0 p)
With this function in hand, we may complete the definition of
the multiplication in the slice monad as
μ (Slice M ) (lf i) φ

= lf i

μ (Slice M ) (nd c δ ) φ

= γM wδψ

where we put

of the definitions fiberwise. And since the dependent case
resembles so closely the non-dependent one, we have attempted to systematically name dependent versions of the the
monadic structure introduced above by appending a "↓" to the
previously given name. For example, Idx↓ for the dependent
version of the family Idx of indices.
As a first step, a dependent monad will be equipped with a
polynomial lying over the base polynomial. This corresponds
to the following three dependent families:
Idx↓ : {M : M} → M↓ M → Idx M → U

w = φ (inl tt)
φ0 p q = φ (inr (p , q))
ψ p = μ (Slice M ) ( p) (φ0 p)
This definition then says that substitution is trivial on leaves,
and when we are looking at a node, we first retrieve the tree
living at this position (called w above), and then graft to it the
result of recursively substituting in the remaining branches.
We refer the reader to the formalization for details on the
remaining constructions handling positions in the slice monad.
D. Dependent monads
Since the notion of dependent type is one of the primitive
aspects of Martin-Löf type theory, it is perhaps not surprising
that we quickly find ourselves in need of a dependent version
of our polynomial monads. We note there is a potential point of
confusion here: while a dependent type can be thought of as a
family of types dependent on a base type, a dependent monad
in our sense is not a family of monads. Rather, it is a monad
structure on dependent families of indices and constructors
indexed over the indices and constructors of the base monad
M . Put another way, under the equivalence between dependent
types with domain A and functions with codomain A, our dependent monads over a base monad M correspond to monads
M 0 equipped with a cartesian homomorphism to M . 4 The
advantage of working in a dependent style, however, is that
we do not need to axiomatize the notion of homomorphism
using propositional equalities as it is encoded directly in the
typing of the multiplication operator.
To begin, let us postulate, for each monad M : M, a universe
M↓ M : U of monads over M .
M↓ : M → U
That is, for M : M, the inhabitants of M↓M are codes for
monads equipped with a cartesian morphism to M . For this
reason, when we are given a monad M and a dependent monad
M ↓ : M↓ M , we often speak of the pair (M , M ↓) as a monad
extension.
The decoding functions for dependent monads follow the
same setup as the non-dependent case, simply repeating each
4 In fact, it is entirely possible to add a monadic form of dependent sum
to the list of monad constructors of the universe M so that this statement
becomes literally true. As we will not have need of this construction in the
present article, however, we omit the details.

Cns↓ : {M : M} (M ↓ : M↓ M ) {i : Idx M }
→ Idx↓ M ↓ i → Cns M i → U
Typ↓ : {M : M} (M ↓ : M↓ M )
→ {i : Idx M } {i↓ : Idx↓ M ↓ i}
→ {c : Cns M i} (c↓ : Cns↓ M ↓ i↓ c)
→ Pos M c → Idx↓ M ↓ (Typ M c p)
The reader will notice, however, that there is no analog
of dependent positions. This is because we are modelling
cartesian morphisms of monads, and therefore positions of
a dependent constructor c↓ : Cns↓ M ↓ i↓ c should be the
same as those of the underlying constructor c. By working
fiberwise, we can reflect this requirement directly in the type
signature.
The monadic structure of a dependent monad simply operates fiberwise, following the multiplication in the base monad:
η↓ : {M : M} (M ↓ : M↓ M )
→ {i : Idx M } → Idx↓ M ↓ i
→ Cns↓ M ↓ i (η M i)
μ↓ : {M : M} (M ↓ : M↓ M )
→ {i : Idx M } {c : Cns M i}
→ {δ : (p : Pos M c) → Cns M (Typ M c p)}
→ (i↓ : Idx↓ M ↓ i) (c↓ : Cns↓ M ↓ i↓ c)
→ (δ↓ : (p : Pos M c) →
Cns↓ M ↓ (Typ↓ M ↓ c↓ p) (δ p))
→ Cns↓ M ↓ i↓ (μ M c δ)
The fact that we require the multiplication of a family of dependent constructors to live over the multiplication of the base
constructors (and similarly for the unit) is what guarantees the
homomorphism property alluded to above.
Our dependent monads must also be equipped with equational laws making them compatible with the corresponding
laws of the monads they live over. For example, the typing
functions for η↓ and μ↓ respect the indices of parameters,
just as in the base case:
Typ↓ M ↓ (η↓ M ↓ i↓) p

i↓

Typ↓ M ↓ (μ↓ M ↓ c↓ δ↓) p
Typ↓ M (δ↓ (μ-pos-fst ↓M ↓ p))
(μ-pos-snd ↓M ↓ p)

There are similar laws asserting the definitional associativity
and unitality of the multiplication, but as these all follow
exactly the same pattern, we omit the details here and refer
the curious reader to the implementation.
We remark that, because their positions are the same,
decorations of the dependent constructor η↓ are essentially
constant just as in the case of η, and there is therefore an
analogous function η-dec↓ generating such decorations from
a single piece of data with a similar definition. This function
occurs occasionally in the code below.
E. Populating the dependent universe
We now quickly describe dependent counterparts of the base
monads and monad constructors of the previous section. As
most of the definitions are routine and easily deduced from
the absolute case, the presentation here is brief.
1) The identity monad: The dependent identity monad is
parametrized by a type A : U and indexed over the identity
monad Id. That is, we have a dependent monad constructor of
the form
Id↓ : U → M↓ Id

Idx↓ (Id↓ A) tt

=A

Cns↓ (Id↓ A) x tt

=>

Pos↓ (Id↓ A) tt tt

=>

Typ↓ (Id↓ A) {i↓ = x} tt tt

=x

As in the base case, the multiplication and unit all take values
in the unit type, making the structure essentially trivial.
2) The dependent pullback monad: Just as we can refine
the indices of a base monad, so the dependent pullback monad
allows us to refine the indices of a dependent monad. Its
constructor takes the form
Pb↓ : {M : M} (M ↓ : M↓ M ) {X : Idx M → U}
→ (X↓ : {i : Idx M } → Idx↓ M ↓ i → X i → U)
→ M↓ (Pb M X)
Note that the family X↓ may also depend on elements of
the refining family X for the base monad. The underlying
polynomial of the dependent pullback is then defined as
follows:
X
Idx↓ (Pb↓ M ↓ X↓) (i, x) =
X↓ i↓ x
(i↓:Idx↓ M ↓ i)

Cns↓ (Pb↓ M ↓ X↓) (i↓, x↓) (c, ν) =
Y

Slice↓ : {M : M} (M ↓ : M↓ M ) → M↓ (Slice M )
As for the absolute case, the indices are given by the dependent
constructors. That is, we set
X
Idx↓ (Slice↓ M ↓) (i, c) =
Cns↓ M ↓ i↓ c
i↓:Idx↓ M ↓ i

Similarly, the type of constructors Cns↓ (Slice↓ M ↓) are trees
lying over a tree in the base. This corresponds to the following
(rather verbose) inductive type:
data Tree↓ : {i : Idx (Slice M )} → (i↓ : Idx↓ (Slice↓ M ↓)
→ Tree i → U where
lf↓ : {i : Idx M } (i↓ : Idx↓ M ↓ i)
→ Cns↓ (Slice↓ M ↓) (i↓, η↓M ↓ i↓) (lf i)
nd↓ : {i : Idx M } {c : Cns M i}
→ {δ : (p : Pos M c) → Cns M (Typ M c p)}
→ { : (p : Pos M c)
→ Cns (Slice M ) (Typ M c p, δ p)}

Its polynomial part is defined by

X

3) The dependent slice monad: Finally, the dependent slice
monad extends the Baez-Dolan slice construction to the dependent case. Its monad constructor is typed as follows:

X↓ (Typ↓ M ↓ c↓ p) (ν p)

(c↓:Cns↓ M ↓ i↓ c) (p:Pos M c)

Typ↓ (Pb↓ M ↓ X↓) (c↓, ν↓) p = Typ↓ M c↓ p, ν↓ p
with multiplicative structure following fiberwise the rules for
the base pullback Pb M X.

→ {i↓ : Idx↓ M ↓ i} → (c↓ : Cns↓ M ↓ i↓ c)
→ (δ↓ : (p : Pos M c) → Cns↓ M ↓ (Typ↓ M ↓ c↓ p))
→ (↓ : (p : Pos M c)
→ Cns↓ (Slice↓ M ↓) (Typ↓ M ↓ c↓ p, δ↓ p))
→ Cns↓ (Slice↓ M ↓) (i↓ , μ↓M ↓ c↓ δ↓) (nd c δ )
The rest of the description of the dependent slice follows
exactly the same pattern: duplicating the definitions and laws
of the base case routinely in each fiber.
III. O PETOPIC T YPES
In this section, we show how to use the universes introduced
above in order to implement Baez and Dolan's definition
of opetopic type [2]. We go on to explain how to use this
definition to capture the notion of weak M -algebra, and finish
with some examples.
Definition 1. An opetopic type over a monad M is defined
coninductively as follow:
record OpetopicType (M : M) : U1 where
C : Idx M → U
R : OpetopicType (Slice (Pb M C ))
We see from the definition that an opetopic type consists of
an infinite sequence of dependent families
C X , C (R X) , C (R (R X)) , . . .
whose domain is the set of indices of a monad whose definition
incorporates all the previous families in the sequence. Given
an opetopic type X : OpetopicType M , we will often denote
this sequence of dependent types more succinctly as just
X0 , X1 , X2 , . . . since the destructor notation quickly becomes

quite heavy. We will use a similar convention for the series
of monads M = M0 , M1 , M2 . . . generated by the definition.
That is, we have:
M0 = M

X0 = C X : Idx M → U

We recall that for M a polynomial monad, an M -algebra
consists of a carrier family C : Idx M → U together with a
map
α : {i : Idx M } → [M ] C i → C i

M1 = Slice (Pb M0 X0 ) X1 = C (R X) : Idx M1 → U
M2 = Slice (Pb M1 X1 ) X2 = C (R (R X)) :

(1)

Idx M2 → U
..
.

..
.

Before describing the connection between opetopic types
and weak M -algebras, let us give some examples of how
to think of the resulting dependent families as "fillers" for
a collection of "shapes" generated by the monad M . For
concreteness, we will fix M = Id in our examples. Given
X : OpetopicType Id, we can define the type of objects of X
as simply
Obj : U
(2)
Obj = C X tt
Next, after a single slice, X provides us with a type of arrows
between any two objects which can be defined as follows:
Arrow : (x y : Obj) → U
Arrow x y = C (R X)

(3)

((tt , y) , (tt, η-dec Id (C X) x))
Furthermore, for a loop f in X, that is, an arrow with the same
domain and codomain, X includes a family whose elements
can be thought of as "null-homotopies of f ", and which is
defined by
Null : (x : Obj) (f : Arrow x x) → U
Null x f = C (R (R X))
((((tt , x) , (tt, η-dec Id (C X) x)) , f ) ,
lf (tt , x) , ⊥-elim)
More examples of shapes and filling families may be found
in the development.
A. Weak Algebras and Fibrant Opetopic Types
We now wish to describe how an opetopic type X :
OpetopicType M encodes the structure of a weak M -algebra.
Before we begin, it will be convenient to adopt the following
convention: recall that X consists of an infinite sequence of
dependent types following the form of Equation 1. In the
discussion which follows, instead of working with a fixed
opetopic type X, we will rather just work with abstract
type families X0 , X1 , . . . over monads M = M0 , M1 , . . .
following the same pattern of dependencies. We will then
freely add new families of the form Xi to our hypotheses as
they become necessary. The advantage of working this way is
that our definitions are parameterized over just that portion of
the opetopic type which is necessary, as opposed to depending
on the entire opetopic type X itself, and consequently, we will
be able to reuse our definitions and constructions starting at
any point in the infinite sequence generated by X.

which satisfies some equations expressing the compatibility
of α with the multiplication of M . Indeed, it is the need for
a complete description of these equations in all dimensions
which motivates the present work. Now, clearly the first
dependent type X0 : Idx M → U may serve as a carrier for an
M -algebra structure. Let us now see what else this sequence
of families provides us with.
After one iteration, we obtain a type family X1 : Idx M1 →
U, and unfolding the definition of the indices of the slice and
pullback monads, we find that the domain of X1 takes the
form
X
X
X
(p : Pos M c) → X0 (Typ M c p)
(i:Idx M ) (x:X0 i) (c:Cns M i)

The elements of this type are 4-tuples (i , x , c , ν), and we now
observe that the three elements i, c and ν are typed such that
they are exactly the arguments of the hypothetical algebra map
α introduced above. We may regard the family X1 , therefore,
as a relation between triples (i , c , ν) and elements x : X0 i,
and in order to define a map α, we only need to impose that
this relation is functional in the sense that there is a unique x
determined by any such triple. When this is the case, we will
say that the family X1 is multiplicative. That is, we define:
is-mult : {X0 : Idx M0 → U} (X1 : Idx M1 → U) → U
is-mult {X0 } X1 = {i : Idx M } (c : Cns M i)
→ (ν : (p : Pos M c) → X0 (Typ M c p))
X
→ is-contr (
X1 (i , x , c , ν))
x:X0 i

Supposing we are given a proof m1 : is-mult X1 , we can
define an algebra map α as above by
α (c , ν) = fst (ctr (m1 c ν))
Furthermore, we will write
α-wit (c , ν) = snd (ctr (m1 c ν))
for the associated element of the relation X1 (i , α (c , ν) , c , ν)
which witnesses this multiplication.
Let us now suppose that our sequence extends one step
further, that is, that we are given a type family X2 : Idx M1 →
U and a proof m2 : is-mult X2 . We now show how to use this
further structure to derive some of the expected laws for the
algebra map α we have just defined. As a first example, we
expect α to satisfy a unit law: decorating a unit constructor
with some element x and then applying α should return the
element x itself. In other words, we expect to be able to prove
αη -coh : {i : Idx M }(x : X0 i)
→ α (η M i , η-dec M X0 x) ≡ x

To prove this equality, let us define the following function:
η-algm2 : {i : Idx M }(x : X0 i)
→ X1 ((i , x) , (η M i, η-dec M X0 x))
η-algm2 = fst (ctr (m2 (lf (i , x)) ⊥-elim))
Now we simply notice that the pairs

must be equal as indicated, since they inhabit a contractible
space. Projecting on the first factor gives exactly the desired
equation.
We also expect our algebra map α to satisfy an equation expressing its compatibility with multiplication of the following
form:
αμ -coh : {i0 : Idx M } (c0 : Cns M i)
→ (δ 0 : (p : Pos M c) → Cns M (Typ M c p))
→ (ν 0 : (p : Pos M c0 )(q : Pos M (δ 0 p))
→ X0 (Typ M (δ 0 p) q))
→ α (μ M c0 δ 0 ) (λp → ν 0 (μ-pos-fst p) (μ-pos-snd p)) ≡
α c0 (λp → α (δ 0 p) (ν 0 p))
We note that this equation is simply the type theoretic translation of the familiar commutative diagram
μX0

[M ] X0

[M ] α

[M ] X0

α
α

c = c0

x1 = α-wit (c , ν)

ν p = α (δ 0 p , ν 0 p)

δ p = (δ 0 p , ν 0 p)

x0 = α (c , ν)

x̄ p = α-wit (δ 0 p , ν 0 p)

we find that the pairs

ctr (m1 (η M i) (η-dec M X0 x)) ≡ (x , η-alg x)

[M ] [M ] X0

Now instantiating our function μ-algm2 with arguments

X0

To prove this axiom, we use m2 to define the following
multiplication operation on elements of the family X1 :
μ-algm2 : {i : Idx M } (c : Cns M i)
→ (ν : (p : Pos M c) → X0 (Typ M c p))
→ (δ : (p : Pos M c)
→ Cns (Pb M X0 )(Typ (Pb M X0 ) (c, ν) p))
→ (x0 : X0 i) (x1 : X1 (i , x0 , c , ν))
→ (x̄ : (p : Pos M c) → X1 (Typ (Pb M X0 )(c , ν) , δ p))
→ X1 (i , x0 , μ (Pb M X0 ) (c , ν) δ)
μ-algm2 = fst (ctr (m2 σ θ))

ctr (m1 (μ M c0 δ 0 ) (λp → ν 0 (μ-pos-fst p) (μ-pos-snd p))) ≡
(α (c , ν) , μ-algm2 c ν x0 x1 δ x̄)
again inhabit a contractible space, whereby their first components are equal, giving the desired equation.
We may think of the functions η-algm2 and μ-algm2 defined
above as the nullary and binary cases of a multiplicative
operation on the relations of our algebra structure. The key
insight, as we have seen, is that this multiplicative structure
encodes exactly the laws for the algebra map α defined one
level lower. Similarly, if we are able to extend our sequence
on further step to a family X3 which is itself multiplicative,
then we will be able to show that the operations η-algm2 and
μ-algm2 themselves satisfy unit and associativity laws, and this
in turn encodes the "2-associativity" and "2-unitality" of the
algebra map α. This motivates the following definition:
Definition 2. An opetopic type X over a monad M is said
to be fibrant if we are given an element of the following
coinductively defined property:
record is-fibrant {M : M} (X : OpetopicType M ) : U
where
car-is-mult : is-mult M (C (R X))
rel-is-fibrant : is-fibrant (R X)
Fibrant opetopic types, therefore, are our definition of
infinitely coherent M -algebras, with the multiplicativity of
the relations further in the sequence witnessing the higher
dimensional laws satisfied by the structure earlier in the
sequence.
B. Higher structures
We now use the preceding notions to define a number of
coherent algebraic structures. A first example is that we obtain
an internal definition of the notion of ∞-groupoid as follows:

σ = nd (c , ν) δ (λp → η M1 ((Typ M c p , ν p) , δ p))

Definition 3. An ∞-groupoid is a fibrant opetopic type over
the identity monad. That is,
P
∞-Grp = (X:OpetopicType Id) is-fibrant X

is the two-level tree consisting of a base node (c, ν), as well
as a second level of constructors specified by the decoration
δ, and θ is the decoration of the nodes of σ by elements of
X1 defined by:

We will attempt to justify the correctness of this definition in
the sections which follow.
Next, it happens that the monad Slice Id is in fact the monad
whose algebras are monoids, and consequently, our setup leads
naturally to the definition of an A∞ -type, that is, a type with
a coherently associative binary operation.

where

θ (inl tt) = x1
θ (inr (p , inl tt)) = x̄ p

Definition 4. An A∞ -type is a fibrant opetopic type over the
first slice of the identity monad.
P
A∞ -type = (X:OpetopicType (Slice Id)) is-fibrant X

Furthermore, the notion of A∞ -group can now be defined by
imposing an invertibility axiom. A classical theorem of homotopy theory asserts that the type of A∞ -groups is equivalent
to the type of pointed, connected spaces via the loop-space
construction. It would be interesting to see if the techniques
of this article lead to a proof of this fact in type theory.
The notion of ∞-category can also be defined using this
setup. Recall that an opetopic type over the identity monad Id
has both a type of objects and a type of arrows (Equations 2
and 3). In the definition of ∞-groupoid above, the invertibility
of the arrows in the underlying opetopic type is a consequence
of the fact that the family of arrows is assumed to be
multiplicative. Consequently, we obtain a reasonable notion
of a pre-∞-category by simply dropping this assumption, and
only requiring fibrancy after one application of the destructor
R:
P
pre-∞-Cat = (X:OpetopicType Id) is-fibrant (R X)
The prefix "pre" here refers to the fact that this definition
is missing a completeness axiom asserting that the invertible
arrows coincide with paths in the space of objects, that is, an
axiom of univalence in the sense of [18]. Such an axiom is
easily worked out in the present setting, but as it would distract
us slightly from the main objective of the present work, we
will not pursue the matter here.
IV. T HE ∞- GROUPOID ASSOCIATED TO A TYPE
In this section, we use the machinery we have set up to
produce an ∞-groupoid associated to any type and eventually
prove it is unique. As a first step, we will need a source of
opetopic types. Here is where the notion of dependent monad
becomes important: we now show that every dependent monad
gives rise to an opetopic type. The reason for this phenomenon
is simple: since our dependent monad constructors mirror the
monad constructors of the absolute case, any monad extension
(M , M ↓) in fact gives rise to a new monad extension as
follows:
M

7→

Slice (Pb M (Idx↓ M ↓))

M↓

7→

Slice↓ (Pb↓ M ↓ (λ j k → j ≡ k))

Notice how by pulling back along Idx↓ M ↓, the identity
type gives us a canonical family along which to apply the
Pb↓ constructor. Iterating this construction, then, we find that
associated to every monad extension (M , M ↓), is an infinite
sequence
(M , M ↓) = (M0 , M ↓0 ), (M1 , M ↓1 ), (M2 , M ↓2 ), . . .
where (Mi+1 , M ↓i+1 ) is obtained from (Mi , M ↓i ) by the
above transformation.
The above construction provides us with our desired source
of opetopic types. Formally, we define (using copattern notation)
↓OpType M M ↓ : OpetopicType M
C (↓OpType M M ↓) = Idx↓ M ↓
R (↓OpType M M ↓) =

↓OpType (Slice (Pb (Idx↓ M ↓)))
(Slice↓ (Pb↓ M ↓ (λ j k → j ≡ k)))
Specializing to the case of the identity monad, we obtain the
following:
Definition 5. For a type A : U, the underlying opetopic
type of A is defined to be the opetopic type associated to
the dependent identity monad determined by A. That is, the
opetopic type
↓OpType Id (Id↓ A)
in the notation of the previous paragraph.
In order to show that every type A determines an ∞groupoid in our sense, our next task is to show that this
opetopic type is in fact fibrant.
A. Algebraic Extensions
Let M : M and M ↓ : M↓. We will say that the extension
(M, M ↓) is algebraic if we have a proof
is-algebraic : (M : M) (M ↓ : M↓) → U
is-algebraic = {i : Idx M } (c : Cns M i)
→ (ν : (p : Pos M c) → Idx↓ M ↓ (Typ M c p))


X
X
Typ↓ M ↓ c↓ ≡ ν 
→ is-contr 
(i↓:Idx↓ M ↓) (c↓:Cns↓ M ↓ i↓)

An algebraic extension should be thought of as roughly
analogous to a generalized kind of opfibration: if we think
of the constructors as generalized arrows between their input
indices and output, then the hypothesis says we know a family
of lifts over the source of our constructor, and the conclusion
is that there exists a unique "pushforward" consisting of a lift
over the output as well as a constructor connecting the two
whose typing function agrees with the provided input lifts.
Such a hypothesis is one way of encoding an M -algebra,
which motivates the name for this property. See [19, Section
6.3].
The main use of the notion of algebraic extension is the
following lemma, whose proof is entirely straightforward:
Lemma 2. Suppose the pair (M , M ↓) is an algebraic extension. Then the relation Idx↓ M ↓1 is multiplicative.
Consequently, just as dependent monads are a source of
opetopic types, algebraic extensions can be thought of as
a source of multiplicative relations. Hence if we want to
prove fibrancy of the opetopic type associated to a monad
extension, we will need to know which of the extensions in
the generated sequence are algebraic. Our main theorem is that
after a single iteration of the slice construction, every monad
extension becomes algebraic. That is
Theorem 1. Let (M , M ↓) be a monad extension. Then slice
extension (M1 , M ↓1 ) is algebraic.

A proof can be found in the extended version of this article
[16]. The importance of the theorem is that it has the following
immediate corollaries:
Corollary 1. Let (M , M ↓) be an algebraic extension. Then
the opetopic type ↓OpType M M ↓ is fibrant.
Proof. The base case of the coinduction is Lemma 2 and the
coinductive case is covered by Theorem 1.
Corollary 2. There is a map Γ : U → ∞-Grp.
Proof. Let A : U be a type. A short calculation shows that the
monad extension (Id , Id↓ A) is algebraic. The result therefore
follows from Corollary 1.
B. Uniqueness of the Groupoid Structure
We now turn to the task of showing the map Γ : U →
∞-Grp is an equivalence. Observe that there is a forgetful
map Υ : ∞-Grp → U which is given by extracting the type
of objects (Equation 2) from the opetopic type underlying a
groupoid G : ∞-Grp. It is readily checked that the composite
Υ ◦ Γ is definitionally the identity, and so what remains to be
shown is that any G : ∞-Grp is equivalent to Γ applied to its
type of objects.
Unwinding the definitions, we find that we are faced
with the following problem: suppose we are given a monad
extension (M , M ↓) as well as a opetopic type X :
OpetopicType M . Under what hypotheses can we prove that
X 'o ↓OpType M M ↓ (where 'o denotes an appropriate
notion of equivalence of opetopic types)? A first remark is that
the opetopic type ↓OpType M M ↓ is completely determined
by the algebraic structure of the dependent monad M ↓.
Therefore, at a minimum, we must assume that the data of
the opetopic type X is equivalent to the data provided by M ↓
wherever they "overlap".
To see what this means concretely, let us begin at the base of
the sequence, writing Z = ↓OpType M M ↓ to reduce clutter.
Now, the family Z0 : Idx M → U is, by definition, given
by the family of dependent indices Idx↓ M ↓ of the dependent
monad M ↓. On the other hand, without additional hypotheses,
the opetopic type X only provides us with some abstract type
family X0 : Idx M → U. Clearly, then, we will need to assume
an equivalence e0 : (i : Idx M ) → Idx↓ M ↓ i ' X0 i in order
to have any chance to end up with the desired equivalence of
opetopic types.
Moving on to the next stage, here we find that Z1 is given
by the dependent indices
Idx↓ M ↓1 : Idx M1 → U
of the first iteration of the dependent slice-pullback construction. Unfolding the definition, these are of the form
(Idx↓ M ↓1 ) (i , j , c , v) =
X
X
(j:Idx↓ M ↓ i)

(r:j≡j 0 )

X

(Typ↓ M ↓ d ≡ ν)

r and the equality relating ν to the typing function of d, we
find that the dependent indices are essentially just dependent
constructors of M ↓, slightly reindexed. In other words, a
dependent equivalence
e1 : (i : Idx M1 ) → Idx↓ M ↓1 'e0 X1
over the previous equivalence e0 amounts to saying that the relations of the family X1 "are" just the dependent constructors
of M ↓ (again, reindexed according to the typing of their input
and output positions). As this is again part of the data already
provided by the dependent monad M ↓, we will additionally
need to add such an equivalence to our list of hypotheses.
To recap: assuming the equivalences e0 and e1 amounts to
requiring that the first two stages of the opetopic type X are
equivalent to the indices and constructors of the dependent
monad M ↓, respectively. What structure remains? Well, the
dependent constructors of M ↓ are equipped with the unit
and multiplication operators η↓ and μ↓. But now, recall
from Section III-A that if the family of relations X1 extends
further in the sequence to a family X2 and we have a proof
m2 : is-mult X2 , then the family X1 can be equipped with
a multiplicative structure given by the functions η-algm2 and
μ-algm2 defined there. This is the case in the current situation,
if we assume that the opetopic type X is fibrant (in fact, we
only need assume that R X is fibrant to make this statement
hold). Therefore, the last piece of information in order that
X "completely agrees" with the dependent monad M ↓ is that
the equivalence e1 is additionally a homomorphism, sending
η↓ to η-algm2 and μ↓ to μ-algm2 . Our theorem now is that
this data suffices to prove an equivalence of opetopic types:
Theorem 2. Suppose (M, M ↓) is a monad extension and X :
OpetopicType M an opetopic type such that R X is fibrant.
Moreover, suppose we are given the data of
• An equivalence e0 : (i : Idx M ) → Idx↓ M ↓ i ' X0 i
• An equivalence e1 : (i : Idx M1 ) → Idx↓ M ↓1 'e0 X1
over e0
• Proofs that s : η↓M ↓ ≡e0 ,e1
η-algm2 and t :
μ↓M ↓ ≡e0 ,e1 μ-algm2
Then there is an equivalence of opetopic types
X 'o ↓OpType M M ↓
We have taken some liberties in the presentation of this
theorem (strictly speaking, we have not stated precisely in
what sense the second equivalence e1 is "over" the equivalence
e0 , nor precisely what equality is implied by symbol the
≡e0 ,e1 ) but these omissions can be made perfectly rigorous by
standard techniques, and we feel the statement above conveys
the essential ideas perhaps more clearly than a fully elaborated
statement, which would require a great deal more preparation,
not to mention space. See the appendix of the extended version
of this article for a proof [16, Theorem 2].
We at last obtain our desired equivalence:

(d:Cns↓ M ↓ c)

With the 4-tuple (i , j , c , v) as in Equation 4. We notice that
much of the data here is redundant: by eliminating the equality

Theorem 3. The map
Γ : U → ∞-Grp

is an equivalence.
Proof. Given G : ∞-Grp, we let A : U be its type of objects.
We now apply Theorem 2 with M = Id and M ↓ = Id↓ A.
We may take e0 to be the identity. The equivalence e1 is a
consequence of [13, Theorem 5.8.2] and the required equalities
are a straightforward calculation.
V. C ONCLUSION
We have presented an approach to defining higher coherent
structures in homotopy type theory by equipping type theory
with a primitive set of structures collected into a universe M of
polynomial monads, and demonstrated that this approach can
be used to prove non-trivial theorems about these structures. In
this brief final section, we compare some related approaches
and survey some of the possible directions and applications.
A. Future Directions
1) Symmetric Structures: A natural class of structures
which escapes the capabilities of our current approach is that
of symmetric structures, that is, those which incorporate higher
analogs of commutativity. Examples would include E∞ groups
and monoids, symmetric monoidal categories, and general ∞operads and their algebras.
2) Higher Category Theory: As we have seen, one higher
structure which is amenable to treatment by our methods is
that of an ∞-category. An obvious point to follow up on, then,
is how much of the well developed theory of ∞-categories can
be formalized in this manner.
3) A General Theory of Structures: As we have mentioned
in the introduction, we see the present work as a first step
towards a general theory of types and structures. And though
we feel certain that at least some of the ideas of the present
work will carry over to such a theory, a complete picture of
the basic principles remains to be understood. Moreover, a
careful investigation of the interaction of our techniques with
univalent implementations of type theory (such as cubical type
theory) also remains for future work.
Accompanying such a general theory, we anticipate a deeper
investigation of the meta-theoretic properties of our proposed
approach. For example, the Agda implementation is limited by
the expressivity of rewrite rules, and complicated by the explicit universe construction, while a proper extension of MLTT
would allow for the investigation of meta-theoretic properties
like decidability of type checking and strong normalization
using techniques like normalization-by-evaluation (and potentially settling the conjecture of II-B). Furthermore, we have
not touched at all on the potential models of our system, topic
which deserves we feel deserves careful attention.
R EFERENCES
[1] N. Gambino and J. Kock, "Polynomial functors and polynomial monads," Mathematical Proceedings of the Cambridge Philosophical Society, vol. 154, no. 1, p. 153–192, 2013.
[2] J. C. Baez and J. Dolan, "Higher-dimensional algebra iii. n-categories
and the algebra of opetopes," Advances in Mathematics, vol. 135, no. 2,
pp. 145–206, 1998.

[3] J. Kock, A. Joyal, M. Batanin, and J.-F. Mascari, "Polynomial functors
and opetopes," Advances in Mathematics, vol. 224, no. 6, pp. 2690–
2737, 2010.
[4] D. Gepner, R. Haugseng, and J. Kock, "∞-operads as analytic monads,"
arXiv preprint arXiv:1712.06469, 2017.
[5] J. Cockx, N. Tabareau, and T. Winterhalter, "The Taming of the
Rew: A Type Theory with Computational Assumptions," Proceedings
of the ACM on Programming Languages, 2020. [Online]. Available:
https://hal.archives-ouvertes.fr/hal-02901011
[6] B. Van Den Berg and R. Garner, "Types are weak ω-groupoids,"
Proceedings of the london mathematical society, vol. 102, no. 2, pp.
370–394, 2011.
[7] P. L. Lumsdaine, "Weak ω-categories from intensional type theory," in
International Conference on Typed Lambda Calculi and Applications.
Springer, 2009, pp. 172–187.
[8] P. R. North, "Towards a directed homotopy type theory," Electronic
Notes in Theoretical Computer Science, vol. 347, pp. 223–239, 2019.
[9] E. Riehl and M. Shulman, "A type theory for synthetic ∞-categories,"
arXiv preprint arXiv:1705.07442, 2017.
[10] D. Annenkov, P. Capriotti, and N. Kraus, "Two-level type theory and
applications," CoRR, vol. abs/1705.03307, 2017. [Online]. Available:
http://arxiv.org/abs/1705.03307
[11] Agda development team, "Agda 2.6.1.1 documentation," 2020. [Online].
Available: https://agda.readthedocs.io/en/v2.6.1.1/
[12] P. Martin-Löf, "An intuitionistic theory of types: Predicative part," in
Studies in Logic and the Foundations of Mathematics. Elsevier, 1975,
vol. 80, pp. 73–118.
[13] T. Univalent Foundations Program, Homotopy Type Theory: Univalent
Foundations of Mathematics. Institute for Advanced Study: https://
homotopytypetheory.org/book, 2013.
[14] T. Altenkirch, N. Ghani, P. G. Hancock, C. McBride, and P. Morris,
"Indexed containers," J. Funct. Program., vol. 25, 2015. [Online].
Available: https://doi.org/10.1017/S095679681500009X
[15] G. Huet, "Confluent reductions: Abstract properties and applications
to term rewriting systems," J. ACM, vol. 27, no. 4, p. 797–821, Oct.
1980. [Online]. Available: https://doi.org/10.1145/322217.322230
[16] A. Allioux, E. Finster, and M. Sozeau, "Types are internal ∞-groupoids
(extended version)," arXiv preprint, 2021.
[17] F. Blanqui, G. Genestier, and O. Hermant, "Dependency pairs
termination in dependent type theory modulo rewriting," CoRR, vol.
abs/1906.11649, 2019. [Online]. Available: http://arxiv.org/abs/1906.
11649
[18] B. Ahrens, K. Kapulkin, and M. Shulman, "Univalent categories and
the rezk completion," Mathematical Structures in Computer Science,
vol. 25, no. 5, pp. 1010–1039, 2015.
[19] T. Leinster, Higher operads, higher categories. Cambridge University
Press, 2004, no. 298.

A PPENDIX
Lemma 3 (Strong confluence for the μ-η-r/μ-μ pair). We fix a
monad M and show that the two rules can always be joined:
if t μ-η-r t0 and t μ-μ t00 then t00 ∗ t0 .
Proof. In case of overlap, the first application reduces in one
step:
μ (μ c δ) (λ p → η (Typ (μ c δ) p))

μ-η-r

μcδ

We show that applying the μ-μ rule instead results in the
same term, where only one rule applies on a given subterm at
each step:
μ (μ c δ) (λ p → η (Typ (μ c δ) p))

μ-μ,β

μ c (λ p → μ (δ p) (λ q → η (Typ (μ c δ) (μ-pos p q))))
Typ-μ

μ c (λ p → μ (δ p) (λ q →

η (Typ (δ (μ-pos-fst c δ (μ-pos p q)))
(μ-pos-snd c δ (μ-pos p q)))))
(μ-pos-fst),μ-pos-snd

μ c (λ p → μ (δ p) (λ q → η (Typ (δ p) q)))
μ-η-r

μ c (λ p → δ p)))

η

For the inductive case, that is, when σ = nd c δ , evaluating
the decoration φ on the position corresponding to the base
of our tree, that is φ (inl tt), we obtain a 4-tuple (j 0 , r, d, τ )
where j 0 : Idx↓ M ↓ i, r : j 0 ≡ j, d : Cns↓ M ↓ c j 0 and τ :
Typ↓ M ↓d ≡ ν. Then we define

μcδ

Theorem 1. Let (M , M ↓) be a monad extension. Then slice
extension (M1 , M ↓1 ) is algebraic.
Proof. Unfolding the definitions, we have that Idx M1 is the
iterated sum:
X
X
X
(i:Idx M ) (j:Idx↓ M ↓ i) (c:Cns M i)

(4)

(p : Pos M c) → Idx↓ M ↓ (Typ M c p)
and for a given (i, j, c, ν), the type Idx↓ M ↓1 (i, j, c, ν) of
dependent indices is itself an iterated sum of the form:
X
X
X
Typ↓ M ↓ d ≡ ν
(j:Idx↓ M ↓ i) (r:j≡j 0 ) (d:Cns↓ M ↓ c)

In other words, if the tuple (i, j, c, ν) is seen as a constructor
in c with inputs and output decorated by elements of Idx↓ M ↓,
then a element (j 0 , r, d, τ ) lying over it is simply a constructor
of the dependent monad M ↓ over c whose intrinsic typing
information (that is, indices assigned by the underlying dependent polynomial of M ↓) matches the decoration of c.
The constructors follow a similar pattern, but now assembled into trees: a constructor of the base monad M1 is a tree
σ whose internal nodes carry the additional information of a
decoration of their incoming and outgoing edges by elements
of Idx↓ M ↓. A constructor of M ↓1 lying over σ is itself a tree
σ↓ built from dependent constructors of M ↓, and carrying the
additional information of equalities witnessing that the typing
information of each node agrees with the decoration of the
node it lies over in σ, in the sense of the previous paragraph.
Now, the situation of the theorem is the following: we
are given a 4-tuple (i, j, c, ν) : Idx M1 and a tree σ :
Cns M1 (i, j, c, ν) together with a decoration of this tree φ
which assigns to each of the positions of σ, that is, to each of
its nodes, an index living in Idx↓ M ↓1 , which as we have seen,
means a single dependent constructor together with proofs that
its typing information matches the local decoration of the node
in σ. To prove the theorem, we must produce in this situation
three pieces of data:

ω = (j 0 , r , μ↓M ↓ d δ↓0 , τ 0 )
σ↓ = nd↓(d , τ ) (λp → δ↓0 p , τ 0 p q) ↓0
ζ = β * ζ0
in which the decorations δ↓0 and ↓0 , as well as the typing
compatibilities τ 0 and ζ 0 are obtained from the induction
hypothesis, and β is a coherence asserting that the typing information of a constructor is unchanged when it is transported
along an equality of indices.
In summary: the decoration φ assigns to each node of
the tree σ a dependent constructor lying over the constructor
occupying that node, together with compatibility information
about the typing. By induction on σ, we accumulate these
dependent constructors into dependent tree σ↓ lying over σ,
and at the same time accumulate witnesses that the typing of
the nodes in the resulting tree agrees with φ, which it clearly
does by construction.
To show uniqueness, we need to see that any other triple
(ω 0 , σ↓0 , ζ 0 ) is equal to the one defined above. The proof again
proceeds by induction on the given tree σ, and the crucial
point is that all the data of this 3-tuple can be eliminated
away. To see this, let us expand ω 0 = (j 0 , r, d, τ ). Now,
r : j 0 ≡ j, so we may eliminate and assume j 0 = j. Similarly,
ζ 0 : Typ↓ M ↓1 σ↓0 ≡ φ is just an equality between the typing
function for σ↓0 and the original decoration φ. Since φ was
a free parameter to begin with, we can freely eliminate ζ 0
at this point and assume that φ actually is typing function
σ↓0 . We are left with just the dependent tree σ↓0 and the
remaining two elements of ω 0 , namely (d, τ ). But now, as we
proceed by induction on σ, we can also proceed by induction
on the dependent tree σ↓0 . And in fact, this completely forces
the values of (d, τ ) via the indexing of dependent trees:
for example, when σ = lf (i , j), the only valid possibility
for σ↓0 is lf↓(j , refl), and in this case, we necessarily have
(d, τ ) = (η↓M ↓(j , refl) , η-dec↓ refl) as required. The nd
case is similar, even if the path algebra is considerably more
involved.

And moreover, we must show that the space of all such data
is contractible.
We will construct this data by induction on the tree σ. In
the case that σ = lf (i , j) we have necessarily that c = η M i
and ν = η-dec j, and we may take

Theorem 2. Suppose (M, M ↓) is a monad extension and X :
OpetopicType M an opetopic type such that R X is fibrant.
Moreover, suppose we are given the data of
• An equivalence e0 : (i : Idx M ) → Idx↓ M ↓ i ' X0 i
• An equivalence e1 : (i : Idx M1 ) → Idx↓ M ↓1 'e0 X1
over e0
• Proofs that s : η↓M ↓ ≡e0 ,e1
η-algm2 and t :
μ↓M ↓ ≡e0 ,e1 μ-algm2
Then there is an equivalence of opetopic types

ω = (j , refl , η↓ M ↓ j , η-dec↓ refl)

X 'o ↓OpType M M ↓

•
•
•

An index ω : Idx↓ M ↓1 (i, j, c, ν)
A dependent tree σ↓ : Cns↓ M ↓1 ω
A proof that ζ : Typ↓ M ↓1 σ↓ ≡ φ

σ↓ = lf↓ (j , refl)
ζ = funext ⊥-elim

Proof. The proof is by coinduction, and so it suffices to
produce elements e00 , e01 , s0 , t0 whose types are the same as

those of the corresponding elements in the hypotheses, but
modified by the transformations
(M, M ↓)

7→

(M1 , M ↓1 )

X

7→

RX

Next, we observe that it follows from univalence that the
equivalences e0 and e1 can be eliminated from the hypotheses
since the opetopic type X is abstract. In other words, we are
free to assume that X0 = Idx↓ M ↓ and X1 = Idx↓ M ↓1 so
that the first remaining abstract family of X is
X2 : Idx M2 → U
Moreover, after making these simplifications, the equalities s
and t take the following types:
s : (i : Idx P M ) (j : Idx↓ P M ↓i)
→ (j, η↓P M ↓ j) ≡ η-algm2 (fst i) (snd i)
t : (i : Idx P M ) (c : Cns P M i)

When σ = lf (i, j) and σ↓ = lf (j, refl), we must produce
an element of X2 of type:
X2 (is , js , lf (i, j), φ)
where
is = (i , j , η M i , η-dec j)
js = (j , refl , η↓ M ↓ j , η-dec↓ refl)
on the other hand, we have an element
x2 : X2 (is , (η-algm2 is (lf (i, j)) φ) , lf (i, j) , φ)
x2 = snd (ctr (m2 (lf (i , x)) φ))
since η-algm2 is defined using the multiplicativity of the
relation X2 . But the term s (i , j) (j , refl) obtained from the
hypothesis s now gives
js ≡ η-algm2 is (lf (i, j)) φ
and we so we obtain the desired result by transporting x2
along this equality.

→ (δ : Pos P M c) → Cns P M (Typ P M c p)

Before moving on to the inductive case of a node, let us
pause
to anticipate how we intend to prove the equations s0
→ (j : Idx↓ P M ↓ i)(d : Cns↓ P M ↓ j c)
0
and t , as this will have serious consequences for how we
→ (δ↓ : (p : Pos P M c) → Cns↓ P M ↓ (Typ↓ P M ↓ d p) (δ p))
proceed. These equations will now be over the equivalence e01
→ (j, μ↓P M ↓ d δ↓) ≡
which we are in the process of constructing. Specifically, they
take the form
μ-algm2 (fst i) (fst c) (snd c) δ (snd i) (j , d)
(λp → (Typ↓ M ↓, (fst d)p , snd d p) , δ↓ p)
where we have set
P M = Pb M (Idx↓ M ↓)

s0 : (i : Idx P M1 ) (j : Idx↓ P M ↓1 i)
→ e01 (i, ηP M1 i) (j, η↓P M ↓1 j) ≡
η-algm3 (fst i) (snd i)

P M ↓ = Pb↓ M ↓ (λ j k → j ≡ k)
to simplify the notation.
Now, we may take e00 to be the identity, since e1 is the
identity. It therefore remains to construct the equivalence e01
of type
(i : Idx M2 ) → Idx↓ M ↓2 i ' X2 i
and check the two required equations. We claim that it in fact
suffices to construct a map
e : (i : Idx M2 ) → Idx↓ M ↓2 i → X2 i
and that any such map is necessarily an equivalence. This
follows from the fact that both Idx↓ M ↓2 and X2 are multiplicative relations. The former by Theorem 1 and the latter by
assumption.
Now, unfolding all the definitions and eliminating the redundancies, we find that the map e depends on the data of a tree
σ : Cns M1 (i, j, c, ν) where (i, j, c, ν) : Idx M1 , a decoration
φ of the nodes of this tree in the family Idx↓ M ↓1 , a dependent
tree σ↓ living over σ and a proof φ↓ that the typing function
of σ↓ agrees with the data determined by φ (the situation is
analogous to that encountered in the proof of Theorem 1). We
may therefore proceed by simultaneous induction on σ and
σ↓.

t0 : (i : Idx P M1 ) (c : Cns P M1 i)
→ (δ : Pos P M1 c) → Cns P M1 (Typ P M1 c p)
→ (j : Idx↓ P M ↓1 i)(d : Cns↓ P M ↓1 j c)
→ (δ↓ : (p : Pos P M1 c)
→ Cns↓ P M ↓1 (Typ↓ P M ↓1 d p) (δ p))
→ e01 (i, μP M1 c δ) (j, μ↓P M ↓1 d δ↓) ≡
μ-algm3 (fst i) (fst c) (snd c) δ (snd i) (j , d)
(λp → (Typ↓ M1 ↓, (fst d)p , snd d p) , δ↓ p)
where now each of monads have advanced by a single slice
P M1 = Pb M1 (Idx↓ M1 ↓)
P M ↓1 = Pb↓ M ↓1 (λ j k → j ≡ k)
Furthermore, the left side of each equality now includes an
application of the equivalence e01 , and the right side uses
the unit and multiplicative operators η-algm3 and μ-algm3
corresponding to the fact that the next family X3 is also
multiplicative.
What this means is that, if we want to ensure that the
equivalence e01 sends the required elements to applications
of the unit η-algm3 and multiplication μ-algm3 functions, we
will need to use these functions in the definition of e01 and
furthermore, we need to use them both. But since the unit case

η-algm3 in the next dimension corresponds to a corolla, that
is, a tree with a single node in the present dimension, we will
need to now make a case split depending on whether or not the
node in the tree σ we are recursing on has descendants or not.
This is possible as soon as the monad M we are considering
is finitary in the sense that the type of positions is merely
equivalent to finite type. In this case, the the property of a
tree being a corolla becomes decidable, and so we can make
the required case split. This is not a problem for our intended
application since it is easily checked that the identity monad
has this property and, moreover, that it is inherited both by
pulling back and slicing. Consequently, we will freely proceed
now under this hypothesis.
Now, returning to the definition of our equivalence e01 . We
are in the inductive case so that we have σ = nd (c , ν) δ  and
σ↓ = nd (c↓ , ν↓) δ↓ ↓. Our goal is to produce an element of
type
X2 (is , js , nd (c , ν) δ , φ)
where now
is = (i , j , μ P M (c , ν) δ)
js = (j , refl , μ↓ P M ↓ (c↓ , ν↓) δ↓)
We now make a case distinction based on whether the tree
σ is a corolla or not. In case that it is, one can prove equalities
u : (i , j , μ P M (c , ν) δ) ≡ (i , j , c , ν)
v : (j , refl , μ↓ P M ↓ (c↓ , ν↓) δ↓) ≡ φ (inl tt)
But then the result follows from transporting the term
η-algm3 (i , j , c , ν) (φ (inl tt))
in the fibration X2 along the equalities u and v.
If σ is not a corolla, but rather has proper descendants,
then we proceed as follows: by appealing to the induction
hypothesis, we obtain a family of elements of X2 parameterized by the positions p : Pos M c. These assemble, together
with the witness for the binary multiplication of c↓ and δ↓
under μ-algx2 , into the arguments for μ-algx3 , which has the
correct type up to a transport along the equality given by our
hypothesis t.
This completes the definition of e01 and, as the reader can
see, we have thus achieved our goal of using the multiplicative
operators η-algm3 and μ-algm3 in the construction of the
required equivalence. It remains to check the equations s0
and t0 above, a long calculation which we will not reproduce
here. It is not hard to see that, up to some path algebra, s0
is by definition. Verifying t0 is slightly more involved: in this
case, one must proceed by induction on the trees occurring
in the arguments c and c↓, again splitting into three cases:
that of a leaf, a corolla, and a tree with at least 2 nodes.
Additionally, during the course of the induction, one uses that
the operators η-algm3 and μ-algm3 are themselves associative
and unital under the assumption that the opetopic type X was
fibrant.

