anytime decoding by montecarlo tree search

arxiv210500056v1 csit 30 apr 2021

aolin xu

abstractan anytime decoding algorithm for tree codes using
montecarlo tree search is proposed the meaning of anytime
decoding here is twofold 1 the decoding algorithm is an anytime algorithm whose decoding performance improves as more
computational resource measured by decoding time is allowed
and 2 the proposed decoding algorithm can approximate the
maximumlikelihood sequence decoding of tree codes which has
the anytime reliability when the code is properly designed the
above anytime properties are demonstrated through experiments
the proposed method may be extended to the decoding of convolutional codes and block codes by montecarlo trellis search
to enable smooth complexityperformance tradeoffs in these
decoding tasks some other extensions and possible improvements
are also discussed

i i ntroduction
a tree code
tree code is a type of error correction code for which
the encoding can be performed sequentially as tree traversal
starting from a root node in the ith encoding step the ith
information symbol determines which child node to traverse
and the ith encoded symbol is taken as the label on the branch
towards the chosen child node for example a rate kn tree
code encoding d information symbols defined over 0 1k can
be described by a regular 2k ary tree of depth d where each
nonleaf node has 2k child nodes and each branch has a label
drawn from 0 1n  figure 1 shows such an example with
k  1 n  2 and d  4 many familiar error correction
codes can be represented as tree codes examples include
the convolutional codes 1 and the block codes both linear
2 and nonlinear 3 as both types of codes have trellis
representations which can be expanded to trees
an interesting property a tree code can have is the anytime
reliability 4 meaning that the probability of decoding error
of each information symbol can be exponentially smaller as
the delay for decoding that symbol linearly increases tree
codes with anytime reliability are shown to be essential for
interactive communication over noisy channels 5 and for stabilizing an unstable linear system over a noisy channel 4 the
anytime reliability of random convolutional codes over binary
symmetric channel is claimed in the original paper where the
convolutional code was proposed 6 the existence of tree
codes with explicit distance properties that guarantee anytime
reliability under maximumlikelihood sequence decoding is
proved in 5 recent studies on more explicit constructions
of codes having such a property include 79
xuaolingmailcom

fig 1 a tree code example with k  1 n  2 d  4 the encoding path
for the information sequence 0 1 1 0 is shown in bold

b decoding by tree search
a natural choice for decoding a tree code is the maximumlikelihood sequence decoding mlsd over a discrete memoryless channel dmc the mlsd reduces to the minimum
distance decoding which is equivalent to searching for the
minimumlength path from the root node to a leaf node
the length of each candidate path is the summation of the
hamming distance between the label on the i branch in that
path and the ith received symbol over i  1     d the
complexity of full search on a 2k ary tree of depth d is
proportional to the number of leaves which is o2kd 
to manage the decoding complexity at the expense of
compromising the optimality in the sense of mlsd a number
of approximate treesearch decoding algorithms have been
proposed mostly in the early literature of convolutional code
decoding 10 11 chapter 8 prominent examples are sequential decoding and stack decoding the complexity of
which are random variables and are likely to be small when
the channel noise is light other examples include feedback
decoding and majority logic decoding or threshold decoding
where the complexity can be explicitly controlled by restricting
the search depth which however results in inferior decoding
performance this paper presents a novel approximate treesearch decoding method for which the complexity determined
by the run time can be explicitly controlled and the performance constantly improves as the run time increases the
method is based on montecarlo tree search
c montecarlo tree search
montecarlo tree search mcts is a heuristic tree search
algorithm first proposed in the filed of computer game playing
12 13 it served as a major workhorse for the recent
breakthroughs of computer go 14 15 in mcts each
node in the tree represents a state in a game or a decisionmaking problem while each branch emanating from that node
corresponds to a move or an action and is associated with a
reward the goal is to find a move from the root node with

the largest expected accumulated reward towards a leaf node
the core ideas behind mcts are selecting the most promising
move at each node while maintaining sufficient exploration
during the search and expanding the search tree based on
random samplings of the search space the major advantage
of mcts is its low complexity for a 2k ary tree of depth
d the complexity of mcts is omd where m is the total
number of rounds of search to run this is in contrast to the
exponential complexity of o2kd  for the full tree search
at the same time mcts is an anytime algorithm meaning
that it can be stopped at any time and would return the best
result it has found so far and its result gradually improves if
more rounds of search are run being an anytime algorithm is a
desirable feature for the algorithms used in intelligent systems
16 as it allows for flexible tradeoffs between complexity
and performance of an algorithm

to evaluate the q function and for each node there are 2k
entries this decoding method will serve as the benchmark for
both the complexity and the performance in the experiments
b proposed decoding algorithm
1 singleround decoding we first consider a basic decoding algorithm based on mcts the singleround decoding
which is an approximation of mlsd it is adapted from the
upper confidence bound for trees uct implementation of
mcts 13 the algorithm involves running many rounds of
search during which an estimate of the q function defined
in 2 denoted as qs a is constantly updated each round
of search starts from the root node and ends at a leaf node
and can be executed in a recursive manner there are three
stages in each round of search


selection if the current state in the search is in the set t 
initially empty then the search enters the selection stage
otherwise it proceeds to the expansion stage during the
selection stage the function qs a is updated for the states
and actions visited and tried in the search the number of
times n s a an action a has been taken at a state s is also
tracked during the selection at each state the action that
maximizes
s
log n s

5
qs a  c
n s a
p
is taken where n s  aa n s a is the total number
of times the state s has been visited and c is a parameter
that controls the amount of exploration in the search the
second term in 5 can be thought as an exploration bonus
that encourages selecting actions that have not been tried as
frequently once an action is taken a reward as in 1 is
received and the state transits to the child node where the
action leads to the selection stage can be executed recursively until a leaf node or a node not in t is reached 17
18 at the end of each selection stage the accumulated
reward is returned either from a subselection stage or from
the exploration stage and is used to update the value for
qs a



expansion once a state s that is not in the set t is reached
the function values n s a and qs a are initialized with
n0 s a and q0 s a respectively by iterating over all of
the actions available at that state the initializing functions
n0 and q0 can be simply allzero or can be based on
any available prior knowledge of the decoding problem the
state is then added to the set t 



exploration after the expansion stage the actions are selected according to some default exploration policy 0  the
exploration policy does not have to be close to optimal but
it is a way to bias the search into areas that are promising
it can be stochastic eg sampling a from a uniformly at
random or can be in a deterministic roundrobin fashion
the reward generation and state transition in the exploration
stage is the same as in the selection stage the exploration

ii d ecoding by m onte c arlo tree search
a tree search as sequential decision making
as reviewed in section ib for a tree code transmitted over
a dmc the mlsd is equivalent to the minimumlength path
search searching for a minimumlength path over a tree can
be further cast as a sequential decisionmaking problem as
follows each node s in the tree represents a state in this
decisionmaking problem the branches emanating from this
node towards its child nodes represent the available actions
as at this state and each branch a  as is associated
with a reward
rs a  n  dh xs a yi 

1

where dh denotes the hamming distance xs a is the label
on the branch a and yi is the ith received encoded symbol
assuming that the branch a is at depth i in the tree at each
state once an action is chosen the next state becomes the
child node where the chosen branch leads to the goal is to
sequentially choose actions from the root node to a leaf node
to maximize the accumulated reward
this sequential decisionmaking problem can be straightforwardly solved by dynamic programming through backward
tracking define v  s  0 for all the leaf nodes s for each
nonleaf node s and each a  as define recursively
q s a  rs a  v  s0 

2

where s0 is the next state when a is chosen at state s and
v  s  max q s a
aas

3

with the function q  the optimal actions of the sequential
decisionmaking problem can be found as
i  arg max q s a

4

aas

for i  1     d where s evolves from the root node to a leaf
node according to each i  the sequence 1      d  form
an mlsd solution
on a 2k ary tree with depth d the complexity of the above
computation is o2kd1  as there are 2kd  1 nonleaf nodes

stage can also be executed recursively until a leaf node or
a desired depth is reached
the singleround decoding is run until some stopping criterion is met which could simply be a fixed number of rounds
of search the information symbols can then be decoded
sequentially by taking the action that maximizes qs a at
each state from the root node to an leaf node
algorithm 1 below presents a detailed example of the singleround decoding method described above where the number of
rounds of search is fixed to m the tree is assumed to have
depth d and the received sequence of encoded symbols is
denoted by y
algorithm 1 singleround decoding by mcts
1 global variables t  n   q 
2 function d ecode b y mctsd m y
3
i  0 t   n    0 q   0
4
while i  m do
5
s earchroot d y
6
ii1
7
s1  root
8
for j  1 to d do
9
j  arg maxaasj  qsj  a
10
sj1  n ext s tatesj  j 
11
return 1      d 
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34

function s earchs d y
if d  0 then
return 0
if s 
 t then
for a  as do
n s a qs a  n0 s a q0 s a
t  t  s
return e xplores d y
p
n s  aas n s a
q
n s
a  arg maxaas qs a  c log
n sa
r  r ewards a y
s0  n ext s tates a
q  r  s earchs0  d  1 y
n s a  n s a  1
q
1
qs a  n sa
qs a  1  n sa
return q
function e xplores d y
if d  0 then
return 0
a  0 s
r  r ewards a y
s0  n ext s tates a
return r  e xplores0  d  1 y

c slidingroot mcts decoding
in the singleround mcts decoding described above each
search starts from the root node and ends at a leaf node

and finally all d information symbols are decoded when d
is large this method may not work well with an affordable
number of rounds of search especially for the information
symbols with large indices ie those near the leaf nodes the
decoding error can be high one way to improve is performing
multiple rounds of mcts decoding where the root of the
search in the successive rounds of decoding slides toward the
leaf nodes according to the previously decoded information
symbols moreover the depth of search can be smaller than d
and different for different rounds of decoding
for example a total number of d rounds of decoding can be
performed where in the ith round of decoding each round of
search starts from a node in the ith level of the tree determined
by the previously decoded information symbols and in the end
of the ith round of decoding only the ith information symbol
is decoded the depth of search in the ith round of decoding
can be d  1  i which allows it to search to a leaf node or
it can be some number smaller than d  1  i
d support for anytime reliability
to support anytime reliability the decoding does not need to
wait for receiving all d encoded symbols to start instead the
ith information symbol can start to be decoded immediately
after the ith encoded symbol is received
one specific way to support anytime reliability is to perform
d rounds of mcts decoding where the ith round of decoding
starts immediately after the ith encoded symbol is received
and each search in that round starts from the root node and
ends at a leaf node in the ith level in the tree namely the
depth of search is i in the end of the ith round of decoding
the first i information symbols are decoded the larger the
i is the more reliable the decoded information symbols are
moreover the earlier an information symbol is sent the more
reliably it can be decoded
iii e xperiments
two tree codes are used for performing experiments on the
proposed algorithm both of them are binary codes with rate
12 namely k  1 and n  2 one of them has depth 10
and the other has depth 25 each code is selected from a pool
of randomly generated codes with the specified parameters
to have the best decoding performance under mlsd the
codeword is sent over a bsc with crossover probability 01
for mcts decoding the parameter c in 5 is set to be in
the same order as the search depth
figures 2 to 4 show the bit error rate ber for multiple
rounds of mcts decoding that supports anytime reliability
with the code with depth 10 the number of rounds of search
in each round of decoding is set to m  10 100 and 1000
respectively the grey curves in figure 3 and figure 4 indicate
ber for mlsd from these figures it is seen that 1 the
decoding performance increases as m is increased when m is
increased to 1000 the ber of mcts decoding is even lower
than the mlsd which should not be surprising as mlsd
minimizes the sequence error rate not necessarily the ber
and 2 for each bit the ber decreases as the decoding delay

increases namely when it is decoded in a later round we
can also see the unequal error protection ability of this coding
and decoding scheme that is the bits sent earlier are better
protected against the channel noise while the most recently
sent bits can have a decoding error rate even larger than the
channel transition probability this is a natural property of
random tree codes by increasing the code length more bits
can be protected by the increased search depth
figures 5 and 6 show the same ber plots for the code with
depth 25 one is for the mcts decoding with m  1000 and
the other is for mlsd it can be seen that with a much lower
computation complexity the mcts decoding has comparable
performance with mlsd for bits with indices i  4 at the
same time the ber for the bits with large index can be much
higher than those with smaller indices which is a downside to
have all the bits decoded in a singleround mcts decoding
to further improve the decoding performance one could either
increase m or perform slidingroot mcts decoding
figure 7 compares the bers for the slidingroot mcts
decoding the slidingwindow full search decoding and the
mlsd on the code with depth 25 for the slidingroot mcts
decoding every search is run to the leaf node and m  2048
rounds of search is run in each round of decoding while for
the slidingwindow full search decoding the search depth is
set to 10 so that these two decoding methods have roughly
the same computational complexity it can be seen that for
bits with smaller indices eg i  7 the slidingroot mcts
decoding performs slightly better than the slidingwindow full
search decoding under similar computation complexity

fig 3 ber for multiple rounds of mcts decoding supporting anytime
reliability with d  10 and m  100 grey curves indicate ber for mlsd

fig 4 ber for multiple rounds of mcts decoding supporting anytime
reliability with d  10 and m  1000 grey curves indicate ber for
mlsd

fig 2 ber for multiple rounds of mcts decoding supporting anytime
reliability with d  10 and m  10


iv p ossible improvements and extensions
some possible improvements and extensions of the proposed decoding method are listed below


reuse of qs a

when multiple rounds of mcts decoding are performed
the values of qs a obtained in each round of decoding
may be reused for the future rounds this reuse may
improve the decoding performance without a heavy increase
of the computation complexity following the practice in
alphago 14 15 qs a as a function of s a can
even be represented by neural networks and updated by a
reinforcement learning scheme
support for soft output andor soft input
the proposed decoding method can be modified to support
the soft output or reliability for each information symbol
for example with the slidingroot mcts decoding the
probability of the ith information symbol being a can be
computed as z1 eqsa  where s is the node determined by





the hard decisions of the previous information symbols 
is a parameter that can be tuned and z is a normalization
factor the soft input may also be supported by incorporating any prior knowledge into the initialization functions q0
and n0 
decoding by montecarlo trellis search
the proposed decoding method based on mcts can be
naturally extended to decoding codes with a trellis structure
instead of searching over a tree the proposed method can
be used for searching for the minimumlength path over a
trellis which amounts to the mlsd decoding of the trellis
codes over dmc the decoding method may be termed as
decoding by montecarlo trellis search
decoding irregular tree codes
the proposed decoding method can also be used for irregular tree codes eg the recently proposed polaradjusted
convolutional pac codes 19
fig 6 ber for mlsd with d  25

fig 5 ber for multiple rounds of mcts decoding supporting anytime
reliability with d  25 and m  1000

fig 7 ber for slidingroot mcts decoding with d  25 and m  2048
compared with ber for slidingwindow full search decoding with search
depth 10 and ber for mlsd

r eferences
1 j wozencraft sequential decoding for reliable communication research lab of electronics mit tech rep 1957
2 l bahl j cocke f jelinek and j raviv optimal decoding of
linear codes for minimizing symbol error rate ieee transactions on
information theory vol 20 no 2 pp 284287 1974
3 f r kschischang and v sorokine on the trellis structure of block
codes ieee transactions on information theory vol 41 no 6 pp
19241937 1995
4 a sahai and s mitter the necessity and sufficiency of anytime
capacity for stabilization of a linear system over a noisy communication
link part i scalar systems ieee trans inform theory vol 52 no 8
pp 33693395 2006
5 l schulman coding for interactive communication ieee trans
inform theory vol 42 no 6 pp 17451756 1996
6 p elias coding for noisy channels ire conv rec pp 3746 mar
1955
7 r t sukhavasi and b hassibi linear timeinvariant anytime codes for
control over noisy channels ieee transactions on automatic control
vol 61 no 12 pp 38263841 2016

8 l grosjean l k rasmussen r thobaben and m skoglund systematic ldpc convolutional codes asymptotic and finitelength anytime
properties ieee transactions on communications vol 62 no 12 pp
41654183 2014
9 m noorarahim k d nguyen and g lechner anytime reliability
of spatially coupled codes ieee transactions on communications
vol 63 no 4 pp 10691080 2015
10 s lin and d j costello error control coding 2nd ed pearson
2005
11 j g proakis and m salehi digital communications 5th ed mcgrawhill education 2007
12 r coulom efficient selectivity and backup operators in montecarlo
tree search in proceedings computers and games springerverlag
2006
13 l kocsis and c szepesvri bandit based montecarlo planning in
european conference on machine learning springer 2006
14 d silver a huang c j maddison a guez l sifre g van den
driessche j schrittwieser i antonoglou v panneershelvam m lanctot s dieleman d grewe j nham n kalchbrenner i sutskever
t lillicrap m leach k kavukcuoglu t graepel and d hassabis

15

16
17
18
19

mastering the game of go with deep neural networks and tree search
nature vol 529 no 7587 pp 484489 jan 2016
d silver j schrittwieser k simonyan i antonoglou a huang
a guez t hubert l baker m lai a bolton y chen t lillicrap
f hui l sifre g van den driessche t graepel and d hassabis
mastering the game of go without human knowledge nature vol
550 no 7676 pp 354359 oct 2017
s zilberstein using anytime algorithms in intelligent systems ai
magazine vol 17 no 3 p 73 mar 1996
h s chang m c fu j hu and s i marcus an adaptive sampling
algorithm for solving markov decision processes operations research
vol 53 no 1 pp 126139 2005
m j kochenderfer decision making under uncertainty theory and
application mit press 2015
e arkan from sequential decoding to channel polarization and back
again ieee information theorey society newsletter sep 2019

